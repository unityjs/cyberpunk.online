var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/tsup@6.6.3_typescript@4.9.5/node_modules/tsup/assets/cjs_shims.js
var init_cjs_shims = __esm({
  "node_modules/.pnpm/tsup@6.6.3_typescript@4.9.5/node_modules/tsup/assets/cjs_shims.js"() {
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/driver.js
var require_driver = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/driver.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var driver = null;
    module2.exports.get = function() {
      return driver;
    };
    module2.exports.set = function(v) {
      driver = v;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/binary.js
var require_binary = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/binary.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Binary = require("mongodb").Binary;
    module2.exports = exports2 = Binary;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/connectionstate.js
var require_connectionstate = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/connectionstate.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var STATES = module2.exports = exports2 = /* @__PURE__ */ Object.create(null);
    var disconnected = "disconnected";
    var connected = "connected";
    var connecting = "connecting";
    var disconnecting = "disconnecting";
    var uninitialized = "uninitialized";
    STATES[0] = disconnected;
    STATES[1] = connected;
    STATES[2] = connecting;
    STATES[3] = disconnecting;
    STATES[99] = uninitialized;
    STATES[disconnected] = 0;
    STATES[connected] = 1;
    STATES[connecting] = 2;
    STATES[disconnecting] = 3;
    STATES[uninitialized] = 99;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/immediate.js
var require_immediate = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/immediate.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var nextTick = process.nextTick.bind(process);
    module2.exports = function immediate(cb) {
      return nextTick(cb);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/collection.js
var require_collection = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/collection.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var EventEmitter = require("events").EventEmitter;
    var STATES = require_connectionstate();
    var immediate = require_immediate();
    function Collection(name, conn, opts) {
      if (opts === void 0) {
        opts = {};
      }
      if (opts.capped === void 0) {
        opts.capped = {};
      }
      if (typeof opts.capped === "number") {
        opts.capped = { size: opts.capped };
      }
      this.opts = opts;
      this.name = name;
      this.collectionName = name;
      this.conn = conn;
      this.queue = [];
      this.buffer = true;
      this.emitter = new EventEmitter();
      if (STATES.connected === this.conn.readyState) {
        this.onOpen();
      }
    }
    Collection.prototype.name;
    Collection.prototype.collectionName;
    Collection.prototype.conn;
    Collection.prototype.onOpen = function() {
      this.buffer = false;
      immediate(() => this.doQueue());
    };
    Collection.prototype.onClose = function(force) {
      if (this._shouldBufferCommands() && !force) {
        this.buffer = true;
      }
    };
    Collection.prototype.addQueue = function(name, args) {
      this.queue.push([name, args]);
      return this;
    };
    Collection.prototype.removeQueue = function(name, args) {
      const index = this.queue.findIndex((v) => v[0] === name && v[1] === args);
      if (index === -1) {
        return false;
      }
      this.queue.splice(index, 1);
      return true;
    };
    Collection.prototype.doQueue = function() {
      for (const method of this.queue) {
        if (typeof method[0] === "function") {
          method[0].apply(this, method[1]);
        } else {
          this[method[0]].apply(this, method[1]);
        }
      }
      this.queue = [];
      const _this = this;
      immediate(function() {
        _this.emitter.emit("queue");
      });
      return this;
    };
    Collection.prototype.ensureIndex = function() {
      throw new Error("Collection#ensureIndex unimplemented by driver");
    };
    Collection.prototype.createIndex = function() {
      throw new Error("Collection#createIndex unimplemented by driver");
    };
    Collection.prototype.findAndModify = function() {
      throw new Error("Collection#findAndModify unimplemented by driver");
    };
    Collection.prototype.findOneAndUpdate = function() {
      throw new Error("Collection#findOneAndUpdate unimplemented by driver");
    };
    Collection.prototype.findOneAndDelete = function() {
      throw new Error("Collection#findOneAndDelete unimplemented by driver");
    };
    Collection.prototype.findOneAndReplace = function() {
      throw new Error("Collection#findOneAndReplace unimplemented by driver");
    };
    Collection.prototype.findOne = function() {
      throw new Error("Collection#findOne unimplemented by driver");
    };
    Collection.prototype.find = function() {
      throw new Error("Collection#find unimplemented by driver");
    };
    Collection.prototype.insert = function() {
      throw new Error("Collection#insert unimplemented by driver");
    };
    Collection.prototype.insertOne = function() {
      throw new Error("Collection#insertOne unimplemented by driver");
    };
    Collection.prototype.insertMany = function() {
      throw new Error("Collection#insertMany unimplemented by driver");
    };
    Collection.prototype.save = function() {
      throw new Error("Collection#save unimplemented by driver");
    };
    Collection.prototype.update = function() {
      throw new Error("Collection#update unimplemented by driver");
    };
    Collection.prototype.getIndexes = function() {
      throw new Error("Collection#getIndexes unimplemented by driver");
    };
    Collection.prototype.mapReduce = function() {
      throw new Error("Collection#mapReduce unimplemented by driver");
    };
    Collection.prototype.watch = function() {
      throw new Error("Collection#watch unimplemented by driver");
    };
    Collection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
      const opts = this.opts;
      if (opts.bufferCommands != null) {
        return opts.bufferCommands;
      }
      if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferCommands != null) {
        return opts.schemaUserProvidedOptions.bufferCommands;
      }
      return this.conn._shouldBufferCommands();
    };
    Collection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {
      const conn = this.conn;
      const opts = this.opts;
      if (opts.bufferTimeoutMS != null) {
        return opts.bufferTimeoutMS;
      }
      if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferTimeoutMS != null) {
        return opts.schemaUserProvidedOptions.bufferTimeoutMS;
      }
      if (conn.config.bufferTimeoutMS != null) {
        return conn.config.bufferTimeoutMS;
      }
      if (conn.base != null && conn.base.get("bufferTimeoutMS") != null) {
        return conn.base.get("bufferTimeoutMS");
      }
      return 1e4;
    };
    module2.exports = Collection;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/mongooseError.js
var require_mongooseError = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/mongooseError.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = class extends Error {
    };
    Object.defineProperty(MongooseError.prototype, "name", {
      value: "MongooseError"
    });
    module2.exports = MongooseError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/objectid.js
var require_objectid = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/objectid.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ObjectId2 = require("mongodb").ObjectId;
    module2.exports = exports2 = ObjectId2;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/get.js
var require_get = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/get.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function get(obj2, path3, def) {
      let parts;
      let isPathArray = false;
      if (typeof path3 === "string") {
        if (path3.indexOf(".") === -1) {
          const _v = getProperty(obj2, path3);
          if (_v == null) {
            return def;
          }
          return _v;
        }
        parts = path3.split(".");
      } else {
        isPathArray = true;
        parts = path3;
        if (parts.length === 1) {
          const _v = getProperty(obj2, parts[0]);
          if (_v == null) {
            return def;
          }
          return _v;
        }
      }
      let rest = path3;
      let cur = obj2;
      for (const part of parts) {
        if (cur == null) {
          return def;
        }
        if (!isPathArray && cur[rest] != null) {
          return cur[rest];
        }
        cur = getProperty(cur, part);
        if (!isPathArray) {
          rest = rest.substr(part.length + 1);
        }
      }
      return cur == null ? def : cur;
    };
    function getProperty(obj2, prop) {
      if (obj2 == null) {
        return obj2;
      }
      if (obj2 instanceof Map) {
        return obj2.get(prop);
      }
      return obj2[prop];
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/getConstructorName.js
var require_getConstructorName = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/getConstructorName.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function getConstructorName(val) {
      if (val == null) {
        return void 0;
      }
      if (typeof val.constructor !== "function") {
        return void 0;
      }
      return val.constructor.name;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+sliced@1.0.1/node_modules/sliced/index.js
var require_sliced = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+sliced@1.0.1/node_modules/sliced/index.js"(exports2, module2) {
    init_cjs_shims();
    module2.exports = function(args, slice, sliceEnd) {
      var ret2 = [];
      var len = args.length;
      if (0 === len)
        return ret2;
      var start = slice < 0 ? Math.max(0, slice + len) : slice || 0;
      if (sliceEnd !== void 0) {
        len = sliceEnd < 0 ? sliceEnd + len : sliceEnd;
      }
      while (len-- > start) {
        ret2[len - start] = args[len];
      }
      return ret2;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+regexp-clone@1.0.0/node_modules/regexp-clone/index.js
var require_regexp_clone = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+regexp-clone@1.0.0/node_modules/regexp-clone/index.js"(exports2, module2) {
    init_cjs_shims();
    var toString = Object.prototype.toString;
    function isRegExp(o) {
      return "object" == typeof o && "[object RegExp]" == toString.call(o);
    }
    module2.exports = exports2 = function(regexp) {
      if (!isRegExp(regexp)) {
        throw new TypeError("Not a RegExp");
      }
      const flags = [];
      if (regexp.global)
        flags.push("g");
      if (regexp.multiline)
        flags.push("m");
      if (regexp.ignoreCase)
        flags.push("i");
      if (regexp.dotAll)
        flags.push("s");
      if (regexp.unicode)
        flags.push("u");
      if (regexp.sticky)
        flags.push("y");
      const result = new RegExp(regexp.source, flags.join(""));
      if (typeof regexp.lastIndex === "number") {
        result.lastIndex = regexp.lastIndex;
      }
      return result;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/decimal128.js
var require_decimal128 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/decimal128.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = require_driver().get().Decimal128;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/symbols.js
var require_symbols = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/symbols.js"(exports2) {
    "use strict";
    init_cjs_shims();
    exports2.arrayAtomicsSymbol = Symbol("mongoose#Array#_atomics");
    exports2.arrayParentSymbol = Symbol("mongoose#Array#_parent");
    exports2.arrayPathSymbol = Symbol("mongoose#Array#_path");
    exports2.arraySchemaSymbol = Symbol("mongoose#Array#_schema");
    exports2.documentArrayParent = Symbol("mongoose:documentArrayParent");
    exports2.documentIsSelected = Symbol("mongoose#Document#isSelected");
    exports2.documentIsModified = Symbol("mongoose#Document#isModified");
    exports2.documentModifiedPaths = Symbol("mongoose#Document#modifiedPaths");
    exports2.documentSchemaSymbol = Symbol("mongoose#Document#schema");
    exports2.getSymbol = Symbol("mongoose#Document#get");
    exports2.modelSymbol = Symbol("mongoose#Model");
    exports2.objectIdSymbol = Symbol("mongoose#ObjectId");
    exports2.populateModelSymbol = Symbol("mongoose.PopulateOptions#Model");
    exports2.schemaTypeSymbol = Symbol("mongoose#schemaType");
    exports2.sessionNewDocuments = Symbol("mongoose:ClientSession#newDocuments");
    exports2.scopeSymbol = Symbol("mongoose#Document#scope");
    exports2.validatorErrorSymbol = Symbol("mongoose:validatorError");
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/objectid.js
var require_objectid2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/objectid.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ObjectId2 = require_driver().get().ObjectId;
    var objectIdSymbol = require_symbols().objectIdSymbol;
    Object.defineProperty(ObjectId2.prototype, "_id", {
      enumerable: false,
      configurable: true,
      get: function() {
        return this;
      }
    });
    ObjectId2.prototype[objectIdSymbol] = true;
    module2.exports = ObjectId2;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/specialProperties.js
var require_specialProperties = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/specialProperties.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/isMongooseObject.js
var require_isMongooseObject = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/isMongooseObject.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(v) {
      if (v == null) {
        return false;
      }
      return v.$__ != null || // Document
      v.isMongooseArray || // Array or Document Array
      v.isMongooseBuffer || // Buffer
      v.$isMongooseMap;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/getFunctionName.js
var require_getFunctionName = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/getFunctionName.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(fn) {
      if (fn.name) {
        return fn.name;
      }
      return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/isBsonType.js
var require_isBsonType = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/isBsonType.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var get = require_get();
    function isBsonType(obj2, typename) {
      return get(obj2, "_bsontype", void 0) === typename;
    }
    module2.exports = isBsonType;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/isObject.js
var require_isObject = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/isObject.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(arg) {
      if (Buffer.isBuffer(arg)) {
        return true;
      }
      return Object.prototype.toString.call(arg) === "[object Object]";
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+ms@2.1.2/node_modules/ms/index.js"(exports2, module2) {
    init_cjs_shims();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mpath@0.8.4/node_modules/mpath/lib/stringToParts.js
var require_stringToParts = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mpath@0.8.4/node_modules/mpath/lib/stringToParts.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function stringToParts(str) {
      const result = [];
      let curPropertyName = "";
      let state = "DEFAULT";
      for (let i = 0; i < str.length; ++i) {
        if (state === "IN_SQUARE_BRACKETS" && !/\d/.test(str[i]) && str[i] !== "]") {
          state = "DEFAULT";
          curPropertyName = result[result.length - 1] + "[" + curPropertyName;
          result.splice(result.length - 1, 1);
        }
        if (str[i] === "[") {
          if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
            result.push(curPropertyName);
            curPropertyName = "";
          }
          state = "IN_SQUARE_BRACKETS";
        } else if (str[i] === "]") {
          if (state === "IN_SQUARE_BRACKETS") {
            state = "IMMEDIATELY_AFTER_SQUARE_BRACKETS";
            result.push(curPropertyName);
            curPropertyName = "";
          } else {
            state = "DEFAULT";
            curPropertyName += str[i];
          }
        } else if (str[i] === ".") {
          if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
            result.push(curPropertyName);
            curPropertyName = "";
          }
          state = "DEFAULT";
        } else {
          curPropertyName += str[i];
        }
      }
      if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
        result.push(curPropertyName);
      }
      return result;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mpath@0.8.4/node_modules/mpath/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mpath@0.8.4/node_modules/mpath/lib/index.js"(exports2) {
    init_cjs_shims();
    var stringToParts = require_stringToParts();
    var ignoreProperties = ["__proto__", "constructor", "prototype"];
    exports2.get = function(path3, o, special, map) {
      var lookup;
      if ("function" == typeof special) {
        if (special.length < 2) {
          map = special;
          special = void 0;
        } else {
          lookup = special;
          special = void 0;
        }
      }
      map || (map = K);
      var parts = "string" == typeof path3 ? stringToParts(path3) : path3;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      var obj2 = o, part;
      for (var i = 0; i < parts.length; ++i) {
        part = parts[i];
        if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
          throw new TypeError("Each segment of path to `get()` must be a string or number, got " + typeof parts[i]);
        }
        if (Array.isArray(obj2) && !/^\d+$/.test(part)) {
          var paths = parts.slice(i);
          return [].concat(obj2).map(function(item) {
            return item ? exports2.get(paths, item, special || lookup, map) : map(void 0);
          });
        }
        if (lookup) {
          obj2 = lookup(obj2, part);
        } else {
          var _from = special && obj2[special] ? obj2[special] : obj2;
          obj2 = _from instanceof Map ? _from.get(part) : _from[part];
        }
        if (!obj2)
          return map(obj2);
      }
      return map(obj2);
    };
    exports2.has = function(path3, o) {
      var parts = typeof path3 === "string" ? stringToParts(path3) : path3;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      var len = parts.length;
      var cur = o;
      for (var i = 0; i < len; ++i) {
        if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
          throw new TypeError("Each segment of path to `has()` must be a string or number, got " + typeof parts[i]);
        }
        if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
          return false;
        }
        cur = cur[parts[i]];
      }
      return true;
    };
    exports2.unset = function(path3, o) {
      var parts = typeof path3 === "string" ? stringToParts(path3) : path3;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      var len = parts.length;
      var cur = o;
      for (var i = 0; i < len; ++i) {
        if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
          return false;
        }
        if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
          throw new TypeError("Each segment of path to `unset()` must be a string or number, got " + typeof parts[i]);
        }
        if (ignoreProperties.indexOf(parts[i]) !== -1) {
          return false;
        }
        if (i === len - 1) {
          delete cur[parts[i]];
          return true;
        }
        cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];
      }
      return true;
    };
    exports2.set = function(path3, val, o, special, map, _copying) {
      var lookup;
      if ("function" == typeof special) {
        if (special.length < 2) {
          map = special;
          special = void 0;
        } else {
          lookup = special;
          special = void 0;
        }
      }
      map || (map = K);
      var parts = "string" == typeof path3 ? stringToParts(path3) : path3;
      if (!Array.isArray(parts)) {
        throw new TypeError("Invalid `path`. Must be either string or array");
      }
      if (null == o)
        return;
      for (var i = 0; i < parts.length; ++i) {
        if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
          throw new TypeError("Each segment of path to `set()` must be a string or number, got " + typeof parts[i]);
        }
        if (ignoreProperties.indexOf(parts[i]) !== -1) {
          return;
        }
      }
      var copy = _copying || /\$/.test(path3) && _copying !== false, obj2 = o, part;
      for (var i = 0, len = parts.length - 1; i < len; ++i) {
        part = parts[i];
        if ("$" == part) {
          if (i == len - 1) {
            break;
          } else {
            continue;
          }
        }
        if (Array.isArray(obj2) && !/^\d+$/.test(part)) {
          var paths = parts.slice(i);
          if (!copy && Array.isArray(val)) {
            for (var j = 0; j < obj2.length && j < val.length; ++j) {
              exports2.set(paths, val[j], obj2[j], special || lookup, map, copy);
            }
          } else {
            for (var j = 0; j < obj2.length; ++j) {
              exports2.set(paths, val, obj2[j], special || lookup, map, copy);
            }
          }
          return;
        }
        if (lookup) {
          obj2 = lookup(obj2, part);
        } else {
          var _to = special && obj2[special] ? obj2[special] : obj2;
          obj2 = _to instanceof Map ? _to.get(part) : _to[part];
        }
        if (!obj2)
          return;
      }
      part = parts[len];
      if (special && obj2[special]) {
        obj2 = obj2[special];
      }
      if (Array.isArray(obj2) && !/^\d+$/.test(part)) {
        if (!copy && Array.isArray(val)) {
          _setArray(obj2, val, part, lookup, special, map);
        } else {
          for (var j = 0; j < obj2.length; ++j) {
            var item = obj2[j];
            if (item) {
              if (lookup) {
                lookup(item, part, map(val));
              } else {
                if (item[special])
                  item = item[special];
                item[part] = map(val);
              }
            }
          }
        }
      } else {
        if (lookup) {
          lookup(obj2, part, map(val));
        } else if (obj2 instanceof Map) {
          obj2.set(part, map(val));
        } else {
          obj2[part] = map(val);
        }
      }
    };
    function _setArray(obj2, val, part, lookup, special, map) {
      for (var item, j = 0; j < obj2.length && j < val.length; ++j) {
        item = obj2[j];
        if (Array.isArray(item) && Array.isArray(val[j])) {
          _setArray(item, val[j], part, lookup, special, map);
        } else if (item) {
          if (lookup) {
            lookup(item, part, map(val[j]));
          } else {
            if (item[special])
              item = item[special];
            item[part] = map(val[j]);
          }
        }
      }
    }
    function K(v) {
      return v;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mpath@0.8.4/node_modules/mpath/index.js
var require_mpath = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mpath@0.8.4/node_modules/mpath/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = exports2 = require_lib();
  }
});

// node_modules/.pnpm/registry.npmmirror.com+safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+safe-buffer@5.2.1/node_modules/safe-buffer/index.js"(exports2, module2) {
    init_cjs_shims();
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/PopulateOptions.js
var require_PopulateOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/PopulateOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var clone = require_clone();
    var PopulateOptions = class {
      constructor(obj2) {
        this._docs = {};
        this._childDocs = [];
        if (obj2 == null) {
          return;
        }
        obj2 = clone(obj2);
        Object.assign(this, obj2);
        if (typeof obj2.subPopulate === "object") {
          this.populate = obj2.subPopulate;
        }
        if (obj2.perDocumentLimit != null && obj2.limit != null) {
          throw new Error("Can not use `limit` and `perDocumentLimit` at the same time. Path: `" + obj2.path + "`.");
        }
      }
    };
    module2.exports = PopulateOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+safe-buffer@5.1.2/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+safe-buffer@5.1.2/node_modules/safe-buffer/index.js"(exports2, module2) {
    init_cjs_shims();
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/utils.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var Buffer2 = require_safe_buffer2().Buffer;
    var RegExpClone = require_regexp_clone();
    var specialProperties = ["__proto__", "constructor", "prototype"];
    var clone = exports2.clone = function clone2(obj2, options) {
      if (obj2 === void 0 || obj2 === null)
        return obj2;
      if (Array.isArray(obj2))
        return exports2.cloneArray(obj2, options);
      if (obj2.constructor) {
        if (/ObjectI[dD]$/.test(obj2.constructor.name)) {
          return "function" == typeof obj2.clone ? obj2.clone() : new obj2.constructor(obj2.id);
        }
        if (obj2.constructor.name === "ReadPreference") {
          return new obj2.constructor(obj2.mode, clone2(obj2.tags, options));
        }
        if ("Binary" == obj2._bsontype && obj2.buffer && obj2.value) {
          return "function" == typeof obj2.clone ? obj2.clone() : new obj2.constructor(obj2.value(true), obj2.sub_type);
        }
        if ("Date" === obj2.constructor.name || "Function" === obj2.constructor.name)
          return new obj2.constructor(+obj2);
        if ("RegExp" === obj2.constructor.name)
          return RegExpClone(obj2);
        if ("Buffer" === obj2.constructor.name)
          return exports2.cloneBuffer(obj2);
      }
      if (isObject3(obj2))
        return exports2.cloneObject(obj2, options);
      if (obj2.valueOf)
        return obj2.valueOf();
    };
    exports2.cloneObject = function cloneObject(obj2, options) {
      var minimize = options && options.minimize;
      var ret2 = {};
      var hasKeys;
      var val;
      for (const k of Object.keys(obj2)) {
        if (specialProperties.indexOf(k) !== -1) {
          continue;
        }
        val = clone(obj2[k], options);
        if (!minimize || "undefined" !== typeof val) {
          hasKeys || (hasKeys = true);
          ret2[k] = val;
        }
      }
      return minimize ? hasKeys && ret2 : ret2;
    };
    exports2.cloneArray = function cloneArray(arr, options) {
      var ret2 = [];
      for (var i = 0, l2 = arr.length; i < l2; i++)
        ret2.push(clone(arr[i], options));
      return ret2;
    };
    exports2.tick = function tick(callback) {
      if ("function" !== typeof callback)
        return;
      return function() {
        var args = arguments;
        soon(function() {
          callback.apply(this, args);
        });
      };
    };
    exports2.merge = function merge2(to, from) {
      var keys = Object.keys(from), i = keys.length, key;
      while (i--) {
        key = keys[i];
        if (specialProperties.indexOf(key) !== -1) {
          continue;
        }
        if ("undefined" === typeof to[key]) {
          to[key] = from[key];
        } else {
          if (exports2.isObject(from[key])) {
            merge2(to[key], from[key]);
          } else {
            to[key] = from[key];
          }
        }
      }
    };
    exports2.mergeClone = function mergeClone(to, from) {
      var keys = Object.keys(from), i = keys.length, key;
      while (i--) {
        key = keys[i];
        if (specialProperties.indexOf(key) !== -1) {
          continue;
        }
        if ("undefined" === typeof to[key]) {
          to[key] = clone(from[key]);
        } else {
          if (exports2.isObject(from[key])) {
            mergeClone(to[key], from[key]);
          } else {
            to[key] = clone(from[key]);
          }
        }
      }
    };
    exports2.readPref = function readPref(pref) {
      switch (pref) {
        case "p":
          pref = "primary";
          break;
        case "pp":
          pref = "primaryPreferred";
          break;
        case "s":
          pref = "secondary";
          break;
        case "sp":
          pref = "secondaryPreferred";
          break;
        case "n":
          pref = "nearest";
          break;
      }
      return pref;
    };
    exports2.readConcern = function readConcern(concern) {
      if ("string" === typeof concern) {
        switch (concern) {
          case "l":
            concern = "local";
            break;
          case "a":
            concern = "available";
            break;
          case "m":
            concern = "majority";
            break;
          case "lz":
            concern = "linearizable";
            break;
          case "s":
            concern = "snapshot";
            break;
        }
        concern = { level: concern };
      }
      return concern;
    };
    var _toString = Object.prototype.toString;
    exports2.toString = function(arg) {
      return _toString.call(arg);
    };
    var isObject3 = exports2.isObject = function(arg) {
      return "[object Object]" == exports2.toString(arg);
    };
    exports2.isArray = function(arg) {
      return Array.isArray(arg) || "object" == typeof arg && "[object Array]" == exports2.toString(arg);
    };
    exports2.keys = Object.keys;
    exports2.create = "function" == typeof Object.create ? Object.create : create;
    function create(proto) {
      if (arguments.length > 1) {
        throw new Error("Adding properties is not supported");
      }
      function F() {
      }
      F.prototype = proto;
      return new F();
    }
    exports2.inherits = function(ctor, superCtor) {
      ctor.prototype = exports2.create(superCtor.prototype);
      ctor.prototype.constructor = ctor;
    };
    var soon = exports2.soon = "function" == typeof setImmediate ? setImmediate : process.nextTick;
    exports2.cloneBuffer = function(buff) {
      var dupe = Buffer2.alloc(buff.length);
      buff.copy(dupe, 0, 0, buff.length);
      return dupe;
    };
    exports2.isArgumentsObject = function(v) {
      return Object.prototype.toString.call(v) === "[object Arguments]";
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+ms@2.0.0/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+ms@2.0.0/node_modules/ms/index.js"(exports2, module2) {
    init_cjs_shims();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+debug@3.1.0/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+debug@3.1.0/node_modules/debug/src/debug.js"(exports2, module2) {
    init_cjs_shims();
    exports2 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = require_ms2();
    exports2.instances = [];
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports2.colors[Math.abs(hash) % exports2.colors.length];
    }
    function createDebug(namespace) {
      var prevTime;
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format3) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports2.formatters[format3];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports2.enabled(namespace);
      debug.useColors = exports2.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      if ("function" === typeof exports2.init) {
        exports2.init(debug);
      }
      exports2.instances.push(debug);
      return debug;
    }
    function destroy() {
      var index = exports2.instances.indexOf(this);
      if (index !== -1) {
        exports2.instances.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var i;
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
      for (i = 0; i < exports2.instances.length; i++) {
        var instance = exports2.instances[i];
        instance.enabled = exports2.enabled(instance.namespace);
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+debug@3.1.0/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+debug@3.1.0/node_modules/debug/src/browser.js"(exports2, module2) {
    init_cjs_shims();
    exports2 = module2.exports = require_debug();
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+debug@3.1.0/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+debug@3.1.0/node_modules/debug/src/node.js"(exports2, module2) {
    init_cjs_shims();
    var tty = require("tty");
    var util2 = require("util");
    exports2 = module2.exports = require_debug();
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      supportsColor = require_supports_color();
      if (supportsColor && supportsColor.level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (err) {
    }
    var supportsColor;
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj2, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj2[prop] = val;
      return obj2;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        var prefix = "  " + colorCode + ";1m" + name + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      } else {
        return (/* @__PURE__ */ new Date()).toISOString() + " ";
      }
    }
    function log() {
      return process.stderr.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load());
  }
});

// node_modules/.pnpm/registry.npmmirror.com+debug@3.1.0/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+debug@3.1.0/node_modules/debug/src/index.js"(exports2, module2) {
    init_cjs_shims();
    if (typeof process === "undefined" || process.type === "renderer") {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/permissions.js
var require_permissions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/permissions.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var denied = exports2;
    denied.distinct = function(self2) {
      if (self2._fields && Object.keys(self2._fields).length > 0) {
        return "field selection and slice";
      }
      var keys = Object.keys(denied.distinct);
      var err;
      keys.every(function(option) {
        if (self2.options[option]) {
          err = option;
          return false;
        }
        return true;
      });
      return err;
    };
    denied.distinct.select = denied.distinct.slice = denied.distinct.sort = denied.distinct.limit = denied.distinct.skip = denied.distinct.batchSize = denied.distinct.comment = denied.distinct.maxScan = denied.distinct.snapshot = denied.distinct.hint = denied.distinct.tailable = true;
    denied.findOneAndUpdate = denied.findOneAndRemove = function(self2) {
      var keys = Object.keys(denied.findOneAndUpdate);
      var err;
      keys.every(function(option) {
        if (self2.options[option]) {
          err = option;
          return false;
        }
        return true;
      });
      return err;
    };
    denied.findOneAndUpdate.limit = denied.findOneAndUpdate.skip = denied.findOneAndUpdate.batchSize = denied.findOneAndUpdate.maxScan = denied.findOneAndUpdate.snapshot = denied.findOneAndUpdate.hint = denied.findOneAndUpdate.tailable = denied.findOneAndUpdate.comment = true;
    denied.count = function(self2) {
      if (self2._fields && Object.keys(self2._fields).length > 0) {
        return "field selection and slice";
      }
      var keys = Object.keys(denied.count);
      var err;
      keys.every(function(option) {
        if (self2.options[option]) {
          err = option;
          return false;
        }
        return true;
      });
      return err;
    };
    denied.count.slice = denied.count.batchSize = denied.count.comment = denied.count.maxScan = denied.count.snapshot = denied.count.tailable = true;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/env.js
var require_env = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/env.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    exports2.isNode = "undefined" != typeof process && "object" == typeof module2 && "object" == typeof global && "function" == typeof Buffer && process.argv;
    exports2.isMongo = !exports2.isNode && "function" == typeof printjson && "function" == typeof ObjectId && "function" == typeof rs && "function" == typeof sh;
    exports2.isBrowser = !exports2.isNode && !exports2.isMongo && "undefined" != typeof window;
    exports2.type = exports2.isNode ? "node" : exports2.isMongo ? "mongo" : exports2.isBrowser ? "browser" : "unknown";
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/collection/collection.js
var require_collection2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/collection/collection.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var methods = [
      "find",
      "findOne",
      "update",
      "updateMany",
      "updateOne",
      "replaceOne",
      "remove",
      "count",
      "distinct",
      "findAndModify",
      "aggregate",
      "findStream",
      "deleteOne",
      "deleteMany"
    ];
    function Collection() {
    }
    for (i = 0, len = methods.length; i < len; ++i) {
      method = methods[i];
      Collection.prototype[method] = notImplemented(method);
    }
    var method;
    var i;
    var len;
    module2.exports = exports2 = Collection;
    Collection.methods = methods;
    function notImplemented(method2) {
      return function() {
        throw new Error("collection." + method2 + " not implemented");
      };
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/collection/node.js
var require_node2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/collection/node.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Collection = require_collection2();
    var utils = require_utils();
    function NodeCollection(col) {
      this.collection = col;
      this.collectionName = col.collectionName;
    }
    utils.inherits(NodeCollection, Collection);
    NodeCollection.prototype.find = function(match, options, cb) {
      this.collection.find(match, options, function(err, cursor) {
        if (err)
          return cb(err);
        try {
          cursor.toArray(cb);
        } catch (error) {
          cb(error);
        }
      });
    };
    NodeCollection.prototype.findOne = function(match, options, cb) {
      this.collection.findOne(match, options, cb);
    };
    NodeCollection.prototype.count = function(match, options, cb) {
      this.collection.count(match, options, cb);
    };
    NodeCollection.prototype.distinct = function(prop, match, options, cb) {
      this.collection.distinct(prop, match, options, cb);
    };
    NodeCollection.prototype.update = function(match, update, options, cb) {
      this.collection.update(match, update, options, cb);
    };
    NodeCollection.prototype.updateMany = function(match, update, options, cb) {
      this.collection.updateMany(match, update, options, cb);
    };
    NodeCollection.prototype.updateOne = function(match, update, options, cb) {
      this.collection.updateOne(match, update, options, cb);
    };
    NodeCollection.prototype.replaceOne = function(match, update, options, cb) {
      this.collection.replaceOne(match, update, options, cb);
    };
    NodeCollection.prototype.deleteOne = function(match, options, cb) {
      this.collection.deleteOne(match, options, cb);
    };
    NodeCollection.prototype.deleteMany = function(match, options, cb) {
      this.collection.deleteMany(match, options, cb);
    };
    NodeCollection.prototype.remove = function(match, options, cb) {
      this.collection.remove(match, options, cb);
    };
    NodeCollection.prototype.findAndModify = function(match, update, options, cb) {
      var sort = Array.isArray(options.sort) ? options.sort : [];
      this.collection.findAndModify(match, sort, update, options, cb);
    };
    NodeCollection.prototype.findStream = function(match, findOptions, streamOptions) {
      return this.collection.find(match, findOptions).stream(streamOptions);
    };
    NodeCollection.prototype.findCursor = function(match, findOptions) {
      return this.collection.find(match, findOptions);
    };
    module2.exports = exports2 = NodeCollection;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/collection/index.js
var require_collection3 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/collection/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var env2 = require_env();
    if ("unknown" == env2.type) {
      throw new Error("Unknown environment");
    }
    module2.exports = env2.isNode ? require_node2() : env2.isMongo ? require_collection2() : require_collection2();
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/es5.js
var require_es5 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/es5.js"(exports2, module2) {
    init_cjs_shims();
    var isES5 = function() {
      "use strict";
      return this === void 0;
    }();
    if (isES5) {
      module2.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5,
        propertyIsWritable: function(obj2, prop) {
          var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
          return !!(!descriptor || descriptor.writable || descriptor.set);
        }
      };
    } else {
      has = {}.hasOwnProperty;
      str = {}.toString;
      proto = {}.constructor.prototype;
      ObjectKeys = function(o) {
        var ret2 = [];
        for (var key in o) {
          if (has.call(o, key)) {
            ret2.push(key);
          }
        }
        return ret2;
      };
      ObjectGetDescriptor = function(o, key) {
        return { value: o[key] };
      };
      ObjectDefineProperty = function(o, key, desc) {
        o[key] = desc.value;
        return o;
      };
      ObjectFreeze = function(obj2) {
        return obj2;
      };
      ObjectGetPrototypeOf = function(obj2) {
        try {
          return Object(obj2).constructor.prototype;
        } catch (e) {
          return proto;
        }
      };
      ArrayIsArray = function(obj2) {
        try {
          return str.call(obj2) === "[object Array]";
        } catch (e) {
          return false;
        }
      };
      module2.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5,
        propertyIsWritable: function() {
          return true;
        }
      };
    }
    var has;
    var str;
    var proto;
    var ObjectKeys;
    var ObjectGetDescriptor;
    var ObjectDefineProperty;
    var ObjectFreeze;
    var ObjectGetPrototypeOf;
    var ArrayIsArray;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/util.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var es5 = require_es5();
    var canEvaluate = typeof navigator == "undefined";
    var errorObj = { e: {} };
    var tryCatchTarget;
    var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports !== void 0 ? exports : null;
    function tryCatcher() {
      try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
    }
    var inherits = function(Child, Parent) {
      var hasProp = {}.hasOwnProperty;
      function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
          if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
            this[propertyName + "$"] = Parent.prototype[propertyName];
          }
        }
      }
      T.prototype = Parent.prototype;
      Child.prototype = new T();
      return Child.prototype;
    };
    function isPrimitive(val) {
      return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
    }
    function isObject(value) {
      return typeof value === "function" || typeof value === "object" && value !== null;
    }
    function maybeWrapAsError(maybeError) {
      if (!isPrimitive(maybeError))
        return maybeError;
      return new Error(safeToString(maybeError));
    }
    function withAppended(target, appendee) {
      var len = target.length;
      var ret2 = new Array(len + 1);
      var i;
      for (i = 0; i < len; ++i) {
        ret2[i] = target[i];
      }
      ret2[i] = appendee;
      return ret2;
    }
    function getDataPropertyOrDefault(obj2, key, defaultValue) {
      if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj2, key);
        if (desc != null) {
          return desc.get == null && desc.set == null ? desc.value : defaultValue;
        }
      } else {
        return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
      }
    }
    function notEnumerableProp(obj2, name, value) {
      if (isPrimitive(obj2))
        return obj2;
      var descriptor = {
        value,
        configurable: true,
        enumerable: false,
        writable: true
      };
      es5.defineProperty(obj2, name, descriptor);
      return obj2;
    }
    function thrower(r) {
      throw r;
    }
    var inheritedDataKeys = function() {
      var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
      ];
      var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
          if (excludedPrototypes[i] === val) {
            return true;
          }
        }
        return false;
      };
      if (es5.isES5) {
        var getKeys2 = Object.getOwnPropertyNames;
        return function(obj2) {
          var ret2 = [];
          var visitedKeys = /* @__PURE__ */ Object.create(null);
          while (obj2 != null && !isExcludedProto(obj2)) {
            var keys;
            try {
              keys = getKeys2(obj2);
            } catch (e) {
              return ret2;
            }
            for (var i = 0; i < keys.length; ++i) {
              var key = keys[i];
              if (visitedKeys[key])
                continue;
              visitedKeys[key] = true;
              var desc = Object.getOwnPropertyDescriptor(obj2, key);
              if (desc != null && desc.get == null && desc.set == null) {
                ret2.push(key);
              }
            }
            obj2 = es5.getPrototypeOf(obj2);
          }
          return ret2;
        };
      } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj2) {
          if (isExcludedProto(obj2))
            return [];
          var ret2 = [];
          enumeration:
            for (var key in obj2) {
              if (hasProp.call(obj2, key)) {
                ret2.push(key);
              } else {
                for (var i = 0; i < excludedPrototypes.length; ++i) {
                  if (hasProp.call(excludedPrototypes[i], key)) {
                    continue enumeration;
                  }
                }
                ret2.push(key);
              }
            }
          return ret2;
        };
      }
    }();
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn) {
      try {
        if (typeof fn === "function") {
          var keys = es5.names(fn.prototype);
          var hasMethods = es5.isES5 && keys.length > 1;
          var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
          var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
          if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
            return true;
          }
        }
        return false;
      } catch (e) {
        return false;
      }
    }
    function toFastProperties(obj) {
      function FakeConstructor() {
      }
      FakeConstructor.prototype = obj;
      var l = 8;
      while (l--)
        new FakeConstructor();
      return obj;
      eval(obj);
    }
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
      return rident.test(str);
    }
    function filledRange(count, prefix, suffix) {
      var ret2 = new Array(count);
      for (var i = 0; i < count; ++i) {
        ret2[i] = prefix + i + suffix;
      }
      return ret2;
    }
    function safeToString(obj2) {
      try {
        return obj2 + "";
      } catch (e) {
        return "[no string representation]";
      }
    }
    function isError(obj2) {
      return obj2 instanceof Error || obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
    }
    function markAsOriginatingFromRejection(e) {
      try {
        notEnumerableProp(e, "isOperational", true);
      } catch (ignore) {
      }
    }
    function originatesFromRejection(e) {
      if (e == null)
        return false;
      return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
    }
    function canAttachTrace(obj2) {
      return isError(obj2) && es5.propertyIsWritable(obj2, "stack");
    }
    var ensureErrorObject = function() {
      if (!("stack" in new Error())) {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          try {
            throw new Error(safeToString(value));
          } catch (err) {
            return err;
          }
        };
      } else {
        return function(value) {
          if (canAttachTrace(value))
            return value;
          return new Error(safeToString(value));
        };
      }
    }();
    function classString(obj2) {
      return {}.toString.call(obj2);
    }
    function copyDescriptors(from, to, filter) {
      var keys = es5.names(from);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
          try {
            es5.defineProperty(to, key, es5.getDescriptor(from, key));
          } catch (ignore) {
          }
        }
      }
    }
    var asArray = function(v) {
      if (es5.isArray(v)) {
        return v;
      }
      return null;
    };
    if (typeof Symbol !== "undefined" && Symbol.iterator) {
      ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
      } : function(v) {
        var ret2 = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!(itResult = it.next()).done) {
          ret2.push(itResult.value);
        }
        return ret2;
      };
      asArray = function(v) {
        if (es5.isArray(v)) {
          return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
          return ArrayFrom(v);
        }
        return null;
      };
    }
    var ArrayFrom;
    var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
    var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
    function env(key) {
      return hasEnvVariables ? process.env[key] : void 0;
    }
    function getNativePromise() {
      if (typeof Promise === "function") {
        try {
          var promise = new Promise(function() {
          });
          if ({}.toString.call(promise) === "[object Promise]") {
            return Promise;
          }
        } catch (e) {
        }
      }
    }
    function domainBind(self2, cb) {
      return self2.bind(cb);
    }
    var ret = {
      isClass,
      isIdentifier,
      inheritedDataKeys,
      getDataPropertyOrDefault,
      thrower,
      isArray: es5.isArray,
      asArray,
      notEnumerableProp,
      isPrimitive,
      isObject,
      isError,
      canEvaluate,
      errorObj,
      tryCatch,
      inherits,
      withAppended,
      maybeWrapAsError,
      toFastProperties,
      filledRange,
      toString: safeToString,
      canAttachTrace,
      ensureErrorObject,
      originatesFromRejection,
      markAsOriginatingFromRejection,
      classString,
      copyDescriptors,
      hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
      isNode,
      hasEnvVariables,
      env,
      global: globalObject,
      getNativePromise,
      domainBind
    };
    ret.isRecentNode = ret.isNode && function() {
      var version = process.versions.node.split(".").map(Number);
      return version[0] === 0 && version[1] > 10 || version[0] > 0;
    }();
    if (ret.isNode)
      ret.toFastProperties(process);
    try {
      throw new Error();
    } catch (e) {
      ret.lastLineError = e;
    }
    module.exports = ret;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/schedule.js
var require_schedule = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/schedule.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var util2 = require_util();
    var schedule;
    var noAsyncScheduler = function() {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    };
    var NativePromise = util2.getNativePromise();
    if (util2.isNode && typeof MutationObserver === "undefined") {
      GlobalSetImmediate = global.setImmediate;
      ProcessNextTick = process.nextTick;
      schedule = util2.isRecentNode ? function(fn) {
        GlobalSetImmediate.call(global, fn);
      } : function(fn) {
        ProcessNextTick.call(process, fn);
      };
    } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
      nativePromise = NativePromise.resolve();
      schedule = function(fn) {
        nativePromise.then(fn);
      };
    } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
      schedule = function() {
        var div = document.createElement("div");
        var opts = { attributes: true };
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
          div.classList.toggle("foo");
          toggleScheduled = false;
        });
        o2.observe(div2, opts);
        var scheduleToggle = function() {
          if (toggleScheduled)
            return;
          toggleScheduled = true;
          div2.classList.toggle("foo");
        };
        return function schedule2(fn) {
          var o = new MutationObserver(function() {
            o.disconnect();
            fn();
          });
          o.observe(div, opts);
          scheduleToggle();
        };
      }();
    } else if (typeof setImmediate !== "undefined") {
      schedule = function(fn) {
        setImmediate(fn);
      };
    } else if (typeof setTimeout !== "undefined") {
      schedule = function(fn) {
        setTimeout(fn, 0);
      };
    } else {
      schedule = noAsyncScheduler;
    }
    var GlobalSetImmediate;
    var ProcessNextTick;
    var nativePromise;
    module2.exports = schedule;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/queue.js
var require_queue = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/queue.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
      for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
      }
    }
    function Queue(capacity) {
      this._capacity = capacity;
      this._length = 0;
      this._front = 0;
    }
    Queue.prototype._willBeOverCapacity = function(size) {
      return this._capacity < size;
    };
    Queue.prototype._pushOne = function(arg) {
      var length = this.length();
      this._checkCapacity(length + 1);
      var i = this._front + length & this._capacity - 1;
      this[i] = arg;
      this._length = length + 1;
    };
    Queue.prototype.push = function(fn, receiver, arg) {
      var length = this.length() + 3;
      if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
      }
      var j = this._front + length - 3;
      this._checkCapacity(length);
      var wrapMask = this._capacity - 1;
      this[j + 0 & wrapMask] = fn;
      this[j + 1 & wrapMask] = receiver;
      this[j + 2 & wrapMask] = arg;
      this._length = length;
    };
    Queue.prototype.shift = function() {
      var front = this._front, ret2 = this[front];
      this[front] = void 0;
      this._front = front + 1 & this._capacity - 1;
      this._length--;
      return ret2;
    };
    Queue.prototype.length = function() {
      return this._length;
    };
    Queue.prototype._checkCapacity = function(size) {
      if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
      }
    };
    Queue.prototype._resizeTo = function(capacity) {
      var oldCapacity = this._capacity;
      this._capacity = capacity;
      var front = this._front;
      var length = this._length;
      var moveItemsCount = front + length & oldCapacity - 1;
      arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    };
    module2.exports = Queue;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/async.js
var require_async = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/async.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var firstLineError;
    try {
      throw new Error();
    } catch (e) {
      firstLineError = e;
    }
    var schedule = require_schedule();
    var Queue = require_queue();
    var util2 = require_util();
    function Async() {
      this._customScheduler = false;
      this._isTickUsed = false;
      this._lateQueue = new Queue(16);
      this._normalQueue = new Queue(16);
      this._haveDrainedQueues = false;
      this._trampolineEnabled = true;
      var self2 = this;
      this.drainQueues = function() {
        self2._drainQueues();
      };
      this._schedule = schedule;
    }
    Async.prototype.setScheduler = function(fn) {
      var prev = this._schedule;
      this._schedule = fn;
      this._customScheduler = true;
      return prev;
    };
    Async.prototype.hasCustomScheduler = function() {
      return this._customScheduler;
    };
    Async.prototype.enableTrampoline = function() {
      this._trampolineEnabled = true;
    };
    Async.prototype.disableTrampolineIfNecessary = function() {
      if (util2.hasDevTools) {
        this._trampolineEnabled = false;
      }
    };
    Async.prototype.haveItemsQueued = function() {
      return this._isTickUsed || this._haveDrainedQueues;
    };
    Async.prototype.fatalError = function(e, isNode2) {
      if (isNode2) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
        process.exit(2);
      } else {
        this.throwLater(e);
      }
    };
    Async.prototype.throwLater = function(fn, arg) {
      if (arguments.length === 1) {
        arg = fn;
        fn = function() {
          throw arg;
        };
      }
      if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
          fn(arg);
        }, 0);
      } else
        try {
          this._schedule(function() {
            fn(arg);
          });
        } catch (e) {
          throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
        }
    };
    function AsyncInvokeLater(fn, receiver, arg) {
      this._lateQueue.push(fn, receiver, arg);
      this._queueTick();
    }
    function AsyncInvoke(fn, receiver, arg) {
      this._normalQueue.push(fn, receiver, arg);
      this._queueTick();
    }
    function AsyncSettlePromises(promise) {
      this._normalQueue._pushOne(promise);
      this._queueTick();
    }
    if (!util2.hasDevTools) {
      Async.prototype.invokeLater = AsyncInvokeLater;
      Async.prototype.invoke = AsyncInvoke;
      Async.prototype.settlePromises = AsyncSettlePromises;
    } else {
      Async.prototype.invokeLater = function(fn, receiver, arg) {
        if (this._trampolineEnabled) {
          AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
          this._schedule(function() {
            setTimeout(function() {
              fn.call(receiver, arg);
            }, 100);
          });
        }
      };
      Async.prototype.invoke = function(fn, receiver, arg) {
        if (this._trampolineEnabled) {
          AsyncInvoke.call(this, fn, receiver, arg);
        } else {
          this._schedule(function() {
            fn.call(receiver, arg);
          });
        }
      };
      Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
          AsyncSettlePromises.call(this, promise);
        } else {
          this._schedule(function() {
            promise._settlePromises();
          });
        }
      };
    }
    Async.prototype._drainQueue = function(queue) {
      while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
          fn._settlePromises();
          continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
      }
    };
    Async.prototype._drainQueues = function() {
      this._drainQueue(this._normalQueue);
      this._reset();
      this._haveDrainedQueues = true;
      this._drainQueue(this._lateQueue);
    };
    Async.prototype._queueTick = function() {
      if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
      }
    };
    Async.prototype._reset = function() {
      this._isTickUsed = false;
    };
    module2.exports = Async;
    module2.exports.firstLineError = firstLineError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/errors.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var es52 = require_es5();
    var Objectfreeze = es52.freeze;
    var util2 = require_util();
    var inherits2 = util2.inherits;
    var notEnumerableProp2 = util2.notEnumerableProp;
    function subError(nameProperty, defaultMessage) {
      function SubError(message) {
        if (!(this instanceof SubError))
          return new SubError(message);
        notEnumerableProp2(
          this,
          "message",
          typeof message === "string" ? message : defaultMessage
        );
        notEnumerableProp2(this, "name", nameProperty);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          Error.call(this);
        }
      }
      inherits2(SubError, Error);
      return SubError;
    }
    var _TypeError;
    var _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
      _TypeError = TypeError;
      _RangeError = RangeError;
    } catch (e) {
      _TypeError = subError("TypeError", "type error");
      _RangeError = subError("RangeError", "range error");
    }
    var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
    for (i = 0; i < methods.length; ++i) {
      if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
      }
    }
    var i;
    es52.defineProperty(AggregateError.prototype, "length", {
      value: 0,
      configurable: false,
      writable: true,
      enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
      var indent = Array(level * 4 + 1).join(" ");
      var ret2 = "\n" + indent + "AggregateError of:\n";
      level++;
      indent = Array(level * 4 + 1).join(" ");
      for (var i2 = 0; i2 < this.length; ++i2) {
        var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
          lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret2 += str + "\n";
      }
      level--;
      return ret2;
    };
    function OperationalError(message) {
      if (!(this instanceof OperationalError))
        return new OperationalError(message);
      notEnumerableProp2(this, "name", "OperationalError");
      notEnumerableProp2(this, "message", message);
      this.cause = message;
      this["isOperational"] = true;
      if (message instanceof Error) {
        notEnumerableProp2(this, "message", message.message);
        notEnumerableProp2(this, "stack", message.stack);
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
    inherits2(OperationalError, Error);
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
      errorTypes = Objectfreeze({
        CancellationError,
        TimeoutError,
        OperationalError,
        RejectionError: OperationalError,
        AggregateError
      });
      es52.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      Error,
      TypeError: _TypeError,
      RangeError: _RangeError,
      CancellationError: errorTypes.CancellationError,
      OperationalError: errorTypes.OperationalError,
      TimeoutError: errorTypes.TimeoutError,
      AggregateError: errorTypes.AggregateError,
      Warning
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/thenables.js
var require_thenables = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/thenables.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, INTERNAL) {
      var util2 = require_util();
      var errorObj2 = util2.errorObj;
      var isObject3 = util2.isObject;
      function tryConvertToPromise(obj2, context) {
        if (isObject3(obj2)) {
          if (obj2 instanceof Promise2)
            return obj2;
          var then = getThen(obj2);
          if (then === errorObj2) {
            if (context)
              context._pushContext();
            var ret2 = Promise2.reject(then.e);
            if (context)
              context._popContext();
            return ret2;
          } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj2)) {
              var ret2 = new Promise2(INTERNAL);
              obj2._then(
                ret2._fulfill,
                ret2._reject,
                void 0,
                ret2,
                null
              );
              return ret2;
            }
            return doThenable(obj2, then, context);
          }
        }
        return obj2;
      }
      function doGetThen(obj2) {
        return obj2.then;
      }
      function getThen(obj2) {
        try {
          return doGetThen(obj2);
        } catch (e) {
          errorObj2.e = e;
          return errorObj2;
        }
      }
      var hasProp = {}.hasOwnProperty;
      function isAnyBluebirdPromise(obj2) {
        try {
          return hasProp.call(obj2, "_promise0");
        } catch (e) {
          return false;
        }
      }
      function doThenable(x, then, context) {
        var promise = new Promise2(INTERNAL);
        var ret2 = promise;
        if (context)
          context._pushContext();
        promise._captureStackTrace();
        if (context)
          context._popContext();
        var synchronous = true;
        var result = util2.tryCatch(then).call(x, resolve, reject);
        synchronous = false;
        if (promise && result === errorObj2) {
          promise._rejectCallback(result.e, true, true);
          promise = null;
        }
        function resolve(value) {
          if (!promise)
            return;
          promise._resolveCallback(value);
          promise = null;
        }
        function reject(reason) {
          if (!promise)
            return;
          promise._rejectCallback(reason, synchronous, true);
          promise = null;
        }
        return ret2;
      }
      return tryConvertToPromise;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/promise_array.js
var require_promise_array = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/promise_array.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
      var util2 = require_util();
      var isArray2 = util2.isArray;
      function toResolutionValue(val) {
        switch (val) {
          case -2:
            return [];
          case -3:
            return {};
          case -6:
            return /* @__PURE__ */ new Map();
        }
      }
      function PromiseArray(values) {
        var promise = this._promise = new Promise2(INTERNAL);
        if (values instanceof Promise2) {
          promise._propagateFrom(values, 3);
        }
        promise._setOnCancel(this);
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(void 0, -2);
      }
      util2.inherits(PromiseArray, Proxyable);
      PromiseArray.prototype.length = function() {
        return this._length;
      };
      PromiseArray.prototype.promise = function() {
        return this._promise;
      };
      PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise2) {
          values = values._target();
          var bitField = values._bitField;
          ;
          this._values = values;
          if ((bitField & 50397184) === 0) {
            this._promise._setAsyncGuaranteed();
            return values._then(
              init,
              this._reject,
              void 0,
              this,
              resolveValueIfEmpty
            );
          } else if ((bitField & 33554432) !== 0) {
            values = values._value();
          } else if ((bitField & 16777216) !== 0) {
            return this._reject(values._reason());
          } else {
            return this._cancel();
          }
        }
        values = util2.asArray(values);
        if (values === null) {
          var err = apiRejection(
            "expecting an array or an iterable object but got " + util2.classString(values)
          ).reason();
          this._promise._rejectCallback(err, false);
          return;
        }
        if (values.length === 0) {
          if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
          } else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
          }
          return;
        }
        this._iterate(values);
      };
      PromiseArray.prototype._iterate = function(values) {
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var result = this._promise;
        var isResolved = false;
        var bitField = null;
        for (var i = 0; i < len; ++i) {
          var maybePromise = tryConvertToPromise(values[i], result);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
          } else {
            bitField = null;
          }
          if (isResolved) {
            if (bitField !== null) {
              maybePromise.suppressUnhandledRejections();
            }
          } else if (bitField !== null) {
            if ((bitField & 50397184) === 0) {
              maybePromise._proxy(this, i);
              this._values[i] = maybePromise;
            } else if ((bitField & 33554432) !== 0) {
              isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if ((bitField & 16777216) !== 0) {
              isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
              isResolved = this._promiseCancelled(i);
            }
          } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
          }
        }
        if (!isResolved)
          result._setAsyncGuaranteed();
      };
      PromiseArray.prototype._isResolved = function() {
        return this._values === null;
      };
      PromiseArray.prototype._resolve = function(value) {
        this._values = null;
        this._promise._fulfill(value);
      };
      PromiseArray.prototype._cancel = function() {
        if (this._isResolved() || !this._promise._isCancellable())
          return;
        this._values = null;
        this._promise._cancel();
      };
      PromiseArray.prototype._reject = function(reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false);
      };
      PromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      PromiseArray.prototype._promiseCancelled = function() {
        this._cancel();
        return true;
      };
      PromiseArray.prototype._promiseRejected = function(reason) {
        this._totalResolved++;
        this._reject(reason);
        return true;
      };
      PromiseArray.prototype._resultCancelled = function() {
        if (this._isResolved())
          return;
        var values = this._values;
        this._cancel();
        if (values instanceof Promise2) {
          values.cancel();
        } else {
          for (var i = 0; i < values.length; ++i) {
            if (values[i] instanceof Promise2) {
              values[i].cancel();
            }
          }
        }
      };
      PromiseArray.prototype.shouldCopyValues = function() {
        return true;
      };
      PromiseArray.prototype.getActualLength = function(len) {
        return len;
      };
      return PromiseArray;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/context.js
var require_context = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/context.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2) {
      var longStackTraces = false;
      var contextStack = [];
      Promise2.prototype._promiseCreated = function() {
      };
      Promise2.prototype._pushContext = function() {
      };
      Promise2.prototype._popContext = function() {
        return null;
      };
      Promise2._peekContext = Promise2.prototype._peekContext = function() {
      };
      function Context() {
        this._trace = new Context.CapturedTrace(peekContext());
      }
      Context.prototype._pushContext = function() {
        if (this._trace !== void 0) {
          this._trace._promiseCreated = null;
          contextStack.push(this._trace);
        }
      };
      Context.prototype._popContext = function() {
        if (this._trace !== void 0) {
          var trace = contextStack.pop();
          var ret2 = trace._promiseCreated;
          trace._promiseCreated = null;
          return ret2;
        }
        return null;
      };
      function createContext() {
        if (longStackTraces)
          return new Context();
      }
      function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
          return contextStack[lastIndex];
        }
        return void 0;
      }
      Context.CapturedTrace = null;
      Context.create = createContext;
      Context.deactivateLongStackTraces = function() {
      };
      Context.activateLongStackTraces = function() {
        var Promise_pushContext = Promise2.prototype._pushContext;
        var Promise_popContext = Promise2.prototype._popContext;
        var Promise_PeekContext = Promise2._peekContext;
        var Promise_peekContext = Promise2.prototype._peekContext;
        var Promise_promiseCreated = Promise2.prototype._promiseCreated;
        Context.deactivateLongStackTraces = function() {
          Promise2.prototype._pushContext = Promise_pushContext;
          Promise2.prototype._popContext = Promise_popContext;
          Promise2._peekContext = Promise_PeekContext;
          Promise2.prototype._peekContext = Promise_peekContext;
          Promise2.prototype._promiseCreated = Promise_promiseCreated;
          longStackTraces = false;
        };
        longStackTraces = true;
        Promise2.prototype._pushContext = Context.prototype._pushContext;
        Promise2.prototype._popContext = Context.prototype._popContext;
        Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
        Promise2.prototype._promiseCreated = function() {
          var ctx = this._peekContext();
          if (ctx && ctx._promiseCreated == null)
            ctx._promiseCreated = this;
        };
      };
      return Context;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/debuggability.js
var require_debuggability = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/debuggability.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, Context) {
      var getDomain = Promise2._getDomain;
      var async = Promise2._async;
      var Warning = require_errors().Warning;
      var util2 = require_util();
      var canAttachTrace2 = util2.canAttachTrace;
      var unhandledRejectionHandled;
      var possiblyUnhandledRejection;
      var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
      var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
      var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
      var stackFramePattern = null;
      var formatStack = null;
      var indentStackFrames = false;
      var printWarning;
      var debugging = !!(util2.env("BLUEBIRD_DEBUG") != 0 && (util2.env("BLUEBIRD_DEBUG") || util2.env("NODE_ENV") === "development"));
      var warnings = !!(util2.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util2.env("BLUEBIRD_WARNINGS")));
      var longStackTraces = !!(util2.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util2.env("BLUEBIRD_LONG_STACK_TRACES")));
      var wForgottenReturn = util2.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util2.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
      Promise2.prototype.suppressUnhandledRejections = function() {
        var target = this._target();
        target._bitField = target._bitField & ~1048576 | 524288;
      };
      Promise2.prototype._ensurePossibleRejectionHandled = function() {
        if ((this._bitField & 524288) !== 0)
          return;
        this._setRejectionIsUnhandled();
        var self2 = this;
        setTimeout(function() {
          self2._notifyUnhandledRejection();
        }, 1);
      };
      Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
        fireRejectionEvent(
          "rejectionHandled",
          unhandledRejectionHandled,
          void 0,
          this
        );
      };
      Promise2.prototype._setReturnedNonUndefined = function() {
        this._bitField = this._bitField | 268435456;
      };
      Promise2.prototype._returnedNonUndefined = function() {
        return (this._bitField & 268435456) !== 0;
      };
      Promise2.prototype._notifyUnhandledRejection = function() {
        if (this._isRejectionUnhandled()) {
          var reason = this._settledValue();
          this._setUnhandledRejectionIsNotified();
          fireRejectionEvent(
            "unhandledRejection",
            possiblyUnhandledRejection,
            reason,
            this
          );
        }
      };
      Promise2.prototype._setUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField | 262144;
      };
      Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField & ~262144;
      };
      Promise2.prototype._isUnhandledRejectionNotified = function() {
        return (this._bitField & 262144) > 0;
      };
      Promise2.prototype._setRejectionIsUnhandled = function() {
        this._bitField = this._bitField | 1048576;
      };
      Promise2.prototype._unsetRejectionIsUnhandled = function() {
        this._bitField = this._bitField & ~1048576;
        if (this._isUnhandledRejectionNotified()) {
          this._unsetUnhandledRejectionIsNotified();
          this._notifyUnhandledRejectionIsHandled();
        }
      };
      Promise2.prototype._isRejectionUnhandled = function() {
        return (this._bitField & 1048576) > 0;
      };
      Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
        return warn(message, shouldUseOwnTrace, promise || this);
      };
      Promise2.onPossiblyUnhandledRejection = function(fn) {
        var domain = getDomain();
        possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util2.domainBind(domain, fn) : void 0;
      };
      Promise2.onUnhandledRejectionHandled = function(fn) {
        var domain = getDomain();
        unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util2.domainBind(domain, fn) : void 0;
      };
      var disableLongStackTraces = function() {
      };
      Promise2.longStackTraces = function() {
        if (async.haveItemsQueued() && !config3.longStackTraces) {
          throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (!config3.longStackTraces && longStackTracesIsSupported()) {
          var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
          var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
          config3.longStackTraces = true;
          disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config3.longStackTraces) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
            }
            Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config3.longStackTraces = false;
          };
          Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
          Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
          Context.activateLongStackTraces();
          async.disableTrampolineIfNecessary();
        }
      };
      Promise2.hasLongStackTraces = function() {
        return config3.longStackTraces && longStackTracesIsSupported();
      };
      var fireDomEvent = function() {
        try {
          if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util2.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = new CustomEvent(name.toLowerCase(), {
                detail: event2,
                cancelable: true
              });
              return !util2.global.dispatchEvent(domEvent);
            };
          } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util2.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = new Event(name.toLowerCase(), {
                cancelable: true
              });
              domEvent.detail = event2;
              return !util2.global.dispatchEvent(domEvent);
            };
          } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util2.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = document.createEvent("CustomEvent");
              domEvent.initCustomEvent(
                name.toLowerCase(),
                false,
                true,
                event2
              );
              return !util2.global.dispatchEvent(domEvent);
            };
          }
        } catch (e) {
        }
        return function() {
          return false;
        };
      }();
      var fireGlobalEvent = function() {
        if (util2.isNode) {
          return function() {
            return process.emit.apply(process, arguments);
          };
        } else {
          if (!util2.global) {
            return function() {
              return false;
            };
          }
          return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util2.global[methodName];
            if (!method)
              return false;
            method.apply(util2.global, [].slice.call(arguments, 1));
            return true;
          };
        }
      }();
      function generatePromiseLifecycleEventObject(name, promise) {
        return { promise };
      }
      var eventToObjectGenerator = {
        promiseCreated: generatePromiseLifecycleEventObject,
        promiseFulfilled: generatePromiseLifecycleEventObject,
        promiseRejected: generatePromiseLifecycleEventObject,
        promiseResolved: generatePromiseLifecycleEventObject,
        promiseCancelled: generatePromiseLifecycleEventObject,
        promiseChained: function(name, promise, child) {
          return { promise, child };
        },
        warning: function(name, warning) {
          return { warning };
        },
        unhandledRejection: function(name, reason, promise) {
          return { reason, promise };
        },
        rejectionHandled: generatePromiseLifecycleEventObject
      };
      var activeFireEvent = function(name) {
        var globalEventFired = false;
        try {
          globalEventFired = fireGlobalEvent.apply(null, arguments);
        } catch (e) {
          async.throwLater(e);
          globalEventFired = true;
        }
        var domEventFired = false;
        try {
          domEventFired = fireDomEvent(
            name,
            eventToObjectGenerator[name].apply(null, arguments)
          );
        } catch (e) {
          async.throwLater(e);
          domEventFired = true;
        }
        return domEventFired || globalEventFired;
      };
      Promise2.config = function(opts) {
        opts = Object(opts);
        if ("longStackTraces" in opts) {
          if (opts.longStackTraces) {
            Promise2.longStackTraces();
          } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
            disableLongStackTraces();
          }
        }
        if ("warnings" in opts) {
          var warningsOption = opts.warnings;
          config3.warnings = !!warningsOption;
          wForgottenReturn = config3.warnings;
          if (util2.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
              wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
          }
        }
        if ("cancellation" in opts && opts.cancellation && !config3.cancellation) {
          if (async.haveItemsQueued()) {
            throw new Error(
              "cannot enable cancellation after promises are in use"
            );
          }
          Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
          Promise2.prototype._propagateFrom = cancellationPropagateFrom;
          Promise2.prototype._onCancel = cancellationOnCancel;
          Promise2.prototype._setOnCancel = cancellationSetOnCancel;
          Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
          Promise2.prototype._execute = cancellationExecute;
          propagateFromFunction = cancellationPropagateFrom;
          config3.cancellation = true;
        }
        if ("monitoring" in opts) {
          if (opts.monitoring && !config3.monitoring) {
            config3.monitoring = true;
            Promise2.prototype._fireEvent = activeFireEvent;
          } else if (!opts.monitoring && config3.monitoring) {
            config3.monitoring = false;
            Promise2.prototype._fireEvent = defaultFireEvent;
          }
        }
        return Promise2;
      };
      function defaultFireEvent() {
        return false;
      }
      Promise2.prototype._fireEvent = defaultFireEvent;
      Promise2.prototype._execute = function(executor, resolve, reject) {
        try {
          executor(resolve, reject);
        } catch (e) {
          return e;
        }
      };
      Promise2.prototype._onCancel = function() {
      };
      Promise2.prototype._setOnCancel = function(handler) {
        ;
      };
      Promise2.prototype._attachCancellationCallback = function(onCancel) {
        ;
      };
      Promise2.prototype._captureStackTrace = function() {
      };
      Promise2.prototype._attachExtraTrace = function() {
      };
      Promise2.prototype._clearCancellationData = function() {
      };
      Promise2.prototype._propagateFrom = function(parent, flags) {
        ;
        ;
      };
      function cancellationExecute(executor, resolve, reject) {
        var promise = this;
        try {
          executor(resolve, reject, function(onCancel) {
            if (typeof onCancel !== "function") {
              throw new TypeError("onCancel must be a function, got: " + util2.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
          });
        } catch (e) {
          return e;
        }
      }
      function cancellationAttachCancellationCallback(onCancel) {
        if (!this._isCancellable())
          return this;
        var previousOnCancel = this._onCancel();
        if (previousOnCancel !== void 0) {
          if (util2.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
          } else {
            this._setOnCancel([previousOnCancel, onCancel]);
          }
        } else {
          this._setOnCancel(onCancel);
        }
      }
      function cancellationOnCancel() {
        return this._onCancelField;
      }
      function cancellationSetOnCancel(onCancel) {
        this._onCancelField = onCancel;
      }
      function cancellationClearCancellationData() {
        this._cancellationParent = void 0;
        this._onCancelField = void 0;
      }
      function cancellationPropagateFrom(parent, flags) {
        if ((flags & 1) !== 0) {
          this._cancellationParent = parent;
          var branchesRemainingToCancel = parent._branchesRemainingToCancel;
          if (branchesRemainingToCancel === void 0) {
            branchesRemainingToCancel = 0;
          }
          parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
        }
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      function bindingPropagateFrom(parent, flags) {
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      var propagateFromFunction = bindingPropagateFrom;
      function boundValueFunction() {
        var ret2 = this._boundTo;
        if (ret2 !== void 0) {
          if (ret2 instanceof Promise2) {
            if (ret2.isFulfilled()) {
              return ret2.value();
            } else {
              return void 0;
            }
          }
        }
        return ret2;
      }
      function longStackTracesCaptureStackTrace() {
        this._trace = new CapturedTrace(this._peekContext());
      }
      function longStackTracesAttachExtraTrace(error, ignoreSelf) {
        if (canAttachTrace2(error)) {
          var trace = this._trace;
          if (trace !== void 0) {
            if (ignoreSelf)
              trace = trace._parent;
          }
          if (trace !== void 0) {
            trace.attachExtraTrace(error);
          } else if (!error.__stackCleaned__) {
            var parsed = parseStackAndMessage(error);
            util2.notEnumerableProp(
              error,
              "stack",
              parsed.message + "\n" + parsed.stack.join("\n")
            );
            util2.notEnumerableProp(error, "__stackCleaned__", true);
          }
        }
      }
      function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
        if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
          if (parent !== void 0 && parent._returnedNonUndefined())
            return;
          if ((promise._bitField & 65535) === 0)
            return;
          if (name)
            name = name + " ";
          var handlerLine = "";
          var creatorLine = "";
          if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i >= 0; --i) {
              var line = stack[i];
              if (!nodeFramePattern.test(line)) {
                var lineMatches = line.match(parseLinePattern);
                if (lineMatches) {
                  handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                }
                break;
              }
            }
            if (stack.length > 0) {
              var firstUserLine = stack[0];
              for (var i = 0; i < traceLines.length; ++i) {
                if (traceLines[i] === firstUserLine) {
                  if (i > 0) {
                    creatorLine = "\n" + traceLines[i - 1];
                  }
                  break;
                }
              }
            }
          }
          var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
          promise._warn(msg, true, promiseCreated);
        }
      }
      function deprecated(name, replacement) {
        var message = name + " is deprecated and will be removed in a future version.";
        if (replacement)
          message += " Use " + replacement + " instead.";
        return warn(message);
      }
      function warn(message, shouldUseOwnTrace, promise) {
        if (!config3.warnings)
          return;
        var warning = new Warning(message);
        var ctx;
        if (shouldUseOwnTrace) {
          promise._attachExtraTrace(warning);
        } else if (config3.longStackTraces && (ctx = Promise2._peekContext())) {
          ctx.attachExtraTrace(warning);
        } else {
          var parsed = parseStackAndMessage(warning);
          warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }
        if (!activeFireEvent("warning", warning)) {
          formatAndLogError(warning, "", true);
        }
      }
      function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
          stacks[i].push("From previous event:");
          stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
          stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
      }
      function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
          if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
            stacks.splice(i, 1);
            i--;
          }
        }
      }
      function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
          var prev = stacks[i];
          var currentLastIndex = current.length - 1;
          var currentLastLine = current[currentLastIndex];
          var commonRootMeetPoint = -1;
          for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
              commonRootMeetPoint = j;
              break;
            }
          }
          for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
              current.pop();
              currentLastIndex--;
            } else {
              break;
            }
          }
          current = prev;
        }
      }
      function cleanStack(stack) {
        var ret2 = [];
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
          var isInternalFrame = isTraceLine && shouldIgnore(line);
          if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
              line = "    " + line;
            }
            ret2.push(line);
          }
        }
        return ret2;
      }
      function stackFramesAsArray(error) {
        var stack = error.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
          }
        }
        if (i > 0 && error.name != "SyntaxError") {
          stack = stack.slice(i);
        }
        return stack;
      }
      function parseStackAndMessage(error) {
        var stack = error.stack;
        var message = error.toString();
        stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
        return {
          message,
          stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
        };
      }
      function formatAndLogError(error, title, isSoft) {
        if (typeof console !== "undefined") {
          var message;
          if (util2.isObject(error)) {
            var stack = error.stack;
            message = title + formatStack(stack, error);
          } else {
            message = title + String(error);
          }
          if (typeof printWarning === "function") {
            printWarning(message, isSoft);
          } else if (typeof console.log === "function" || typeof console.log === "object") {
            console.log(message);
          }
        }
      }
      function fireRejectionEvent(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
          if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
              localHandler(promise);
            } else {
              localHandler(reason, promise);
            }
          }
        } catch (e) {
          async.throwLater(e);
        }
        if (name === "unhandledRejection") {
          if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
          }
        } else {
          activeFireEvent(name, promise);
        }
      }
      function formatNonError(obj2) {
        var str;
        if (typeof obj2 === "function") {
          str = "[function " + (obj2.name || "anonymous") + "]";
        } else {
          str = obj2 && typeof obj2.toString === "function" ? obj2.toString() : util2.toString(obj2);
          var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
          if (ruselessToString.test(str)) {
            try {
              var newStr = JSON.stringify(obj2);
              str = newStr;
            } catch (e) {
            }
          }
          if (str.length === 0) {
            str = "(empty array)";
          }
        }
        return "(<" + snip(str) + ">, no stack trace)";
      }
      function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
          return str;
        }
        return str.substr(0, maxChars - 3) + "...";
      }
      function longStackTracesIsSupported() {
        return typeof captureStackTrace === "function";
      }
      var shouldIgnore = function() {
        return false;
      };
      var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
      function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
          return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
          };
        }
      }
      function setBounds(firstLineError, lastLineError) {
        if (!longStackTracesIsSupported())
          return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
          var result = parseLineInfo(firstStackLines[i]);
          if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
          }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
          var result = parseLineInfo(lastStackLines[i]);
          if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
          }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
          return;
        }
        shouldIgnore = function(line) {
          if (bluebirdFramePattern.test(line))
            return true;
          var info = parseLineInfo(line);
          if (info) {
            if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
              return true;
            }
          }
          return false;
        };
      }
      function CapturedTrace(parent) {
        this._parent = parent;
        this._promisesCreated = 0;
        var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32)
          this.uncycle();
      }
      util2.inherits(CapturedTrace, Error);
      Context.CapturedTrace = CapturedTrace;
      CapturedTrace.prototype.uncycle = function() {
        var length = this._length;
        if (length < 2)
          return;
        var nodes = [];
        var stackToIndex = {};
        for (var i = 0, node = this; node !== void 0; ++i) {
          nodes.push(node);
          node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
          var stack = nodes[i].stack;
          if (stackToIndex[stack] === void 0) {
            stackToIndex[stack] = i;
          }
        }
        for (var i = 0; i < length; ++i) {
          var currentStack = nodes[i].stack;
          var index = stackToIndex[currentStack];
          if (index !== void 0 && index !== i) {
            if (index > 0) {
              nodes[index - 1]._parent = void 0;
              nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = void 0;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
            if (index < length - 1) {
              cycleEdgeNode._parent = nodes[index + 1];
              cycleEdgeNode._parent.uncycle();
              cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
            } else {
              cycleEdgeNode._parent = void 0;
              cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
              nodes[j]._length = currentChildLength;
              currentChildLength++;
            }
            return;
          }
        }
      };
      CapturedTrace.prototype.attachExtraTrace = function(error) {
        if (error.__stackCleaned__)
          return;
        this.uncycle();
        var parsed = parseStackAndMessage(error);
        var message = parsed.message;
        var stacks = [parsed.stack];
        var trace = this;
        while (trace !== void 0) {
          stacks.push(cleanStack(trace.stack.split("\n")));
          trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util2.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
        util2.notEnumerableProp(error, "__stackCleaned__", true);
      };
      var captureStackTrace = function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function(stack, error) {
          if (typeof stack === "string")
            return stack;
          if (error.name !== void 0 && error.message !== void 0) {
            return error.toString();
          }
          return formatNonError(error);
        };
        if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
          Error.stackTraceLimit += 6;
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          var captureStackTrace2 = Error.captureStackTrace;
          shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
          };
          return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace2(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
          };
        }
        var err = new Error();
        if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
          stackFramePattern = /@/;
          formatStack = v8stackFormatter;
          indentStackFrames = true;
          return function captureStackTrace3(o) {
            o.stack = new Error().stack;
          };
        }
        var hasStackAfterThrow;
        try {
          throw new Error();
        } catch (e) {
          hasStackAfterThrow = "stack" in e;
        }
        if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          return function captureStackTrace3(o) {
            Error.stackTraceLimit += 6;
            try {
              throw new Error();
            } catch (e) {
              o.stack = e.stack;
            }
            Error.stackTraceLimit -= 6;
          };
        }
        formatStack = function(stack, error) {
          if (typeof stack === "string")
            return stack;
          if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
            return error.toString();
          }
          return formatNonError(error);
        };
        return null;
      }([]);
      if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        printWarning = function(message) {
          console.warn(message);
        };
        if (util2.isNode && process.stderr.isTTY) {
          printWarning = function(message, isSoft) {
            var color = isSoft ? "\x1B[33m" : "\x1B[31m";
            console.warn(color + message + "\x1B[0m\n");
          };
        } else if (!util2.isNode && typeof new Error().stack === "string") {
          printWarning = function(message, isSoft) {
            console.warn(
              "%c" + message,
              isSoft ? "color: darkorange" : "color: red"
            );
          };
        }
      }
      var config3 = {
        warnings,
        longStackTraces: false,
        cancellation: false,
        monitoring: false
      };
      if (longStackTraces)
        Promise2.longStackTraces();
      return {
        longStackTraces: function() {
          return config3.longStackTraces;
        },
        warnings: function() {
          return config3.warnings;
        },
        cancellation: function() {
          return config3.cancellation;
        },
        monitoring: function() {
          return config3.monitoring;
        },
        propagateFromFunction: function() {
          return propagateFromFunction;
        },
        boundValueFunction: function() {
          return boundValueFunction;
        },
        checkForgottenReturns,
        setBounds,
        warn,
        deprecated,
        CapturedTrace,
        fireDomEvent,
        fireGlobalEvent
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/catch_filter.js
var require_catch_filter = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/catch_filter.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(NEXT_FILTER) {
      var util2 = require_util();
      var getKeys2 = require_es5().keys;
      var tryCatch2 = util2.tryCatch;
      var errorObj2 = util2.errorObj;
      function catchFilter(instances, cb, promise) {
        return function(e) {
          var boundTo = promise._boundValue();
          predicateLoop:
            for (var i = 0; i < instances.length; ++i) {
              var item = instances[i];
              if (item === Error || item != null && item.prototype instanceof Error) {
                if (e instanceof item) {
                  return tryCatch2(cb).call(boundTo, e);
                }
              } else if (typeof item === "function") {
                var matchesPredicate = tryCatch2(item).call(boundTo, e);
                if (matchesPredicate === errorObj2) {
                  return matchesPredicate;
                } else if (matchesPredicate) {
                  return tryCatch2(cb).call(boundTo, e);
                }
              } else if (util2.isObject(e)) {
                var keys = getKeys2(item);
                for (var j = 0; j < keys.length; ++j) {
                  var key = keys[j];
                  if (item[key] != e[key]) {
                    continue predicateLoop;
                  }
                }
                return tryCatch2(cb).call(boundTo, e);
              }
            }
          return NEXT_FILTER;
        };
      }
      return catchFilter;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/finally.js
var require_finally = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/finally.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, tryConvertToPromise, NEXT_FILTER) {
      var util2 = require_util();
      var CancellationError = Promise2.CancellationError;
      var errorObj2 = util2.errorObj;
      var catchFilter = require_catch_filter()(NEXT_FILTER);
      function PassThroughHandlerContext(promise, type, handler) {
        this.promise = promise;
        this.type = type;
        this.handler = handler;
        this.called = false;
        this.cancelPromise = null;
      }
      PassThroughHandlerContext.prototype.isFinallyHandler = function() {
        return this.type === 0;
      };
      function FinallyHandlerCancelReaction(finallyHandler2) {
        this.finallyHandler = finallyHandler2;
      }
      FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
        checkCancel(this.finallyHandler);
      };
      function checkCancel(ctx, reason) {
        if (ctx.cancelPromise != null) {
          if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
          } else {
            ctx.cancelPromise._cancel();
          }
          ctx.cancelPromise = null;
          return true;
        }
        return false;
      }
      function succeed() {
        return finallyHandler.call(this, this.promise._target()._settledValue());
      }
      function fail(reason) {
        if (checkCancel(this, reason))
          return;
        errorObj2.e = reason;
        return errorObj2;
      }
      function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;
        if (!this.called) {
          this.called = true;
          var ret2 = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
          if (ret2 === NEXT_FILTER) {
            return ret2;
          } else if (ret2 !== void 0) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret2, promise);
            if (maybePromise instanceof Promise2) {
              if (this.cancelPromise != null) {
                if (maybePromise._isCancelled()) {
                  var reason = new CancellationError("late cancellation observer");
                  promise._attachExtraTrace(reason);
                  errorObj2.e = reason;
                  return errorObj2;
                } else if (maybePromise.isPending()) {
                  maybePromise._attachCancellationCallback(
                    new FinallyHandlerCancelReaction(this)
                  );
                }
              }
              return maybePromise._then(
                succeed,
                fail,
                void 0,
                this,
                void 0
              );
            }
          }
        }
        if (promise.isRejected()) {
          checkCancel(this);
          errorObj2.e = reasonOrValue;
          return errorObj2;
        } else {
          checkCancel(this);
          return reasonOrValue;
        }
      }
      Promise2.prototype._passThrough = function(handler, type, success, fail2) {
        if (typeof handler !== "function")
          return this.then();
        return this._then(
          success,
          fail2,
          void 0,
          new PassThroughHandlerContext(this, type, handler),
          void 0
        );
      };
      Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
        return this._passThrough(
          handler,
          0,
          finallyHandler,
          finallyHandler
        );
      };
      Promise2.prototype.tap = function(handler) {
        return this._passThrough(handler, 1, finallyHandler);
      };
      Promise2.prototype.tapCatch = function(handlerOrPredicate) {
        var len = arguments.length;
        if (len === 1) {
          return this._passThrough(
            handlerOrPredicate,
            1,
            void 0,
            finallyHandler
          );
        } else {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util2.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return Promise2.reject(new TypeError(
                "tapCatch statement predicate: expecting an object but got " + util2.classString(item)
              ));
            }
          }
          catchInstances.length = j;
          var handler = arguments[i];
          return this._passThrough(
            catchFilter(catchInstances, handler, this),
            1,
            void 0,
            finallyHandler
          );
        }
      };
      return PassThroughHandlerContext;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/nodeback.js
var require_nodeback = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/nodeback.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var util2 = require_util();
    var maybeWrapAsError2 = util2.maybeWrapAsError;
    var errors = require_errors();
    var OperationalError = errors.OperationalError;
    var es52 = require_es5();
    function isUntypedError(obj2) {
      return obj2 instanceof Error && es52.getPrototypeOf(obj2) === Error.prototype;
    }
    var rErrorKey = /^(?:name|message|stack|cause)$/;
    function wrapAsOperationalError(obj2) {
      var ret2;
      if (isUntypedError(obj2)) {
        ret2 = new OperationalError(obj2);
        ret2.name = obj2.name;
        ret2.message = obj2.message;
        ret2.stack = obj2.stack;
        var keys = es52.keys(obj2);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!rErrorKey.test(key)) {
            ret2[key] = obj2[key];
          }
        }
        return ret2;
      }
      util2.markAsOriginatingFromRejection(obj2);
      return obj2;
    }
    function nodebackForPromise(promise, multiArgs) {
      return function(err, value) {
        if (promise === null)
          return;
        if (err) {
          var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
          promise._attachExtraTrace(wrapped);
          promise._reject(wrapped);
        } else if (!multiArgs) {
          promise._fulfill(value);
        } else {
          var $_len = arguments.length;
          var args = new Array(Math.max($_len - 1, 0));
          for (var $_i = 1; $_i < $_len; ++$_i) {
            args[$_i - 1] = arguments[$_i];
          }
          ;
          promise._fulfill(args);
        }
        promise = null;
      };
    }
    module2.exports = nodebackForPromise;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/method.js
var require_method = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/method.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
      var util2 = require_util();
      var tryCatch2 = util2.tryCatch;
      Promise2.method = function(fn) {
        if (typeof fn !== "function") {
          throw new Promise2.TypeError("expecting a function but got " + util2.classString(fn));
        }
        return function() {
          var ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._pushContext();
          var value = tryCatch2(fn).apply(this, arguments);
          var promiseCreated = ret2._popContext();
          debug.checkForgottenReturns(
            value,
            promiseCreated,
            "Promise.method",
            ret2
          );
          ret2._resolveFromSyncValue(value);
          return ret2;
        };
      };
      Promise2.attempt = Promise2["try"] = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util2.classString(fn));
        }
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._pushContext();
        var value;
        if (arguments.length > 1) {
          debug.deprecated("calling Promise.try with more than 1 argument");
          var arg = arguments[1];
          var ctx = arguments[2];
          value = util2.isArray(arg) ? tryCatch2(fn).apply(ctx, arg) : tryCatch2(fn).call(ctx, arg);
        } else {
          value = tryCatch2(fn)();
        }
        var promiseCreated = ret2._popContext();
        debug.checkForgottenReturns(
          value,
          promiseCreated,
          "Promise.try",
          ret2
        );
        ret2._resolveFromSyncValue(value);
        return ret2;
      };
      Promise2.prototype._resolveFromSyncValue = function(value) {
        if (value === util2.errorObj) {
          this._rejectCallback(value.e, false);
        } else {
          this._resolveCallback(value, true);
        }
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/bind.js
var require_bind = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/bind.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
      var calledBind = false;
      var rejectThis = function(_, e) {
        this._reject(e);
      };
      var targetRejected = function(e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
      };
      var bindingResolved = function(thisArg, context) {
        if ((this._bitField & 50397184) === 0) {
          this._resolveCallback(context.target);
        }
      };
      var bindingRejected = function(e, context) {
        if (!context.promiseRejectionQueued)
          this._reject(e);
      };
      Promise2.prototype.bind = function(thisArg) {
        if (!calledBind) {
          calledBind = true;
          Promise2.prototype._propagateFrom = debug.propagateFromFunction();
          Promise2.prototype._boundValue = debug.boundValueFunction();
        }
        var maybePromise = tryConvertToPromise(thisArg);
        var ret2 = new Promise2(INTERNAL);
        ret2._propagateFrom(this, 1);
        var target = this._target();
        ret2._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise2) {
          var context = {
            promiseRejectionQueued: false,
            promise: ret2,
            target,
            bindingPromise: maybePromise
          };
          target._then(INTERNAL, targetRejected, void 0, ret2, context);
          maybePromise._then(
            bindingResolved,
            bindingRejected,
            void 0,
            ret2,
            context
          );
          ret2._setOnCancel(maybePromise);
        } else {
          ret2._resolveCallback(target);
        }
        return ret2;
      };
      Promise2.prototype._setBoundTo = function(obj2) {
        if (obj2 !== void 0) {
          this._bitField = this._bitField | 2097152;
          this._boundTo = obj2;
        } else {
          this._bitField = this._bitField & ~2097152;
        }
      };
      Promise2.prototype._isBound = function() {
        return (this._bitField & 2097152) === 2097152;
      };
      Promise2.bind = function(thisArg, value) {
        return Promise2.resolve(value).bind(thisArg);
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/cancel.js
var require_cancel = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/cancel.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, PromiseArray, apiRejection, debug) {
      var util2 = require_util();
      var tryCatch2 = util2.tryCatch;
      var errorObj2 = util2.errorObj;
      var async = Promise2._async;
      Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
        if (!debug.cancellation())
          return this._warn("cancellation is disabled");
        var promise = this;
        var child = promise;
        while (promise._isCancellable()) {
          if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
              child._followee().cancel();
            } else {
              child._cancelBranched();
            }
            break;
          }
          var parent = promise._cancellationParent;
          if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
              promise._followee().cancel();
            } else {
              promise._cancelBranched();
            }
            break;
          } else {
            if (promise._isFollowing())
              promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
          }
        }
      };
      Promise2.prototype._branchHasCancelled = function() {
        this._branchesRemainingToCancel--;
      };
      Promise2.prototype._enoughBranchesHaveCancelled = function() {
        return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
      };
      Promise2.prototype._cancelBy = function(canceller) {
        if (canceller === this) {
          this._branchesRemainingToCancel = 0;
          this._invokeOnCancel();
          return true;
        } else {
          this._branchHasCancelled();
          if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
          }
        }
        return false;
      };
      Promise2.prototype._cancelBranched = function() {
        if (this._enoughBranchesHaveCancelled()) {
          this._cancel();
        }
      };
      Promise2.prototype._cancel = function() {
        if (!this._isCancellable())
          return;
        this._setCancelled();
        async.invoke(this._cancelPromises, this, void 0);
      };
      Promise2.prototype._cancelPromises = function() {
        if (this._length() > 0)
          this._settlePromises();
      };
      Promise2.prototype._unsetOnCancel = function() {
        this._onCancelField = void 0;
      };
      Promise2.prototype._isCancellable = function() {
        return this.isPending() && !this._isCancelled();
      };
      Promise2.prototype.isCancellable = function() {
        return this.isPending() && !this.isCancelled();
      };
      Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
        if (util2.isArray(onCancelCallback)) {
          for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
          }
        } else if (onCancelCallback !== void 0) {
          if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
              var e = tryCatch2(onCancelCallback).call(this._boundValue());
              if (e === errorObj2) {
                this._attachExtraTrace(e.e);
                async.throwLater(e.e);
              }
            }
          } else {
            onCancelCallback._resultCancelled(this);
          }
        }
      };
      Promise2.prototype._invokeOnCancel = function() {
        var onCancelCallback = this._onCancel();
        this._unsetOnCancel();
        async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
      };
      Promise2.prototype._invokeInternalOnCancel = function() {
        if (this._isCancellable()) {
          this._doInvokeOnCancel(this._onCancel(), true);
          this._unsetOnCancel();
        }
      };
      Promise2.prototype._resultCancelled = function() {
        this.cancel();
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/direct_resolve.js
var require_direct_resolve = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/direct_resolve.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2) {
      function returner() {
        return this.value;
      }
      function thrower2() {
        throw this.reason;
      }
      Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
        if (value instanceof Promise2)
          value.suppressUnhandledRejections();
        return this._then(
          returner,
          void 0,
          void 0,
          { value },
          void 0
        );
      };
      Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
        return this._then(
          thrower2,
          void 0,
          void 0,
          { reason },
          void 0
        );
      };
      Promise2.prototype.catchThrow = function(reason) {
        if (arguments.length <= 1) {
          return this._then(
            void 0,
            thrower2,
            void 0,
            { reason },
            void 0
          );
        } else {
          var _reason = arguments[1];
          var handler = function() {
            throw _reason;
          };
          return this.caught(reason, handler);
        }
      };
      Promise2.prototype.catchReturn = function(value) {
        if (arguments.length <= 1) {
          if (value instanceof Promise2)
            value.suppressUnhandledRejections();
          return this._then(
            void 0,
            returner,
            void 0,
            { value },
            void 0
          );
        } else {
          var _value = arguments[1];
          if (_value instanceof Promise2)
            _value.suppressUnhandledRejections();
          var handler = function() {
            return _value;
          };
          return this.caught(value, handler);
        }
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/synchronous_inspection.js
var require_synchronous_inspection = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/synchronous_inspection.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2) {
      function PromiseInspection(promise) {
        if (promise !== void 0) {
          promise = promise._target();
          this._bitField = promise._bitField;
          this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0;
        } else {
          this._bitField = 0;
          this._settledValueField = void 0;
        }
      }
      PromiseInspection.prototype._settledValue = function() {
        return this._settledValueField;
      };
      var value = PromiseInspection.prototype.value = function() {
        if (!this.isFulfilled()) {
          throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
        if (!this.isRejected()) {
          throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
        return (this._bitField & 33554432) !== 0;
      };
      var isRejected = PromiseInspection.prototype.isRejected = function() {
        return (this._bitField & 16777216) !== 0;
      };
      var isPending = PromiseInspection.prototype.isPending = function() {
        return (this._bitField & 50397184) === 0;
      };
      var isResolved = PromiseInspection.prototype.isResolved = function() {
        return (this._bitField & 50331648) !== 0;
      };
      PromiseInspection.prototype.isCancelled = function() {
        return (this._bitField & 8454144) !== 0;
      };
      Promise2.prototype.__isCancelled = function() {
        return (this._bitField & 65536) === 65536;
      };
      Promise2.prototype._isCancelled = function() {
        return this._target().__isCancelled();
      };
      Promise2.prototype.isCancelled = function() {
        return (this._target()._bitField & 8454144) !== 0;
      };
      Promise2.prototype.isPending = function() {
        return isPending.call(this._target());
      };
      Promise2.prototype.isRejected = function() {
        return isRejected.call(this._target());
      };
      Promise2.prototype.isFulfilled = function() {
        return isFulfilled.call(this._target());
      };
      Promise2.prototype.isResolved = function() {
        return isResolved.call(this._target());
      };
      Promise2.prototype.value = function() {
        return value.call(this._target());
      };
      Promise2.prototype.reason = function() {
        var target = this._target();
        target._unsetRejectionIsUnhandled();
        return reason.call(target);
      };
      Promise2.prototype._value = function() {
        return this._settledValue();
      };
      Promise2.prototype._reason = function() {
        this._unsetRejectionIsUnhandled();
        return this._settledValue();
      };
      Promise2.PromiseInspection = PromiseInspection;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/join.js
var require_join = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/join.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
      var util2 = require_util();
      var canEvaluate2 = util2.canEvaluate;
      var tryCatch2 = util2.tryCatch;
      var errorObj2 = util2.errorObj;
      var reject;
      if (true) {
        if (canEvaluate2) {
          var thenCallback = function(i2) {
            return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
          };
          var promiseSetter = function(i2) {
            return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i2));
          };
          var generateHolderClass = function(total) {
            var props = new Array(total);
            for (var i2 = 0; i2 < props.length; ++i2) {
              props[i2] = "this.p" + (i2 + 1);
            }
            var assignment = props.join(" = ") + " = null;";
            var cancellationCode = "var promise;\n" + props.map(function(prop) {
              return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
            }).join("\n");
            var passedArguments = props.join(", ");
            var name = "Holder$" + total;
            var code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
            code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
            return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch2, errorObj2, Promise2, async);
          };
          var holderClasses = [];
          var thenCallbacks = [];
          var promiseSetters = [];
          for (var i = 0; i < 8; ++i) {
            holderClasses.push(generateHolderClass(i + 1));
            thenCallbacks.push(thenCallback(i + 1));
            promiseSetters.push(promiseSetter(i + 1));
          }
          reject = function(reason) {
            this._reject(reason);
          };
        }
      }
      Promise2.join = function() {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
          fn = arguments[last];
          if (true) {
            if (last <= 8 && canEvaluate2) {
              var ret2 = new Promise2(INTERNAL);
              ret2._captureStackTrace();
              var HolderClass = holderClasses[last - 1];
              var holder = new HolderClass(fn);
              var callbacks = thenCallbacks;
              for (var i2 = 0; i2 < last; ++i2) {
                var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                if (maybePromise instanceof Promise2) {
                  maybePromise = maybePromise._target();
                  var bitField = maybePromise._bitField;
                  ;
                  if ((bitField & 50397184) === 0) {
                    maybePromise._then(
                      callbacks[i2],
                      reject,
                      void 0,
                      ret2,
                      holder
                    );
                    promiseSetters[i2](maybePromise, holder);
                    holder.asyncNeeded = false;
                  } else if ((bitField & 33554432) !== 0) {
                    callbacks[i2].call(
                      ret2,
                      maybePromise._value(),
                      holder
                    );
                  } else if ((bitField & 16777216) !== 0) {
                    ret2._reject(maybePromise._reason());
                  } else {
                    ret2._cancel();
                  }
                } else {
                  callbacks[i2].call(ret2, maybePromise, holder);
                }
              }
              if (!ret2._isFateSealed()) {
                if (holder.asyncNeeded) {
                  var domain = getDomain();
                  if (domain !== null) {
                    holder.fn = util2.domainBind(domain, holder.fn);
                  }
                }
                ret2._setAsyncGuaranteed();
                ret2._setOnCancel(holder);
              }
              return ret2;
            }
          }
        }
        var $_len = arguments.length;
        var args = new Array($_len);
        for (var $_i = 0; $_i < $_len; ++$_i) {
          args[$_i] = arguments[$_i];
        }
        ;
        if (fn)
          args.pop();
        var ret2 = new PromiseArray(args).promise();
        return fn !== void 0 ? ret2.spread(fn) : ret2;
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/map.js
var require_map = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/map.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
      var getDomain = Promise2._getDomain;
      var util2 = require_util();
      var tryCatch2 = util2.tryCatch;
      var errorObj2 = util2.errorObj;
      var async = Promise2._async;
      function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        var domain = getDomain();
        this._callback = domain === null ? fn : util2.domainBind(domain, fn);
        this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = [];
        async.invoke(this._asyncInit, this, void 0);
      }
      util2.inherits(MappingPromiseArray, PromiseArray);
      MappingPromiseArray.prototype._asyncInit = function() {
        this._init$(void 0, -2);
      };
      MappingPromiseArray.prototype._init = function() {
      };
      MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;
        if (index < 0) {
          index = index * -1 - 1;
          values[index] = value;
          if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved())
              return true;
          }
        } else {
          if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return false;
          }
          if (preservedValues !== null)
            preservedValues[index] = value;
          var promise = this._promise;
          var callback = this._callback;
          var receiver = promise._boundValue();
          promise._pushContext();
          var ret2 = tryCatch2(callback).call(receiver, value, index, length);
          var promiseCreated = promise._popContext();
          debug.checkForgottenReturns(
            ret2,
            promiseCreated,
            preservedValues !== null ? "Promise.filter" : "Promise.map",
            promise
          );
          if (ret2 === errorObj2) {
            this._reject(ret2.e);
            return true;
          }
          var maybePromise = tryConvertToPromise(ret2, this._promise);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if ((bitField & 50397184) === 0) {
              if (limit >= 1)
                this._inFlight++;
              values[index] = maybePromise;
              maybePromise._proxy(this, (index + 1) * -1);
              return false;
            } else if ((bitField & 33554432) !== 0) {
              ret2 = maybePromise._value();
            } else if ((bitField & 16777216) !== 0) {
              this._reject(maybePromise._reason());
              return true;
            } else {
              this._cancel();
              return true;
            }
          }
          values[index] = ret2;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
          if (preservedValues !== null) {
            this._filter(values, preservedValues);
          } else {
            this._resolve(values);
          }
          return true;
        }
        return false;
      };
      MappingPromiseArray.prototype._drainQueue = function() {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while (queue.length > 0 && this._inFlight < limit) {
          if (this._isResolved())
            return;
          var index = queue.pop();
          this._promiseFulfilled(values[index], index);
        }
      };
      MappingPromiseArray.prototype._filter = function(booleans, values) {
        var len = values.length;
        var ret2 = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
          if (booleans[i])
            ret2[j++] = values[i];
        }
        ret2.length = j;
        this._resolve(ret2);
      };
      MappingPromiseArray.prototype.preservedValues = function() {
        return this._preservedValues;
      };
      function map(promises, fn, options, _filter) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util2.classString(fn));
        }
        var limit = 0;
        if (options !== void 0) {
          if (typeof options === "object" && options !== null) {
            if (typeof options.concurrency !== "number") {
              return Promise2.reject(
                new TypeError("'concurrency' must be a number but it is " + util2.classString(options.concurrency))
              );
            }
            limit = options.concurrency;
          } else {
            return Promise2.reject(new TypeError(
              "options argument must be an object but it is " + util2.classString(options)
            ));
          }
        }
        limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter).promise();
      }
      Promise2.prototype.map = function(fn, options) {
        return map(this, fn, options, null);
      };
      Promise2.map = function(promises, fn, options, _filter) {
        return map(promises, fn, options, _filter);
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/call_get.js
var require_call_get = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/call_get.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var cr = Object.create;
    if (cr) {
      callerCache = cr(null);
      getterCache = cr(null);
      callerCache[" size"] = getterCache[" size"] = 0;
    }
    var callerCache;
    var getterCache;
    module2.exports = function(Promise2) {
      var util2 = require_util();
      var canEvaluate2 = util2.canEvaluate;
      var isIdentifier2 = util2.isIdentifier;
      var getMethodCaller;
      var getGetter;
      if (true) {
        var makeMethodCaller = function(methodName) {
          return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
        };
        var makeGetter = function(propertyName) {
          return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
        };
        var getCompiled = function(name, compiler, cache) {
          var ret2 = cache[name];
          if (typeof ret2 !== "function") {
            if (!isIdentifier2(name)) {
              return null;
            }
            ret2 = compiler(name);
            cache[name] = ret2;
            cache[" size"]++;
            if (cache[" size"] > 512) {
              var keys = Object.keys(cache);
              for (var i = 0; i < 256; ++i)
                delete cache[keys[i]];
              cache[" size"] = keys.length - 256;
            }
          }
          return ret2;
        };
        getMethodCaller = function(name) {
          return getCompiled(name, makeMethodCaller, callerCache);
        };
        getGetter = function(name) {
          return getCompiled(name, makeGetter, getterCache);
        };
      }
      function ensureMethod(obj2, methodName) {
        var fn;
        if (obj2 != null)
          fn = obj2[methodName];
        if (typeof fn !== "function") {
          var message = "Object " + util2.classString(obj2) + " has no method '" + util2.toString(methodName) + "'";
          throw new Promise2.TypeError(message);
        }
        return fn;
      }
      function caller(obj2) {
        var methodName = this.pop();
        var fn = ensureMethod(obj2, methodName);
        return fn.apply(obj2, this);
      }
      Promise2.prototype.call = function(methodName) {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        ;
        if (true) {
          if (canEvaluate2) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
              return this._then(
                maybeCaller,
                void 0,
                void 0,
                args,
                void 0
              );
            }
          }
        }
        args.push(methodName);
        return this._then(caller, void 0, void 0, args, void 0);
      };
      function namedGetter(obj2) {
        return obj2[this];
      }
      function indexedGetter(obj2) {
        var index = +this;
        if (index < 0)
          index = Math.max(0, index + obj2.length);
        return obj2[index];
      }
      Promise2.prototype.get = function(propertyName) {
        var isIndex = typeof propertyName === "number";
        var getter;
        if (!isIndex) {
          if (canEvaluate2) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
          } else {
            getter = namedGetter;
          }
        } else {
          getter = indexedGetter;
        }
        return this._then(getter, void 0, void 0, propertyName, void 0);
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/using.js
var require_using = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/using.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
      var util2 = require_util();
      var TypeError2 = require_errors().TypeError;
      var inherits2 = require_util().inherits;
      var errorObj2 = util2.errorObj;
      var tryCatch2 = util2.tryCatch;
      var NULL = {};
      function thrower2(e) {
        setTimeout(function() {
          throw e;
        }, 0);
      }
      function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
          maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
      }
      function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret2 = new Promise2(INTERNAL);
        function iterator() {
          if (i >= len)
            return ret2._fulfill();
          var maybePromise = castPreservingDisposable(resources[i++]);
          if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
            try {
              maybePromise = tryConvertToPromise(
                maybePromise._getDisposer().tryDispose(inspection),
                resources.promise
              );
            } catch (e) {
              return thrower2(e);
            }
            if (maybePromise instanceof Promise2) {
              return maybePromise._then(
                iterator,
                thrower2,
                null,
                null,
                null
              );
            }
          }
          iterator();
        }
        iterator();
        return ret2;
      }
      function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
      }
      Disposer.prototype.data = function() {
        return this._data;
      };
      Disposer.prototype.promise = function() {
        return this._promise;
      };
      Disposer.prototype.resource = function() {
        if (this.promise().isFulfilled()) {
          return this.promise().value();
        }
        return NULL;
      };
      Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== void 0)
          context._pushContext();
        var ret2 = resource !== NULL ? this.doDispose(resource, inspection) : null;
        if (context !== void 0)
          context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret2;
      };
      Disposer.isDisposer = function(d) {
        return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
      };
      function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
      }
      inherits2(FunctionDisposer, Disposer);
      FunctionDisposer.prototype.doDispose = function(resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
      };
      function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
          this.resources[this.index]._setDisposable(value);
          return value.promise();
        }
        return value;
      }
      function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length - 1] = null;
      }
      ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
          var item = this[i];
          if (item instanceof Promise2) {
            item.cancel();
          }
        }
      };
      Promise2.using = function() {
        var len = arguments.length;
        if (len < 2)
          return apiRejection(
            "you must pass at least 2 arguments to Promise.using"
          );
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util2.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
          input = arguments[0];
          len = input.length;
          spreadArgs = false;
        } else {
          input = arguments;
          len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
          var resource = input[i];
          if (Disposer.isDisposer(resource)) {
            var disposer = resource;
            resource = resource.promise();
            resource._setDisposable(disposer);
          } else {
            var maybePromise = tryConvertToPromise(resource);
            if (maybePromise instanceof Promise2) {
              resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                resources,
                index: i
              }, void 0);
            }
          }
          resources[i] = resource;
        }
        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
          reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
        }
        var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
          for (var i2 = 0; i2 < inspections.length; ++i2) {
            var inspection = inspections[i2];
            if (inspection.isRejected()) {
              errorObj2.e = inspection.error();
              return errorObj2;
            } else if (!inspection.isFulfilled()) {
              resultPromise.cancel();
              return;
            }
            inspections[i2] = inspection.value();
          }
          promise._pushContext();
          fn = tryCatch2(fn);
          var ret2 = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
          var promiseCreated = promise._popContext();
          debug.checkForgottenReturns(
            ret2,
            promiseCreated,
            "Promise.using",
            promise
          );
          return ret2;
        });
        var promise = resultPromise.lastly(function() {
          var inspection = new Promise2.PromiseInspection(resultPromise);
          return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
      };
      Promise2.prototype._setDisposable = function(disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
      };
      Promise2.prototype._isDisposable = function() {
        return (this._bitField & 131072) > 0;
      };
      Promise2.prototype._getDisposer = function() {
        return this._disposer;
      };
      Promise2.prototype._unsetDisposable = function() {
        this._bitField = this._bitField & ~131072;
        this._disposer = void 0;
      };
      Promise2.prototype.disposer = function(fn) {
        if (typeof fn === "function") {
          return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError2();
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/timers.js
var require_timers = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/timers.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, INTERNAL, debug) {
      var util2 = require_util();
      var TimeoutError = Promise2.TimeoutError;
      function HandleWrapper(handle) {
        this.handle = handle;
      }
      HandleWrapper.prototype._resultCancelled = function() {
        clearTimeout(this.handle);
      };
      var afterValue = function(value) {
        return delay(+this).thenReturn(value);
      };
      var delay = Promise2.delay = function(ms, value) {
        var ret2;
        var handle;
        if (value !== void 0) {
          ret2 = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
          if (debug.cancellation() && value instanceof Promise2) {
            ret2._setOnCancel(value);
          }
        } else {
          ret2 = new Promise2(INTERNAL);
          handle = setTimeout(function() {
            ret2._fulfill();
          }, +ms);
          if (debug.cancellation()) {
            ret2._setOnCancel(new HandleWrapper(handle));
          }
          ret2._captureStackTrace();
        }
        ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.prototype.delay = function(ms) {
        return delay(ms, this);
      };
      var afterTimeout = function(promise, message, parent) {
        var err;
        if (typeof message !== "string") {
          if (message instanceof Error) {
            err = message;
          } else {
            err = new TimeoutError("operation timed out");
          }
        } else {
          err = new TimeoutError(message);
        }
        util2.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._reject(err);
        if (parent != null) {
          parent.cancel();
        }
      };
      function successClear(value) {
        clearTimeout(this.handle);
        return value;
      }
      function failureClear(reason) {
        clearTimeout(this.handle);
        throw reason;
      }
      Promise2.prototype.timeout = function(ms, message) {
        ms = +ms;
        var ret2, parent;
        var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
          if (ret2.isPending()) {
            afterTimeout(ret2, message, parent);
          }
        }, ms));
        if (debug.cancellation()) {
          parent = this.then();
          ret2 = parent._then(
            successClear,
            failureClear,
            void 0,
            handleWrapper,
            void 0
          );
          ret2._setOnCancel(handleWrapper);
        } else {
          ret2 = this._then(
            successClear,
            failureClear,
            void 0,
            handleWrapper,
            void 0
          );
        }
        return ret2;
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/generators.js
var require_generators = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/generators.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
      var errors = require_errors();
      var TypeError2 = errors.TypeError;
      var util2 = require_util();
      var errorObj2 = util2.errorObj;
      var tryCatch2 = util2.tryCatch;
      var yieldHandlers = [];
      function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
        for (var i = 0; i < yieldHandlers2.length; ++i) {
          traceParent._pushContext();
          var result = tryCatch2(yieldHandlers2[i])(value);
          traceParent._popContext();
          if (result === errorObj2) {
            traceParent._pushContext();
            var ret2 = Promise2.reject(errorObj2.e);
            traceParent._popContext();
            return ret2;
          }
          var maybePromise = tryConvertToPromise(result, traceParent);
          if (maybePromise instanceof Promise2)
            return maybePromise;
        }
        return null;
      }
      function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        if (debug.cancellation()) {
          var internal = new Promise2(INTERNAL);
          var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
          this._promise = internal.lastly(function() {
            return _finallyPromise;
          });
          internal._captureStackTrace();
          internal._setOnCancel(this);
        } else {
          var promise = this._promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
        }
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = void 0;
        this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
        this._yieldedPromise = null;
        this._cancellationPhase = false;
      }
      util2.inherits(PromiseSpawn, Proxyable);
      PromiseSpawn.prototype._isResolved = function() {
        return this._promise === null;
      };
      PromiseSpawn.prototype._cleanup = function() {
        this._promise = this._generator = null;
        if (debug.cancellation() && this._finallyPromise !== null) {
          this._finallyPromise._fulfill();
          this._finallyPromise = null;
        }
      };
      PromiseSpawn.prototype._promiseCancelled = function() {
        if (this._isResolved())
          return;
        var implementsReturn = typeof this._generator["return"] !== "undefined";
        var result;
        if (!implementsReturn) {
          var reason = new Promise2.CancellationError(
            "generator .return() sentinel"
          );
          Promise2.coroutine.returnSentinel = reason;
          this._promise._attachExtraTrace(reason);
          this._promise._pushContext();
          result = tryCatch2(this._generator["throw"]).call(
            this._generator,
            reason
          );
          this._promise._popContext();
        } else {
          this._promise._pushContext();
          result = tryCatch2(this._generator["return"]).call(
            this._generator,
            void 0
          );
          this._promise._popContext();
        }
        this._cancellationPhase = true;
        this._yieldedPromise = null;
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseFulfilled = function(value) {
        this._yieldedPromise = null;
        this._promise._pushContext();
        var result = tryCatch2(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._promiseRejected = function(reason) {
        this._yieldedPromise = null;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch2(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
      };
      PromiseSpawn.prototype._resultCancelled = function() {
        if (this._yieldedPromise instanceof Promise2) {
          var promise = this._yieldedPromise;
          this._yieldedPromise = null;
          promise.cancel();
        }
      };
      PromiseSpawn.prototype.promise = function() {
        return this._promise;
      };
      PromiseSpawn.prototype._run = function() {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver = this._generatorFunction = void 0;
        this._promiseFulfilled(void 0);
      };
      PromiseSpawn.prototype._continue = function(result) {
        var promise = this._promise;
        if (result === errorObj2) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._rejectCallback(result.e, false);
          }
        }
        var value = result.value;
        if (result.done === true) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._resolveCallback(value);
          }
        } else {
          var maybePromise = tryConvertToPromise(value, this._promise);
          if (!(maybePromise instanceof Promise2)) {
            maybePromise = promiseFromYieldHandler(
              maybePromise,
              this._yieldHandlers,
              this._promise
            );
            if (maybePromise === null) {
              this._promiseRejected(
                new TypeError2(
                  "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(value)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
                )
              );
              return;
            }
          }
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          ;
          if ((bitField & 50397184) === 0) {
            this._yieldedPromise = maybePromise;
            maybePromise._proxy(this, null);
          } else if ((bitField & 33554432) !== 0) {
            Promise2._async.invoke(
              this._promiseFulfilled,
              this,
              maybePromise._value()
            );
          } else if ((bitField & 16777216) !== 0) {
            Promise2._async.invoke(
              this._promiseRejected,
              this,
              maybePromise._reason()
            );
          } else {
            this._promiseCancelled();
          }
        }
      };
      Promise2.coroutine = function(generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
          throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function() {
          var generator = generatorFunction.apply(this, arguments);
          var spawn = new PromiseSpawn$(
            void 0,
            void 0,
            yieldHandler,
            stack
          );
          var ret2 = spawn.promise();
          spawn._generator = generator;
          spawn._promiseFulfilled(void 0);
          return ret2;
        };
      };
      Promise2.coroutine.addYieldHandler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util2.classString(fn));
        }
        yieldHandlers.push(fn);
      };
      Promise2.spawn = function(generatorFunction) {
        debug.deprecated("Promise.spawn()", "Promise.coroutine()");
        if (typeof generatorFunction !== "function") {
          return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret2 = spawn.promise();
        spawn._run(Promise2.spawn);
        return ret2;
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/nodeify.js
var require_nodeify = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/nodeify.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2) {
      var util2 = require_util();
      var async = Promise2._async;
      var tryCatch2 = util2.tryCatch;
      var errorObj2 = util2.errorObj;
      function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util2.isArray(val))
          return successAdapter.call(promise, val, nodeback);
        var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundValue();
        var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver, null) : tryCatch2(nodeback).call(receiver, null, val);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
          var newReason = new Error(reason + "");
          newReason.cause = reason;
          reason = newReason;
        }
        var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
        if (typeof nodeback == "function") {
          var adapter = successAdapter;
          if (options !== void 0 && Object(options).spread) {
            adapter = spreadAdapter;
          }
          this._then(
            adapter,
            errorAdapter,
            void 0,
            this,
            nodeback
          );
        }
        return this;
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/promisify.js
var require_promisify = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/promisify.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, INTERNAL) {
      var THIS = {};
      var util2 = require_util();
      var nodebackForPromise = require_nodeback();
      var withAppended2 = util2.withAppended;
      var maybeWrapAsError2 = util2.maybeWrapAsError;
      var canEvaluate2 = util2.canEvaluate;
      var TypeError2 = require_errors().TypeError;
      var defaultSuffix = "Async";
      var defaultPromisified = { __isPromisified__: true };
      var noCopyProps = [
        "arity",
        "length",
        "name",
        "arguments",
        "caller",
        "callee",
        "prototype",
        "__isPromisified__"
      ];
      var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
      var defaultFilter = function(name) {
        return util2.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
      };
      function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
      }
      function isPromisified(fn) {
        try {
          return fn.__isPromisified__ === true;
        } catch (e) {
          return false;
        }
      }
      function hasPromisified(obj2, key, suffix) {
        var val = util2.getDataPropertyOrDefault(
          obj2,
          key + suffix,
          defaultPromisified
        );
        return val ? isPromisified(val) : false;
      }
      function checkValid(ret2, suffix, suffixRegexp) {
        for (var i = 0; i < ret2.length; i += 2) {
          var key = ret2[i];
          if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret2.length; j += 2) {
              if (ret2[j] === keyWithoutAsyncSuffix) {
                throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
              }
            }
          }
        }
      }
      function promisifiableMethods(obj2, suffix, suffixRegexp, filter) {
        var keys = util2.inheritedDataKeys(obj2);
        var ret2 = [];
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          var value = obj2[key];
          var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj2);
          if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter(key, value, obj2, passesDefaultFilter)) {
            ret2.push(key, value);
          }
        }
        checkValid(ret2, suffix, suffixRegexp);
        return ret2;
      }
      var escapeIdentRegex = function(str) {
        return str.replace(/([$])/, "\\$");
      };
      var makeNodePromisifiedEval;
      if (true) {
        var switchCaseArgumentOrder = function(likelyArgumentCount) {
          var ret2 = [likelyArgumentCount];
          var min = Math.max(0, likelyArgumentCount - 1 - 3);
          for (var i = likelyArgumentCount - 1; i >= min; --i) {
            ret2.push(i);
          }
          for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
            ret2.push(i);
          }
          return ret2;
        };
        var argumentSequence = function(argumentCount) {
          return util2.filledRange(argumentCount, "_arg", "");
        };
        var parameterDeclaration = function(parameterCount2) {
          return util2.filledRange(
            Math.max(parameterCount2, 3),
            "_arg",
            ""
          );
        };
        var parameterCount = function(fn) {
          if (typeof fn.length === "number") {
            return Math.max(Math.min(fn.length, 1023 + 1), 0);
          }
          return 0;
        };
        makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _, multiArgs) {
          var newParameterCount = Math.max(0, parameterCount(fn) - 1);
          var argumentOrder = switchCaseArgumentOrder(newParameterCount);
          var shouldProxyThis = typeof callback === "string" || receiver === THIS;
          function generateCallForArgumentCount(count) {
            var args = argumentSequence(count).join(", ");
            var comma = count > 0 ? ", " : "";
            var ret2;
            if (shouldProxyThis) {
              ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
            } else {
              ret2 = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
            }
            return ret2.replace("{{args}}", args).replace(", ", comma);
          }
          function generateArgumentSwitchCase() {
            var ret2 = "";
            for (var i = 0; i < argumentOrder.length; ++i) {
              ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
            }
            ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
            return ret2;
          }
          var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
          var body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
          body = body.replace("Parameters", parameterDeclaration(newParameterCount));
          return new Function(
            "Promise",
            "fn",
            "receiver",
            "withAppended",
            "maybeWrapAsError",
            "nodebackForPromise",
            "tryCatch",
            "errorObj",
            "notEnumerableProp",
            "INTERNAL",
            body
          )(
            Promise2,
            fn,
            receiver,
            withAppended2,
            maybeWrapAsError2,
            nodebackForPromise,
            util2.tryCatch,
            util2.errorObj,
            util2.notEnumerableProp,
            INTERNAL
          );
        };
      }
      function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
        var defaultThis = function() {
          return this;
        }();
        var method = callback;
        if (typeof method === "string") {
          callback = fn;
        }
        function promisified() {
          var _receiver = receiver;
          if (receiver === THIS)
            _receiver = this;
          var promise = new Promise2(INTERNAL);
          promise._captureStackTrace();
          var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
          var fn2 = nodebackForPromise(promise, multiArgs);
          try {
            cb.apply(_receiver, withAppended2(arguments, fn2));
          } catch (e) {
            promise._rejectCallback(maybeWrapAsError2(e), true, true);
          }
          if (!promise._isFateSealed())
            promise._setAsyncGuaranteed();
          return promise;
        }
        util2.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
      }
      var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
      function promisifyAll(obj2, suffix, filter, promisifier, multiArgs) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter);
        for (var i = 0, len = methods.length; i < len; i += 2) {
          var key = methods[i];
          var fn = methods[i + 1];
          var promisifiedKey = key + suffix;
          if (promisifier === makeNodePromisified) {
            obj2[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
          } else {
            var promisified = promisifier(fn, function() {
              return makeNodePromisified(
                key,
                THIS,
                key,
                fn,
                suffix,
                multiArgs
              );
            });
            util2.notEnumerableProp(promisified, "__isPromisified__", true);
            obj2[promisifiedKey] = promisified;
          }
        }
        util2.toFastProperties(obj2);
        return obj2;
      }
      function promisify(callback, receiver, multiArgs) {
        return makeNodePromisified(
          callback,
          receiver,
          void 0,
          callback,
          null,
          multiArgs
        );
      }
      Promise2.promisify = function(fn, options) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util2.classString(fn));
        }
        if (isPromisified(fn)) {
          return fn;
        }
        options = Object(options);
        var receiver = options.context === void 0 ? THIS : options.context;
        var multiArgs = !!options.multiArgs;
        var ret2 = promisify(fn, receiver, multiArgs);
        util2.copyDescriptors(fn, ret2, propsFilter);
        return ret2;
      };
      Promise2.promisifyAll = function(target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
          throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        options = Object(options);
        var multiArgs = !!options.multiArgs;
        var suffix = options.suffix;
        if (typeof suffix !== "string")
          suffix = defaultSuffix;
        var filter = options.filter;
        if (typeof filter !== "function")
          filter = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function")
          promisifier = makeNodePromisified;
        if (!util2.isIdentifier(suffix)) {
          throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
        }
        var keys = util2.inheritedDataKeys(target);
        for (var i = 0; i < keys.length; ++i) {
          var value = target[keys[i]];
          if (keys[i] !== "constructor" && util2.isClass(value)) {
            promisifyAll(
              value.prototype,
              suffix,
              filter,
              promisifier,
              multiArgs
            );
            promisifyAll(value, suffix, filter, promisifier, multiArgs);
          }
        }
        return promisifyAll(target, suffix, filter, promisifier, multiArgs);
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/props.js
var require_props = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/props.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
      var util2 = require_util();
      var isObject3 = util2.isObject;
      var es52 = require_es5();
      var Es6Map;
      if (typeof Map === "function")
        Es6Map = Map;
      var mapToEntries = function() {
        var index = 0;
        var size = 0;
        function extractEntry(value, key) {
          this[index] = value;
          this[index + size] = key;
          index++;
        }
        return function mapToEntries2(map) {
          size = map.size;
          index = 0;
          var ret2 = new Array(map.size * 2);
          map.forEach(extractEntry, ret2);
          return ret2;
        };
      }();
      var entriesToMap = function(entries) {
        var ret2 = new Es6Map();
        var length = entries.length / 2 | 0;
        for (var i = 0; i < length; ++i) {
          var key = entries[length + i];
          var value = entries[i];
          ret2.set(key, value);
        }
        return ret2;
      };
      function PropertiesPromiseArray(obj2) {
        var isMap = false;
        var entries;
        if (Es6Map !== void 0 && obj2 instanceof Es6Map) {
          entries = mapToEntries(obj2);
          isMap = true;
        } else {
          var keys = es52.keys(obj2);
          var len = keys.length;
          entries = new Array(len * 2);
          for (var i = 0; i < len; ++i) {
            var key = keys[i];
            entries[i] = obj2[key];
            entries[i + len] = key;
          }
        }
        this.constructor$(entries);
        this._isMap = isMap;
        this._init$(void 0, isMap ? -6 : -3);
      }
      util2.inherits(PropertiesPromiseArray, PromiseArray);
      PropertiesPromiseArray.prototype._init = function() {
      };
      PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          var val;
          if (this._isMap) {
            val = entriesToMap(this._values);
          } else {
            val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
              val[this._values[i + keyOffset]] = this._values[i];
            }
          }
          this._resolve(val);
          return true;
        }
        return false;
      };
      PropertiesPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      PropertiesPromiseArray.prototype.getActualLength = function(len) {
        return len >> 1;
      };
      function props(promises) {
        var ret2;
        var castValue = tryConvertToPromise(promises);
        if (!isObject3(castValue)) {
          return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
        } else if (castValue instanceof Promise2) {
          ret2 = castValue._then(
            Promise2.props,
            void 0,
            void 0,
            void 0,
            void 0
          );
        } else {
          ret2 = new PropertiesPromiseArray(castValue).promise();
        }
        if (castValue instanceof Promise2) {
          ret2._propagateFrom(castValue, 2);
        }
        return ret2;
      }
      Promise2.prototype.props = function() {
        return props(this);
      };
      Promise2.props = function(promises) {
        return props(promises);
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/race.js
var require_race = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/race.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
      var util2 = require_util();
      var raceLater = function(promise) {
        return promise.then(function(array) {
          return race(array, promise);
        });
      };
      function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);
        if (maybePromise instanceof Promise2) {
          return raceLater(maybePromise);
        } else {
          promises = util2.asArray(promises);
          if (promises === null)
            return apiRejection("expecting an array or an iterable object but got " + util2.classString(promises));
        }
        var ret2 = new Promise2(INTERNAL);
        if (parent !== void 0) {
          ret2._propagateFrom(parent, 3);
        }
        var fulfill = ret2._fulfill;
        var reject = ret2._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
          var val = promises[i];
          if (val === void 0 && !(i in promises)) {
            continue;
          }
          Promise2.cast(val)._then(fulfill, reject, void 0, ret2, null);
        }
        return ret2;
      }
      Promise2.race = function(promises) {
        return race(promises, void 0);
      };
      Promise2.prototype.race = function() {
        return race(this, void 0);
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/reduce.js
var require_reduce = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/reduce.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
      var getDomain = Promise2._getDomain;
      var util2 = require_util();
      var tryCatch2 = util2.tryCatch;
      function ReductionPromiseArray(promises, fn, initialValue, _each) {
        this.constructor$(promises);
        var domain = getDomain();
        this._fn = domain === null ? fn : util2.domainBind(domain, fn);
        if (initialValue !== void 0) {
          initialValue = Promise2.resolve(initialValue);
          initialValue._attachCancellationCallback(this);
        }
        this._initialValue = initialValue;
        this._currentCancellable = null;
        if (_each === INTERNAL) {
          this._eachValues = Array(this._length);
        } else if (_each === 0) {
          this._eachValues = null;
        } else {
          this._eachValues = void 0;
        }
        this._promise._captureStackTrace();
        this._init$(void 0, -5);
      }
      util2.inherits(ReductionPromiseArray, PromiseArray);
      ReductionPromiseArray.prototype._gotAccum = function(accum) {
        if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
          this._eachValues.push(accum);
        }
      };
      ReductionPromiseArray.prototype._eachComplete = function(value) {
        if (this._eachValues !== null) {
          this._eachValues.push(value);
        }
        return this._eachValues;
      };
      ReductionPromiseArray.prototype._init = function() {
      };
      ReductionPromiseArray.prototype._resolveEmptyArray = function() {
        this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
      };
      ReductionPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      ReductionPromiseArray.prototype._resolve = function(value) {
        this._promise._resolveCallback(value);
        this._values = null;
      };
      ReductionPromiseArray.prototype._resultCancelled = function(sender) {
        if (sender === this._initialValue)
          return this._cancel();
        if (this._isResolved())
          return;
        this._resultCancelled$();
        if (this._currentCancellable instanceof Promise2) {
          this._currentCancellable.cancel();
        }
        if (this._initialValue instanceof Promise2) {
          this._initialValue.cancel();
        }
      };
      ReductionPromiseArray.prototype._iterate = function(values) {
        this._values = values;
        var value;
        var i;
        var length = values.length;
        if (this._initialValue !== void 0) {
          value = this._initialValue;
          i = 0;
        } else {
          value = Promise2.resolve(values[0]);
          i = 1;
        }
        this._currentCancellable = value;
        if (!value.isRejected()) {
          for (; i < length; ++i) {
            var ctx = {
              accum: null,
              value: values[i],
              index: i,
              length,
              array: this
            };
            value = value._then(gotAccum, void 0, void 0, ctx, void 0);
          }
        }
        if (this._eachValues !== void 0) {
          value = value._then(this._eachComplete, void 0, void 0, this, void 0);
        }
        value._then(completed, completed, void 0, value, this);
      };
      Promise2.prototype.reduce = function(fn, initialValue) {
        return reduce(this, fn, initialValue, null);
      };
      Promise2.reduce = function(promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
      };
      function completed(valueOrReason, array) {
        if (this.isFulfilled()) {
          array._resolve(valueOrReason);
        } else {
          array._reject(valueOrReason);
        }
      }
      function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util2.classString(fn));
        }
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
      }
      function gotAccum(accum) {
        this.accum = accum;
        this.array._gotAccum(accum);
        var value = tryConvertToPromise(this.value, this.array._promise);
        if (value instanceof Promise2) {
          this.array._currentCancellable = value;
          return value._then(gotValue, void 0, void 0, this, void 0);
        } else {
          return gotValue.call(this, value);
        }
      }
      function gotValue(value) {
        var array = this.array;
        var promise = array._promise;
        var fn = tryCatch2(array._fn);
        promise._pushContext();
        var ret2;
        if (array._eachValues !== void 0) {
          ret2 = fn.call(promise._boundValue(), value, this.index, this.length);
        } else {
          ret2 = fn.call(
            promise._boundValue(),
            this.accum,
            value,
            this.index,
            this.length
          );
        }
        if (ret2 instanceof Promise2) {
          array._currentCancellable = ret2;
        }
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(
          ret2,
          promiseCreated,
          array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
          promise
        );
        return ret2;
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/settle.js
var require_settle = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/settle.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, PromiseArray, debug) {
      var PromiseInspection = Promise2.PromiseInspection;
      var util2 = require_util();
      function SettledPromiseArray(values) {
        this.constructor$(values);
      }
      util2.inherits(SettledPromiseArray, PromiseArray);
      SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 33554432;
        ret2._settledValueField = value;
        return this._promiseResolved(index, ret2);
      };
      SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 16777216;
        ret2._settledValueField = reason;
        return this._promiseResolved(index, ret2);
      };
      Promise2.settle = function(promises) {
        debug.deprecated(".settle()", ".reflect()");
        return new SettledPromiseArray(promises).promise();
      };
      Promise2.prototype.settle = function() {
        return Promise2.settle(this);
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/some.js
var require_some = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/some.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, PromiseArray, apiRejection) {
      var util2 = require_util();
      var RangeError2 = require_errors().RangeError;
      var AggregateError = require_errors().AggregateError;
      var isArray2 = util2.isArray;
      var CANCELLATION = {};
      function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
      }
      util2.inherits(SomePromiseArray, PromiseArray);
      SomePromiseArray.prototype._init = function() {
        if (!this._initialized) {
          return;
        }
        if (this._howMany === 0) {
          this._resolve([]);
          return;
        }
        this._init$(void 0, -5);
        var isArrayResolved = isArray2(this._values);
        if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
          this._reject(this._getRangeError(this.length()));
        }
      };
      SomePromiseArray.prototype.init = function() {
        this._initialized = true;
        this._init();
      };
      SomePromiseArray.prototype.setUnwrap = function() {
        this._unwrap = true;
      };
      SomePromiseArray.prototype.howMany = function() {
        return this._howMany;
      };
      SomePromiseArray.prototype.setHowMany = function(count) {
        this._howMany = count;
      };
      SomePromiseArray.prototype._promiseFulfilled = function(value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
          this._values.length = this.howMany();
          if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
          } else {
            this._resolve(this._values);
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._promiseRejected = function(reason) {
        this._addRejected(reason);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._promiseCancelled = function() {
        if (this._values instanceof Promise2 || this._values == null) {
          return this._cancel();
        }
        this._addRejected(CANCELLATION);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._checkOutcome = function() {
        if (this.howMany() > this._canPossiblyFulfill()) {
          var e = new AggregateError();
          for (var i = this.length(); i < this._values.length; ++i) {
            if (this._values[i] !== CANCELLATION) {
              e.push(this._values[i]);
            }
          }
          if (e.length > 0) {
            this._reject(e);
          } else {
            this._cancel();
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._fulfilled = function() {
        return this._totalResolved;
      };
      SomePromiseArray.prototype._rejected = function() {
        return this._values.length - this.length();
      };
      SomePromiseArray.prototype._addRejected = function(reason) {
        this._values.push(reason);
      };
      SomePromiseArray.prototype._addFulfilled = function(value) {
        this._values[this._totalResolved++] = value;
      };
      SomePromiseArray.prototype._canPossiblyFulfill = function() {
        return this.length() - this._rejected();
      };
      SomePromiseArray.prototype._getRangeError = function(count) {
        var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
        return new RangeError2(message);
      };
      SomePromiseArray.prototype._resolveEmptyArray = function() {
        this._reject(this._getRangeError(0));
      };
      function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
          return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
        }
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(howMany);
        ret2.init();
        return promise;
      }
      Promise2.some = function(promises, howMany) {
        return some(promises, howMany);
      };
      Promise2.prototype.some = function(howMany) {
        return some(this, howMany);
      };
      Promise2._SomePromiseArray = SomePromiseArray;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/filter.js
var require_filter = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/filter.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseMap = Promise2.map;
      Promise2.prototype.filter = function(fn, options) {
        return PromiseMap(this, fn, options, INTERNAL);
      };
      Promise2.filter = function(promises, fn, options) {
        return PromiseMap(promises, fn, options, INTERNAL);
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/each.js
var require_each = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/each.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2, INTERNAL) {
      var PromiseReduce = Promise2.reduce;
      var PromiseAll = Promise2.all;
      function promiseAllThis() {
        return PromiseAll(this);
      }
      function PromiseMapSeries(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
      }
      Promise2.prototype.each = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
      };
      Promise2.prototype.mapSeries = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, INTERNAL);
      };
      Promise2.each = function(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
      };
      Promise2.mapSeries = PromiseMapSeries;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/any.js
var require_any = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/any.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(Promise2) {
      var SomePromiseArray = Promise2._SomePromiseArray;
      function any(promises) {
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(1);
        ret2.setUnwrap();
        ret2.init();
        return promise;
      }
      Promise2.any = function(promises) {
        return any(promises);
      };
      Promise2.prototype.any = function() {
        return any(this);
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/promise.js
var require_promise = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/promise.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function() {
      var makeSelfResolutionError = function() {
        return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
      };
      var reflectHandler = function() {
        return new Promise2.PromiseInspection(this._target());
      };
      var apiRejection = function(msg) {
        return Promise2.reject(new TypeError2(msg));
      };
      function Proxyable() {
      }
      var UNDEFINED_BINDING = {};
      var util2 = require_util();
      var getDomain;
      if (util2.isNode) {
        getDomain = function() {
          var ret2 = process.domain;
          if (ret2 === void 0)
            ret2 = null;
          return ret2;
        };
      } else {
        getDomain = function() {
          return null;
        };
      }
      util2.notEnumerableProp(Promise2, "_getDomain", getDomain);
      var es52 = require_es5();
      var Async = require_async();
      var async = new Async();
      es52.defineProperty(Promise2, "_async", { value: async });
      var errors = require_errors();
      var TypeError2 = Promise2.TypeError = errors.TypeError;
      Promise2.RangeError = errors.RangeError;
      var CancellationError = Promise2.CancellationError = errors.CancellationError;
      Promise2.TimeoutError = errors.TimeoutError;
      Promise2.OperationalError = errors.OperationalError;
      Promise2.RejectionError = errors.OperationalError;
      Promise2.AggregateError = errors.AggregateError;
      var INTERNAL = function() {
      };
      var APPLY = {};
      var NEXT_FILTER = {};
      var tryConvertToPromise = require_thenables()(Promise2, INTERNAL);
      var PromiseArray = require_promise_array()(
        Promise2,
        INTERNAL,
        tryConvertToPromise,
        apiRejection,
        Proxyable
      );
      var Context = require_context()(Promise2);
      var createContext = Context.create;
      var debug = require_debuggability()(Promise2, Context);
      var CapturedTrace = debug.CapturedTrace;
      var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise, NEXT_FILTER);
      var catchFilter = require_catch_filter()(NEXT_FILTER);
      var nodebackForPromise = require_nodeback();
      var errorObj2 = util2.errorObj;
      var tryCatch2 = util2.tryCatch;
      function check(self2, executor) {
        if (self2 == null || self2.constructor !== Promise2) {
          throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (typeof executor !== "function") {
          throw new TypeError2("expecting a function but got " + util2.classString(executor));
        }
      }
      function Promise2(executor) {
        if (executor !== INTERNAL) {
          check(this, executor);
        }
        this._bitField = 0;
        this._fulfillmentHandler0 = void 0;
        this._rejectionHandler0 = void 0;
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._resolveFromExecutor(executor);
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
      }
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
        var len = arguments.length;
        if (len > 1) {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util2.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return apiRejection("Catch statement predicate: expecting an object but got " + util2.classString(item));
            }
          }
          catchInstances.length = j;
          fn = arguments[i];
          return this.then(void 0, catchFilter(catchInstances, fn, this));
        }
        return this.then(void 0, fn);
      };
      Promise2.prototype.reflect = function() {
        return this._then(
          reflectHandler,
          reflectHandler,
          void 0,
          this,
          void 0
        );
      };
      Promise2.prototype.then = function(didFulfill, didReject) {
        if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
          var msg = ".then() only accepts functions but was passed: " + util2.classString(didFulfill);
          if (arguments.length > 1) {
            msg += ", " + util2.classString(didReject);
          }
          this._warn(msg);
        }
        return this._then(didFulfill, didReject, void 0, void 0, void 0);
      };
      Promise2.prototype.done = function(didFulfill, didReject) {
        var promise = this._then(didFulfill, didReject, void 0, void 0, void 0);
        promise._setIsFinal();
      };
      Promise2.prototype.spread = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util2.classString(fn));
        }
        return this.all()._then(fn, void 0, void 0, APPLY, void 0);
      };
      Promise2.prototype.toJSON = function() {
        var ret2 = {
          isFulfilled: false,
          isRejected: false,
          fulfillmentValue: void 0,
          rejectionReason: void 0
        };
        if (this.isFulfilled()) {
          ret2.fulfillmentValue = this.value();
          ret2.isFulfilled = true;
        } else if (this.isRejected()) {
          ret2.rejectionReason = this.reason();
          ret2.isRejected = true;
        }
        return ret2;
      };
      Promise2.prototype.all = function() {
        if (arguments.length > 0) {
          this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
      };
      Promise2.prototype.error = function(fn) {
        return this.caught(util2.originatesFromRejection, fn);
      };
      Promise2.getNewLibraryCopy = module2.exports;
      Promise2.is = function(val) {
        return val instanceof Promise2;
      };
      Promise2.fromNode = Promise2.fromCallback = function(fn) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result = tryCatch2(fn)(nodebackForPromise(ret2, multiArgs));
        if (result === errorObj2) {
          ret2._rejectCallback(result.e, true);
        }
        if (!ret2._isFateSealed())
          ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.all = function(promises) {
        return new PromiseArray(promises).promise();
      };
      Promise2.cast = function(obj2) {
        var ret2 = tryConvertToPromise(obj2);
        if (!(ret2 instanceof Promise2)) {
          ret2 = new Promise2(INTERNAL);
          ret2._captureStackTrace();
          ret2._setFulfilled();
          ret2._rejectionHandler0 = obj2;
        }
        return ret2;
      };
      Promise2.resolve = Promise2.fulfilled = Promise2.cast;
      Promise2.reject = Promise2.rejected = function(reason) {
        var ret2 = new Promise2(INTERNAL);
        ret2._captureStackTrace();
        ret2._rejectCallback(reason, true);
        return ret2;
      };
      Promise2.setScheduler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util2.classString(fn));
        }
        return async.setScheduler(fn);
      };
      Promise2.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
        var haveInternalData = internalData !== void 0;
        var promise = haveInternalData ? internalData : new Promise2(INTERNAL);
        var target = this._target();
        var bitField = target._bitField;
        if (!haveInternalData) {
          promise._propagateFrom(this, 3);
          promise._captureStackTrace();
          if (receiver === void 0 && (this._bitField & 2097152) !== 0) {
            if (!((bitField & 50397184) === 0)) {
              receiver = this._boundValue();
            } else {
              receiver = target === this ? void 0 : this._boundTo;
            }
          }
          this._fireEvent("promiseChained", this, promise);
        }
        var domain = getDomain();
        if (!((bitField & 50397184) === 0)) {
          var handler, value, settler = target._settlePromiseCtx;
          if ((bitField & 33554432) !== 0) {
            value = target._rejectionHandler0;
            handler = didFulfill;
          } else if ((bitField & 16777216) !== 0) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
          } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
          }
          async.invoke(settler, target, {
            handler: domain === null ? handler : typeof handler === "function" && util2.domainBind(domain, handler),
            promise,
            receiver,
            value
          });
        } else {
          target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
        }
        return promise;
      };
      Promise2.prototype._length = function() {
        return this._bitField & 65535;
      };
      Promise2.prototype._isFateSealed = function() {
        return (this._bitField & 117506048) !== 0;
      };
      Promise2.prototype._isFollowing = function() {
        return (this._bitField & 67108864) === 67108864;
      };
      Promise2.prototype._setLength = function(len) {
        this._bitField = this._bitField & -65536 | len & 65535;
      };
      Promise2.prototype._setFulfilled = function() {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
      };
      Promise2.prototype._setRejected = function() {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
      };
      Promise2.prototype._setFollowing = function() {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
      };
      Promise2.prototype._setIsFinal = function() {
        this._bitField = this._bitField | 4194304;
      };
      Promise2.prototype._isFinal = function() {
        return (this._bitField & 4194304) > 0;
      };
      Promise2.prototype._unsetCancelled = function() {
        this._bitField = this._bitField & ~65536;
      };
      Promise2.prototype._setCancelled = function() {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
      };
      Promise2.prototype._setWillBeCancelled = function() {
        this._bitField = this._bitField | 8388608;
      };
      Promise2.prototype._setAsyncGuaranteed = function() {
        if (async.hasCustomScheduler())
          return;
        this._bitField = this._bitField | 134217728;
      };
      Promise2.prototype._receiverAt = function(index) {
        var ret2 = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
        if (ret2 === UNDEFINED_BINDING) {
          return void 0;
        } else if (ret2 === void 0 && this._isBound()) {
          return this._boundValue();
        }
        return ret2;
      };
      Promise2.prototype._promiseAt = function(index) {
        return this[index * 4 - 4 + 2];
      };
      Promise2.prototype._fulfillmentHandlerAt = function(index) {
        return this[index * 4 - 4 + 0];
      };
      Promise2.prototype._rejectionHandlerAt = function(index) {
        return this[index * 4 - 4 + 1];
      };
      Promise2.prototype._boundValue = function() {
      };
      Promise2.prototype._migrateCallback0 = function(follower) {
        var bitField = follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject = follower._rejectionHandler0;
        var promise = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === void 0)
          receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
      };
      Promise2.prototype._migrateCallbackAt = function(follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (receiver === void 0)
          receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
      };
      Promise2.prototype._addCallbacks = function(fulfill, reject, promise, receiver, domain) {
        var index = this._length();
        if (index >= 65535 - 4) {
          index = 0;
          this._setLength(0);
        }
        if (index === 0) {
          this._promise0 = promise;
          this._receiver0 = receiver;
          if (typeof fulfill === "function") {
            this._fulfillmentHandler0 = domain === null ? fulfill : util2.domainBind(domain, fulfill);
          }
          if (typeof reject === "function") {
            this._rejectionHandler0 = domain === null ? reject : util2.domainBind(domain, reject);
          }
        } else {
          var base = index * 4 - 4;
          this[base + 2] = promise;
          this[base + 3] = receiver;
          if (typeof fulfill === "function") {
            this[base + 0] = domain === null ? fulfill : util2.domainBind(domain, fulfill);
          }
          if (typeof reject === "function") {
            this[base + 1] = domain === null ? reject : util2.domainBind(domain, reject);
          }
        }
        this._setLength(index + 1);
        return index;
      };
      Promise2.prototype._proxy = function(proxyable, arg) {
        this._addCallbacks(void 0, void 0, arg, proxyable, null);
      };
      Promise2.prototype._resolveCallback = function(value, shouldBind) {
        if ((this._bitField & 117506048) !== 0)
          return;
        if (value === this)
          return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise2))
          return this._fulfill(value);
        if (shouldBind)
          this._propagateFrom(maybePromise, 2);
        var promise = maybePromise._target();
        if (promise === this) {
          this._reject(makeSelfResolutionError());
          return;
        }
        var bitField = promise._bitField;
        if ((bitField & 50397184) === 0) {
          var len = this._length();
          if (len > 0)
            promise._migrateCallback0(this);
          for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
          }
          this._setFollowing();
          this._setLength(0);
          this._setFollowee(promise);
        } else if ((bitField & 33554432) !== 0) {
          this._fulfill(promise._value());
        } else if ((bitField & 16777216) !== 0) {
          this._reject(promise._reason());
        } else {
          var reason = new CancellationError("late cancellation observer");
          promise._attachExtraTrace(reason);
          this._reject(reason);
        }
      };
      Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util2.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
          var message = "a promise was rejected with a non-error: " + util2.classString(reason);
          this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
      };
      Promise2.prototype._resolveFromExecutor = function(executor) {
        if (executor === INTERNAL)
          return;
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function(value) {
          promise._resolveCallback(value);
        }, function(reason) {
          promise._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();
        if (r !== void 0) {
          promise._rejectCallback(r, true);
        }
      };
      Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
        var bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        promise._pushContext();
        var x;
        if (receiver === APPLY) {
          if (!value || typeof value.length !== "number") {
            x = errorObj2;
            x.e = new TypeError2("cannot .spread() a non-array: " + util2.classString(value));
          } else {
            x = tryCatch2(handler).apply(this._boundValue(), value);
          }
        } else {
          x = tryCatch2(handler).call(receiver, value);
        }
        var promiseCreated = promise._popContext();
        bitField = promise._bitField;
        if ((bitField & 65536) !== 0)
          return;
        if (x === NEXT_FILTER) {
          promise._reject(value);
        } else if (x === errorObj2) {
          promise._rejectCallback(x.e, false);
        } else {
          debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
          promise._resolveCallback(x);
        }
      };
      Promise2.prototype._target = function() {
        var ret2 = this;
        while (ret2._isFollowing())
          ret2 = ret2._followee();
        return ret2;
      };
      Promise2.prototype._followee = function() {
        return this._rejectionHandler0;
      };
      Promise2.prototype._setFollowee = function(promise) {
        this._rejectionHandler0 = promise;
      };
      Promise2.prototype._settlePromise = function(promise, handler, receiver, value) {
        var isPromise = promise instanceof Promise2;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
          if (isPromise)
            promise._invokeInternalOnCancel();
          if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch2(handler).call(receiver, value) === errorObj2) {
              promise._reject(errorObj2.e);
            }
          } else if (handler === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
          } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
          } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
          } else {
            receiver.cancel();
          }
        } else if (typeof handler === "function") {
          if (!isPromise) {
            handler.call(receiver, value, promise);
          } else {
            if (asyncGuaranteed)
              promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise);
          }
        } else if (receiver instanceof Proxyable) {
          if (!receiver._isResolved()) {
            if ((bitField & 33554432) !== 0) {
              receiver._promiseFulfilled(value, promise);
            } else {
              receiver._promiseRejected(value, promise);
            }
          }
        } else if (isPromise) {
          if (asyncGuaranteed)
            promise._setAsyncGuaranteed();
          if ((bitField & 33554432) !== 0) {
            promise._fulfill(value);
          } else {
            promise._reject(value);
          }
        }
      };
      Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
        var handler = ctx.handler;
        var promise = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler === "function") {
          if (!(promise instanceof Promise2)) {
            handler.call(receiver, value, promise);
          } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
          }
        } else if (promise instanceof Promise2) {
          promise._reject(value);
        }
      };
      Promise2.prototype._settlePromiseCtx = function(ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
      };
      Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
        var promise = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._settlePromise(promise, handler, receiver, value);
      };
      Promise2.prototype._clearCallbackDataAtIndex = function(index) {
        var base = index * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
      };
      Promise2.prototype._fulfill = function(value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        if (value === this) {
          var err = makeSelfResolutionError();
          this._attachExtraTrace(err);
          return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;
        if ((bitField & 65535) > 0) {
          if ((bitField & 134217728) !== 0) {
            this._settlePromises();
          } else {
            async.settlePromises(this);
          }
        }
      };
      Promise2.prototype._reject = function(reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16)
          return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;
        if (this._isFinal()) {
          return async.fatalError(reason, util2.isNode);
        }
        if ((bitField & 65535) > 0) {
          async.settlePromises(this);
        } else {
          this._ensurePossibleRejectionHandled();
        }
      };
      Promise2.prototype._fulfillPromises = function(len, value) {
        for (var i = 1; i < len; i++) {
          var handler = this._fulfillmentHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler, receiver, value);
        }
      };
      Promise2.prototype._rejectPromises = function(len, reason) {
        for (var i = 1; i < len; i++) {
          var handler = this._rejectionHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler, receiver, reason);
        }
      };
      Promise2.prototype._settlePromises = function() {
        var bitField = this._bitField;
        var len = bitField & 65535;
        if (len > 0) {
          if ((bitField & 16842752) !== 0) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
          } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
          }
          this._setLength(0);
        }
        this._clearCancellationData();
      };
      Promise2.prototype._settledValue = function() {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
          return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
          return this._fulfillmentHandler0;
        }
      };
      function deferResolve(v) {
        this.promise._resolveCallback(v);
      }
      function deferReject(v) {
        this.promise._rejectCallback(v, false);
      }
      Promise2.defer = Promise2.pending = function() {
        debug.deprecated("Promise.defer", "new Promise");
        var promise = new Promise2(INTERNAL);
        return {
          promise,
          resolve: deferResolve,
          reject: deferReject
        };
      };
      util2.notEnumerableProp(
        Promise2,
        "_makeSelfResolutionError",
        makeSelfResolutionError
      );
      require_method()(
        Promise2,
        INTERNAL,
        tryConvertToPromise,
        apiRejection,
        debug
      );
      require_bind()(Promise2, INTERNAL, tryConvertToPromise, debug);
      require_cancel()(Promise2, PromiseArray, apiRejection, debug);
      require_direct_resolve()(Promise2);
      require_synchronous_inspection()(Promise2);
      require_join()(
        Promise2,
        PromiseArray,
        tryConvertToPromise,
        INTERNAL,
        async,
        getDomain
      );
      Promise2.Promise = Promise2;
      Promise2.version = "3.5.1";
      require_map()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      require_call_get()(Promise2);
      require_using()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
      require_timers()(Promise2, INTERNAL, debug);
      require_generators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
      require_nodeify()(Promise2);
      require_promisify()(Promise2, INTERNAL);
      require_props()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
      require_race()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
      require_reduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      require_settle()(Promise2, PromiseArray, debug);
      require_some()(Promise2, PromiseArray, apiRejection);
      require_filter()(Promise2, INTERNAL);
      require_each()(Promise2, INTERNAL);
      require_any()(Promise2);
      util2.toFastProperties(Promise2);
      util2.toFastProperties(Promise2.prototype);
      function fillTypes(value) {
        var p = new Promise2(INTERNAL);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
      }
      fillTypes({ a: 1 });
      fillTypes({ b: 2 });
      fillTypes({ c: 3 });
      fillTypes(1);
      fillTypes(function() {
      });
      fillTypes(void 0);
      fillTypes(false);
      fillTypes(new Promise2(INTERNAL));
      debug.setBounds(Async.firstLineError, util2.lastLineError);
      return Promise2;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/bluebird.js
var require_bluebird = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+bluebird@3.5.1/node_modules/bluebird/js/release/bluebird.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var old;
    if (typeof Promise !== "undefined")
      old = Promise;
    function noConflict() {
      try {
        if (Promise === bluebird)
          Promise = old;
      } catch (e) {
      }
      return bluebird;
    }
    var bluebird = require_promise()();
    bluebird.noConflict = noConflict;
    module2.exports = bluebird;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/mquery.js
var require_mquery = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mquery@3.2.5/node_modules/mquery/lib/mquery.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var slice = require_sliced();
    var assert = require("assert");
    var util2 = require("util");
    var utils = require_utils();
    var debug = require_src()("mquery");
    function Query(criteria, options) {
      if (!(this instanceof Query))
        return new Query(criteria, options);
      var proto = this.constructor.prototype;
      this.op = proto.op || void 0;
      this.options = Object.assign({}, proto.options);
      this._conditions = proto._conditions ? utils.clone(proto._conditions) : {};
      this._fields = proto._fields ? utils.clone(proto._fields) : void 0;
      this._update = proto._update ? utils.clone(proto._update) : void 0;
      this._path = proto._path || void 0;
      this._distinct = proto._distinct || void 0;
      this._collection = proto._collection || void 0;
      this._traceFunction = proto._traceFunction || void 0;
      if (options) {
        this.setOptions(options);
      }
      if (criteria) {
        if (criteria.find && criteria.remove && criteria.update) {
          this.collection(criteria);
        } else {
          this.find(criteria);
        }
      }
    }
    var $withinCmd = "$geoWithin";
    Object.defineProperty(Query, "use$geoWithin", {
      get: function() {
        return $withinCmd == "$geoWithin";
      },
      set: function(v) {
        if (true === v) {
          $withinCmd = "$geoWithin";
        } else {
          $withinCmd = "$within";
        }
      }
    });
    Query.prototype.toConstructor = function toConstructor() {
      function CustomQuery(criteria, options) {
        if (!(this instanceof CustomQuery))
          return new CustomQuery(criteria, options);
        Query.call(this, criteria, options);
      }
      utils.inherits(CustomQuery, Query);
      var p = CustomQuery.prototype;
      p.options = {};
      p.setOptions(this.options);
      p.op = this.op;
      p._conditions = utils.clone(this._conditions);
      p._fields = utils.clone(this._fields);
      p._update = utils.clone(this._update);
      p._path = this._path;
      p._distinct = this._distinct;
      p._collection = this._collection;
      p._traceFunction = this._traceFunction;
      return CustomQuery;
    };
    Query.prototype.setOptions = function(options) {
      if (!(options && utils.isObject(options)))
        return this;
      var methods = utils.keys(options), method;
      for (var i = 0; i < methods.length; ++i) {
        method = methods[i];
        if ("function" == typeof this[method]) {
          var args = utils.isArray(options[method]) ? options[method] : [options[method]];
          this[method].apply(this, args);
        } else {
          this.options[method] = options[method];
        }
      }
      return this;
    };
    Query.prototype.collection = function collection(coll) {
      this._collection = new Query.Collection(coll);
      return this;
    };
    Query.prototype.collation = function(value) {
      this.options.collation = value;
      return this;
    };
    Query.prototype.$where = function(js) {
      this._conditions.$where = js;
      return this;
    };
    Query.prototype.where = function() {
      if (!arguments.length)
        return this;
      if (!this.op)
        this.op = "find";
      var type = typeof arguments[0];
      if ("string" == type) {
        this._path = arguments[0];
        if (2 === arguments.length) {
          this._conditions[this._path] = arguments[1];
        }
        return this;
      }
      if ("object" == type && !Array.isArray(arguments[0])) {
        return this.merge(arguments[0]);
      }
      throw new TypeError("path must be a string or object");
    };
    Query.prototype.equals = function equals2(val) {
      this._ensurePath("equals");
      var path3 = this._path;
      this._conditions[path3] = val;
      return this;
    };
    Query.prototype.eq = function eq(val) {
      this._ensurePath("eq");
      var path3 = this._path;
      this._conditions[path3] = val;
      return this;
    };
    Query.prototype.or = function or(array) {
      var or2 = this._conditions.$or || (this._conditions.$or = []);
      if (!utils.isArray(array))
        array = [array];
      or2.push.apply(or2, array);
      return this;
    };
    Query.prototype.nor = function nor(array) {
      var nor2 = this._conditions.$nor || (this._conditions.$nor = []);
      if (!utils.isArray(array))
        array = [array];
      nor2.push.apply(nor2, array);
      return this;
    };
    Query.prototype.and = function and(array) {
      var and2 = this._conditions.$and || (this._conditions.$and = []);
      if (!Array.isArray(array))
        array = [array];
      and2.push.apply(and2, array);
      return this;
    };
    "gt gte lt lte ne in nin all regex size maxDistance minDistance".split(" ").forEach(function($conditional) {
      Query.prototype[$conditional] = function() {
        var path3, val;
        if (1 === arguments.length) {
          this._ensurePath($conditional);
          val = arguments[0];
          path3 = this._path;
        } else {
          val = arguments[1];
          path3 = arguments[0];
        }
        var conds = this._conditions[path3] === null || typeof this._conditions[path3] === "object" ? this._conditions[path3] : this._conditions[path3] = {};
        conds["$" + $conditional] = val;
        return this;
      };
    });
    Query.prototype.mod = function() {
      var val, path3;
      if (1 === arguments.length) {
        this._ensurePath("mod");
        val = arguments[0];
        path3 = this._path;
      } else if (2 === arguments.length && !utils.isArray(arguments[1])) {
        this._ensurePath("mod");
        val = slice(arguments);
        path3 = this._path;
      } else if (3 === arguments.length) {
        val = slice(arguments, 1);
        path3 = arguments[0];
      } else {
        val = arguments[1];
        path3 = arguments[0];
      }
      var conds = this._conditions[path3] || (this._conditions[path3] = {});
      conds.$mod = val;
      return this;
    };
    Query.prototype.exists = function() {
      var path3, val;
      if (0 === arguments.length) {
        this._ensurePath("exists");
        path3 = this._path;
        val = true;
      } else if (1 === arguments.length) {
        if ("boolean" === typeof arguments[0]) {
          this._ensurePath("exists");
          path3 = this._path;
          val = arguments[0];
        } else {
          path3 = arguments[0];
          val = true;
        }
      } else if (2 === arguments.length) {
        path3 = arguments[0];
        val = arguments[1];
      }
      var conds = this._conditions[path3] || (this._conditions[path3] = {});
      conds.$exists = val;
      return this;
    };
    Query.prototype.elemMatch = function() {
      if (null == arguments[0])
        throw new TypeError("Invalid argument");
      var fn, path3, criteria;
      if ("function" === typeof arguments[0]) {
        this._ensurePath("elemMatch");
        path3 = this._path;
        fn = arguments[0];
      } else if (utils.isObject(arguments[0])) {
        this._ensurePath("elemMatch");
        path3 = this._path;
        criteria = arguments[0];
      } else if ("function" === typeof arguments[1]) {
        path3 = arguments[0];
        fn = arguments[1];
      } else if (arguments[1] && utils.isObject(arguments[1])) {
        path3 = arguments[0];
        criteria = arguments[1];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (fn) {
        criteria = new Query();
        fn(criteria);
        criteria = criteria._conditions;
      }
      var conds = this._conditions[path3] || (this._conditions[path3] = {});
      conds.$elemMatch = criteria;
      return this;
    };
    Query.prototype.within = function within() {
      this._ensurePath("within");
      this._geoComparison = $withinCmd;
      if (0 === arguments.length) {
        return this;
      }
      if (2 === arguments.length) {
        return this.box.apply(this, arguments);
      } else if (2 < arguments.length) {
        return this.polygon.apply(this, arguments);
      }
      var area = arguments[0];
      if (!area)
        throw new TypeError("Invalid argument");
      if (area.center)
        return this.circle(area);
      if (area.box)
        return this.box.apply(this, area.box);
      if (area.polygon)
        return this.polygon.apply(this, area.polygon);
      if (area.type && area.coordinates)
        return this.geometry(area);
      throw new TypeError("Invalid argument");
    };
    Query.prototype.box = function() {
      var path3, box;
      if (3 === arguments.length) {
        path3 = arguments[0];
        box = [arguments[1], arguments[2]];
      } else if (2 === arguments.length) {
        this._ensurePath("box");
        path3 = this._path;
        box = [arguments[0], arguments[1]];
      } else {
        throw new TypeError("Invalid argument");
      }
      var conds = this._conditions[path3] || (this._conditions[path3] = {});
      conds[this._geoComparison || $withinCmd] = { "$box": box };
      return this;
    };
    Query.prototype.polygon = function() {
      var val, path3;
      if ("string" == typeof arguments[0]) {
        path3 = arguments[0];
        val = slice(arguments, 1);
      } else {
        this._ensurePath("polygon");
        path3 = this._path;
        val = slice(arguments);
      }
      var conds = this._conditions[path3] || (this._conditions[path3] = {});
      conds[this._geoComparison || $withinCmd] = { "$polygon": val };
      return this;
    };
    Query.prototype.circle = function() {
      var path3, val;
      if (1 === arguments.length) {
        this._ensurePath("circle");
        path3 = this._path;
        val = arguments[0];
      } else if (2 === arguments.length) {
        path3 = arguments[0];
        val = arguments[1];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (!("radius" in val && val.center))
        throw new Error("center and radius are required");
      var conds = this._conditions[path3] || (this._conditions[path3] = {});
      var type = val.spherical ? "$centerSphere" : "$center";
      var wKey = this._geoComparison || $withinCmd;
      conds[wKey] = {};
      conds[wKey][type] = [val.center, val.radius];
      if ("unique" in val)
        conds[wKey].$uniqueDocs = !!val.unique;
      return this;
    };
    Query.prototype.near = function near() {
      var path3, val;
      this._geoComparison = "$near";
      if (0 === arguments.length) {
        return this;
      } else if (1 === arguments.length) {
        this._ensurePath("near");
        path3 = this._path;
        val = arguments[0];
      } else if (2 === arguments.length) {
        path3 = arguments[0];
        val = arguments[1];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (!val.center) {
        throw new Error("center is required");
      }
      var conds = this._conditions[path3] || (this._conditions[path3] = {});
      var type = val.spherical ? "$nearSphere" : "$near";
      if (Array.isArray(val.center)) {
        conds[type] = val.center;
        var radius = "maxDistance" in val ? val.maxDistance : null;
        if (null != radius) {
          conds.$maxDistance = radius;
        }
        if (null != val.minDistance) {
          conds.$minDistance = val.minDistance;
        }
      } else {
        if (val.center.type != "Point" || !Array.isArray(val.center.coordinates)) {
          throw new Error(util2.format("Invalid GeoJSON specified for %s", type));
        }
        conds[type] = { $geometry: val.center };
        if ("maxDistance" in val) {
          conds[type]["$maxDistance"] = val.maxDistance;
        }
        if ("minDistance" in val) {
          conds[type]["$minDistance"] = val.minDistance;
        }
      }
      return this;
    };
    Query.prototype.intersects = function intersects() {
      this._ensurePath("intersects");
      this._geoComparison = "$geoIntersects";
      if (0 === arguments.length) {
        return this;
      }
      var area = arguments[0];
      if (null != area && area.type && area.coordinates)
        return this.geometry(area);
      throw new TypeError("Invalid argument");
    };
    Query.prototype.geometry = function geometry() {
      if (!("$within" == this._geoComparison || "$geoWithin" == this._geoComparison || "$near" == this._geoComparison || "$geoIntersects" == this._geoComparison)) {
        throw new Error("geometry() must come after `within()`, `intersects()`, or `near()");
      }
      var val, path3;
      if (1 === arguments.length) {
        this._ensurePath("geometry");
        path3 = this._path;
        val = arguments[0];
      } else {
        throw new TypeError("Invalid argument");
      }
      if (!(val.type && Array.isArray(val.coordinates))) {
        throw new TypeError("Invalid argument");
      }
      var conds = this._conditions[path3] || (this._conditions[path3] = {});
      conds[this._geoComparison] = { $geometry: val };
      return this;
    };
    Query.prototype.select = function select() {
      var arg = arguments[0];
      if (!arg)
        return this;
      if (arguments.length !== 1) {
        throw new Error("Invalid select: select only takes 1 argument");
      }
      this._validate("select");
      var fields = this._fields || (this._fields = {});
      var type = typeof arg;
      var i, len;
      if (("string" == type || utils.isArgumentsObject(arg)) && "number" == typeof arg.length || Array.isArray(arg)) {
        if ("string" == type)
          arg = arg.split(/\s+/);
        for (i = 0, len = arg.length; i < len; ++i) {
          var field = arg[i];
          if (!field)
            continue;
          var include = "-" == field[0] ? 0 : 1;
          if (include === 0)
            field = field.substring(1);
          fields[field] = include;
        }
        return this;
      }
      if (utils.isObject(arg)) {
        var keys = utils.keys(arg);
        for (i = 0; i < keys.length; ++i) {
          fields[keys[i]] = arg[keys[i]];
        }
        return this;
      }
      throw new TypeError("Invalid select() argument. Must be string or object.");
    };
    Query.prototype.slice = function() {
      if (0 === arguments.length)
        return this;
      this._validate("slice");
      var path3, val;
      if (1 === arguments.length) {
        var arg = arguments[0];
        if (typeof arg === "object" && !Array.isArray(arg)) {
          var keys = Object.keys(arg);
          var numKeys = keys.length;
          for (var i = 0; i < numKeys; ++i) {
            this.slice(keys[i], arg[keys[i]]);
          }
          return this;
        }
        this._ensurePath("slice");
        path3 = this._path;
        val = arguments[0];
      } else if (2 === arguments.length) {
        if ("number" === typeof arguments[0]) {
          this._ensurePath("slice");
          path3 = this._path;
          val = slice(arguments);
        } else {
          path3 = arguments[0];
          val = arguments[1];
        }
      } else if (3 === arguments.length) {
        path3 = arguments[0];
        val = slice(arguments, 1);
      }
      var myFields = this._fields || (this._fields = {});
      myFields[path3] = { "$slice": val };
      return this;
    };
    Query.prototype.sort = function(arg) {
      if (!arg)
        return this;
      var i, len, field;
      this._validate("sort");
      var type = typeof arg;
      if (Array.isArray(arg)) {
        len = arg.length;
        for (i = 0; i < arg.length; ++i) {
          if (!Array.isArray(arg[i])) {
            throw new Error("Invalid sort() argument, must be array of arrays");
          }
          _pushArr(this.options, arg[i][0], arg[i][1]);
        }
        return this;
      }
      if (1 === arguments.length && "string" == type) {
        arg = arg.split(/\s+/);
        len = arg.length;
        for (i = 0; i < len; ++i) {
          field = arg[i];
          if (!field)
            continue;
          var ascend = "-" == field[0] ? -1 : 1;
          if (ascend === -1)
            field = field.substring(1);
          push(this.options, field, ascend);
        }
        return this;
      }
      if (utils.isObject(arg)) {
        var keys = utils.keys(arg);
        for (i = 0; i < keys.length; ++i) {
          field = keys[i];
          push(this.options, field, arg[field]);
        }
        return this;
      }
      if (typeof Map !== "undefined" && arg instanceof Map) {
        _pushMap(this.options, arg);
        return this;
      }
      throw new TypeError("Invalid sort() argument. Must be a string, object, or array.");
    };
    var _validSortValue = {
      "1": 1,
      "-1": -1,
      "asc": 1,
      "ascending": 1,
      "desc": -1,
      "descending": -1
    };
    function push(opts, field, value) {
      if (Array.isArray(opts.sort)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object:\n- `.sort([['field', 1], ['test', -1]])`\n- `.sort({ field: 1, test: -1 })`");
      }
      var s;
      if (value && value.$meta) {
        s = opts.sort || (opts.sort = {});
        s[field] = { $meta: value.$meta };
        return;
      }
      s = opts.sort || (opts.sort = {});
      var val = String(value || 1).toLowerCase();
      val = _validSortValue[val];
      if (!val)
        throw new TypeError("Invalid sort value: { " + field + ": " + value + " }");
      s[field] = val;
    }
    function _pushArr(opts, field, value) {
      opts.sort = opts.sort || [];
      if (!Array.isArray(opts.sort)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object:\n- `.sort([['field', 1], ['test', -1]])`\n- `.sort({ field: 1, test: -1 })`");
      }
      var val = String(value || 1).toLowerCase();
      val = _validSortValue[val];
      if (!val)
        throw new TypeError("Invalid sort value: [ " + field + ", " + value + " ]");
      opts.sort.push([field, val]);
    }
    function _pushMap(opts, map) {
      opts.sort = opts.sort || /* @__PURE__ */ new Map();
      if (!(opts.sort instanceof Map)) {
        throw new TypeError("Can't mix sort syntaxes. Use either array or object or map consistently");
      }
      map.forEach(function(value, key) {
        var val = String(value || 1).toLowerCase();
        val = _validSortValue[val];
        if (!val)
          throw new TypeError("Invalid sort value: < " + key + ": " + value + " >");
        opts.sort.set(key, val);
      });
    }
    ["limit", "skip", "maxScan", "batchSize", "comment"].forEach(function(method) {
      Query.prototype[method] = function(v) {
        this._validate(method);
        this.options[method] = v;
        return this;
      };
    });
    Query.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {
      this._validate("maxTime");
      this.options.maxTimeMS = ms;
      return this;
    };
    Query.prototype.snapshot = function() {
      this._validate("snapshot");
      this.options.snapshot = arguments.length ? !!arguments[0] : true;
      return this;
    };
    Query.prototype.hint = function() {
      if (0 === arguments.length)
        return this;
      this._validate("hint");
      var arg = arguments[0];
      if (utils.isObject(arg)) {
        var hint = this.options.hint || (this.options.hint = {});
        for (var k in arg) {
          hint[k] = arg[k];
        }
        return this;
      }
      if (typeof arg === "string") {
        this.options.hint = arg;
        return this;
      }
      throw new TypeError("Invalid hint. " + arg);
    };
    Query.prototype.j = function j(val) {
      this.options.j = val;
      return this;
    };
    Query.prototype.slaveOk = function(v) {
      this.options.slaveOk = arguments.length ? !!v : true;
      return this;
    };
    Query.prototype.read = Query.prototype.setReadPreference = function(pref) {
      if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {
        console.error("Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.");
        Query.prototype.read.deprecationWarningIssued = true;
      }
      this.options.readPreference = utils.readPref(pref);
      return this;
    };
    Query.prototype.readConcern = Query.prototype.r = function(level) {
      this.options.readConcern = utils.readConcern(level);
      return this;
    };
    Query.prototype.tailable = function() {
      this._validate("tailable");
      this.options.tailable = arguments.length ? !!arguments[0] : true;
      return this;
    };
    Query.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {
      if ("object" === typeof concern) {
        if ("undefined" !== typeof concern.j)
          this.options.j = concern.j;
        if ("undefined" !== typeof concern.w)
          this.options.w = concern.w;
        if ("undefined" !== typeof concern.wtimeout)
          this.options.wtimeout = concern.wtimeout;
      } else {
        this.options.w = "m" === concern ? "majority" : concern;
      }
      return this;
    };
    Query.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {
      this.options.wtimeout = ms;
      return this;
    };
    Query.prototype.merge = function(source) {
      if (!source)
        return this;
      if (!Query.canMerge(source))
        throw new TypeError("Invalid argument. Expected instanceof mquery or plain object");
      if (source instanceof Query) {
        if (source._conditions) {
          utils.merge(this._conditions, source._conditions);
        }
        if (source._fields) {
          this._fields || (this._fields = {});
          utils.merge(this._fields, source._fields);
        }
        if (source.options) {
          this.options || (this.options = {});
          utils.merge(this.options, source.options);
        }
        if (source._update) {
          this._update || (this._update = {});
          utils.mergeClone(this._update, source._update);
        }
        if (source._distinct) {
          this._distinct = source._distinct;
        }
        return this;
      }
      utils.merge(this._conditions, source);
      return this;
    };
    Query.prototype.find = function(criteria, callback) {
      this.op = "find";
      if ("function" === typeof criteria) {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback)
        return this;
      var conds = this._conditions;
      var options = this._optionsForExec();
      if (this.$useProjection) {
        options.projection = this._fieldsForExec();
      } else {
        options.fields = this._fieldsForExec();
      }
      debug("find", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("find", callback, {
        conditions: conds,
        options
      });
      this._collection.find(conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.cursor = function cursor(criteria) {
      if (this.op) {
        if (this.op !== "find") {
          throw new TypeError(".cursor only support .find method");
        }
      } else {
        this.find(criteria);
      }
      var conds = this._conditions;
      var options = this._optionsForExec();
      if (this.$useProjection) {
        options.projection = this._fieldsForExec();
      } else {
        options.fields = this._fieldsForExec();
      }
      debug("findCursor", this._collection.collectionName, conds, options);
      return this._collection.findCursor(conds, options);
    };
    Query.prototype.findOne = function(criteria, callback) {
      this.op = "findOne";
      if ("function" === typeof criteria) {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback)
        return this;
      var conds = this._conditions;
      var options = this._optionsForExec();
      if (this.$useProjection) {
        options.projection = this._fieldsForExec();
      } else {
        options.fields = this._fieldsForExec();
      }
      debug("findOne", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("findOne", callback, {
        conditions: conds,
        options
      });
      this._collection.findOne(conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.count = function(criteria, callback) {
      this.op = "count";
      this._validate();
      if ("function" === typeof criteria) {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback)
        return this;
      var conds = this._conditions, options = this._optionsForExec();
      debug("count", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("count", callback, {
        conditions: conds,
        options
      });
      this._collection.count(conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.distinct = function(criteria, field, callback) {
      this.op = "distinct";
      this._validate();
      if (!callback) {
        switch (typeof field) {
          case "function":
            callback = field;
            if ("string" == typeof criteria) {
              field = criteria;
              criteria = void 0;
            }
            break;
          case "undefined":
          case "string":
            break;
          default:
            throw new TypeError("Invalid `field` argument. Must be string or function");
        }
        switch (typeof criteria) {
          case "function":
            callback = criteria;
            criteria = field = void 0;
            break;
          case "string":
            field = criteria;
            criteria = void 0;
            break;
        }
      }
      if ("string" == typeof field) {
        this._distinct = field;
      }
      if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (!callback) {
        return this;
      }
      if (!this._distinct) {
        throw new Error("No value for `distinct` has been declared");
      }
      var conds = this._conditions, options = this._optionsForExec();
      debug("distinct", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("distinct", callback, {
        conditions: conds,
        options
      });
      this._collection.distinct(this._distinct, conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.update = function update(criteria, doc, options, callback) {
      var force;
      switch (arguments.length) {
        case 3:
          if ("function" == typeof options) {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if ("function" == typeof doc) {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options = void 0;
              break;
          }
      }
      return _update(this, "update", criteria, doc, options, force, callback);
    };
    Query.prototype.updateMany = function updateMany(criteria, doc, options, callback) {
      var force;
      switch (arguments.length) {
        case 3:
          if ("function" == typeof options) {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if ("function" == typeof doc) {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options = void 0;
              break;
          }
      }
      return _update(this, "updateMany", criteria, doc, options, force, callback);
    };
    Query.prototype.updateOne = function updateOne(criteria, doc, options, callback) {
      var force;
      switch (arguments.length) {
        case 3:
          if ("function" == typeof options) {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if ("function" == typeof doc) {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options = void 0;
              break;
          }
      }
      return _update(this, "updateOne", criteria, doc, options, force, callback);
    };
    Query.prototype.replaceOne = function replaceOne(criteria, doc, options, callback) {
      var force;
      switch (arguments.length) {
        case 3:
          if ("function" == typeof options) {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if ("function" == typeof doc) {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          break;
        case 1:
          switch (typeof criteria) {
            case "function":
              callback = criteria;
              criteria = options = doc = void 0;
              break;
            case "boolean":
              force = criteria;
              criteria = void 0;
              break;
            default:
              doc = criteria;
              criteria = options = void 0;
              break;
          }
      }
      this.setOptions({ overwrite: true });
      return _update(this, "replaceOne", criteria, doc, options, force, callback);
    };
    function _update(query, op, criteria, doc, options, force, callback) {
      query.op = op;
      if (Query.canMerge(criteria)) {
        query.merge(criteria);
      }
      if (doc) {
        query._mergeUpdate(doc);
      }
      if (utils.isObject(options)) {
        query.setOptions(options);
      }
      if (!(force || callback)) {
        return query;
      }
      if (!query._update || !query.options.overwrite && 0 === utils.keys(query._update).length) {
        callback && utils.soon(callback.bind(null, null, 0));
        return query;
      }
      options = query._optionsForExec();
      if (!callback)
        options.safe = false;
      criteria = query._conditions;
      doc = query._updateForExec();
      debug("update", query._collection.collectionName, criteria, doc, options);
      callback = query._wrapCallback(op, callback, {
        conditions: criteria,
        doc,
        options
      });
      query._collection[op](criteria, doc, options, utils.tick(callback));
      return query;
    }
    Query.prototype.remove = function(criteria, callback) {
      this.op = "remove";
      var force;
      if ("function" === typeof criteria) {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      } else if (true === criteria) {
        force = criteria;
        criteria = void 0;
      }
      if (!(force || callback))
        return this;
      var options = this._optionsForExec();
      if (!callback)
        options.safe = false;
      var conds = this._conditions;
      debug("remove", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("remove", callback, {
        conditions: conds,
        options
      });
      this._collection.remove(conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.deleteOne = function(criteria, callback) {
      this.op = "deleteOne";
      var force;
      if ("function" === typeof criteria) {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      } else if (true === criteria) {
        force = criteria;
        criteria = void 0;
      }
      if (!(force || callback))
        return this;
      var options = this._optionsForExec();
      if (!callback)
        options.safe = false;
      delete options.justOne;
      var conds = this._conditions;
      debug("deleteOne", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("deleteOne", callback, {
        conditions: conds,
        options
      });
      this._collection.deleteOne(conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.deleteMany = function(criteria, callback) {
      this.op = "deleteMany";
      var force;
      if ("function" === typeof criteria) {
        callback = criteria;
        criteria = void 0;
      } else if (Query.canMerge(criteria)) {
        this.merge(criteria);
      } else if (true === criteria) {
        force = criteria;
        criteria = void 0;
      }
      if (!(force || callback))
        return this;
      var options = this._optionsForExec();
      if (!callback)
        options.safe = false;
      delete options.justOne;
      var conds = this._conditions;
      debug("deleteOne", this._collection.collectionName, conds, options);
      callback = this._wrapCallback("deleteOne", callback, {
        conditions: conds,
        options
      });
      this._collection.deleteMany(conds, options, utils.tick(callback));
      return this;
    };
    Query.prototype.findOneAndUpdate = function(criteria, doc, options, callback) {
      this.op = "findOneAndUpdate";
      this._validate();
      switch (arguments.length) {
        case 3:
          if ("function" == typeof options) {
            callback = options;
            options = {};
          }
          break;
        case 2:
          if ("function" == typeof doc) {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          options = void 0;
          break;
        case 1:
          if ("function" == typeof criteria) {
            callback = criteria;
            criteria = options = doc = void 0;
          } else {
            doc = criteria;
            criteria = options = void 0;
          }
      }
      if (Query.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (doc) {
        this._mergeUpdate(doc);
      }
      options && this.setOptions(options);
      if (!callback)
        return this;
      return this._findAndModify("update", callback);
    };
    Query.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options, callback) {
      this.op = "findOneAndRemove";
      this._validate();
      if ("function" == typeof options) {
        callback = options;
        options = void 0;
      } else if ("function" == typeof conditions) {
        callback = conditions;
        conditions = void 0;
      }
      if (Query.canMerge(conditions)) {
        this.merge(conditions);
      }
      options && this.setOptions(options);
      if (!callback)
        return this;
      return this._findAndModify("remove", callback);
    };
    Query.prototype._findAndModify = function(type, callback) {
      assert.equal("function", typeof callback);
      var options = this._optionsForExec();
      var fields;
      var doc;
      if ("remove" == type) {
        options.remove = true;
      } else {
        if (!("new" in options))
          options.new = true;
        if (!("upsert" in options))
          options.upsert = false;
        doc = this._updateForExec();
        if (!doc) {
          if (options.upsert) {
            doc = { $set: {} };
          } else {
            return this.findOne(callback);
          }
        }
      }
      fields = this._fieldsForExec();
      if (fields != null) {
        if (this.$useProjection) {
          options.projection = this._fieldsForExec();
        } else {
          options.fields = this._fieldsForExec();
        }
      }
      var conds = this._conditions;
      debug("findAndModify", this._collection.collectionName, conds, doc, options);
      callback = this._wrapCallback("findAndModify", callback, {
        conditions: conds,
        doc,
        options
      });
      this._collection.findAndModify(conds, doc, options, utils.tick(callback));
      return this;
    };
    Query.prototype._wrapCallback = function(method, callback, queryInfo) {
      var traceFunction = this._traceFunction || Query.traceFunction;
      if (traceFunction) {
        queryInfo.collectionName = this._collection.collectionName;
        var traceCallback = traceFunction && traceFunction.call(null, method, queryInfo, this);
        var startTime = (/* @__PURE__ */ new Date()).getTime();
        return function wrapperCallback(err, result) {
          if (traceCallback) {
            var millis = (/* @__PURE__ */ new Date()).getTime() - startTime;
            traceCallback.call(null, err, result, millis);
          }
          if (callback) {
            callback.apply(null, arguments);
          }
        };
      }
      return callback;
    };
    Query.prototype.setTraceFunction = function(traceFunction) {
      this._traceFunction = traceFunction;
      return this;
    };
    Query.prototype.exec = function exec(op, callback) {
      switch (typeof op) {
        case "function":
          callback = op;
          op = null;
          break;
        case "string":
          this.op = op;
          break;
      }
      assert.ok(this.op, "Missing query type: (find, update, etc)");
      if ("update" == this.op || "remove" == this.op) {
        callback || (callback = true);
      }
      var _this = this;
      if ("function" == typeof callback) {
        this[this.op](callback);
      } else {
        return new Query.Promise(function(success, error) {
          _this[_this.op](function(err, val) {
            if (err)
              error(err);
            else
              success(val);
            success = error = null;
          });
        });
      }
    };
    Query.prototype.thunk = function() {
      var _this = this;
      return function(cb) {
        _this.exec(cb);
      };
    };
    Query.prototype.then = function(resolve, reject) {
      var _this = this;
      var promise = new Query.Promise(function(success, error) {
        _this.exec(function(err, val) {
          if (err)
            error(err);
          else
            success(val);
          success = error = null;
        });
      });
      return promise.then(resolve, reject);
    };
    Query.prototype.stream = function(streamOptions) {
      if ("find" != this.op)
        throw new Error("stream() is only available for find");
      var conds = this._conditions;
      var options = this._optionsForExec();
      if (this.$useProjection) {
        options.projection = this._fieldsForExec();
      } else {
        options.fields = this._fieldsForExec();
      }
      debug("stream", this._collection.collectionName, conds, options, streamOptions);
      return this._collection.findStream(conds, options, streamOptions);
    };
    Query.prototype.selected = function selected() {
      return !!(this._fields && Object.keys(this._fields).length > 0);
    };
    Query.prototype.selectedInclusively = function selectedInclusively() {
      if (!this._fields)
        return false;
      var keys = Object.keys(this._fields);
      if (0 === keys.length)
        return false;
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (0 === this._fields[key])
          return false;
        if (this._fields[key] && typeof this._fields[key] === "object" && this._fields[key].$meta) {
          return false;
        }
      }
      return true;
    };
    Query.prototype.selectedExclusively = function selectedExclusively() {
      if (!this._fields)
        return false;
      var keys = Object.keys(this._fields);
      if (0 === keys.length)
        return false;
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (0 === this._fields[key])
          return true;
      }
      return false;
    };
    Query.prototype._mergeUpdate = function(doc) {
      if (!this._update)
        this._update = {};
      if (doc instanceof Query) {
        if (doc._update) {
          utils.mergeClone(this._update, doc._update);
        }
      } else {
        utils.mergeClone(this._update, doc);
      }
    };
    Query.prototype._optionsForExec = function() {
      var options = utils.clone(this.options);
      return options;
    };
    Query.prototype._fieldsForExec = function() {
      return utils.clone(this._fields);
    };
    Query.prototype._updateForExec = function() {
      var update = utils.clone(this._update), ops = utils.keys(update), i = ops.length, ret2 = {};
      while (i--) {
        var op = ops[i];
        if (this.options.overwrite) {
          ret2[op] = update[op];
          continue;
        }
        if ("$" !== op[0]) {
          if (!ret2.$set) {
            if (update.$set) {
              ret2.$set = update.$set;
            } else {
              ret2.$set = {};
            }
          }
          ret2.$set[op] = update[op];
          ops.splice(i, 1);
          if (!~ops.indexOf("$set"))
            ops.push("$set");
        } else if ("$set" === op) {
          if (!ret2.$set) {
            ret2[op] = update[op];
          }
        } else {
          ret2[op] = update[op];
        }
      }
      this._compiledUpdate = ret2;
      return ret2;
    };
    Query.prototype._ensurePath = function(method) {
      if (!this._path) {
        var msg = method + "() must be used after where() when called with these arguments";
        throw new Error(msg);
      }
    };
    Query.permissions = require_permissions();
    Query._isPermitted = function(a, b) {
      var denied = Query.permissions[b];
      if (!denied)
        return true;
      return true !== denied[a];
    };
    Query.prototype._validate = function(action) {
      var fail;
      var validator;
      if (void 0 === action) {
        validator = Query.permissions[this.op];
        if ("function" != typeof validator)
          return true;
        fail = validator(this);
      } else if (!Query._isPermitted(action, this.op)) {
        fail = action;
      }
      if (fail) {
        throw new Error(fail + " cannot be used with " + this.op);
      }
    };
    Query.canMerge = function(conds) {
      return conds instanceof Query || utils.isObject(conds);
    };
    Query.setGlobalTraceFunction = function(traceFunction) {
      Query.traceFunction = traceFunction;
    };
    Query.utils = utils;
    Query.env = require_env();
    Query.Collection = require_collection3();
    Query.BaseCollection = require_collection2();
    Query.Promise = require_bluebird();
    module2.exports = exports2 = Query;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/promise_provider.js
var require_promise_provider = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/promise_provider.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var assert = require("assert");
    var mquery = require_mquery();
    var store = {
      _promise: null
    };
    store.get = function() {
      return store._promise;
    };
    store.set = function(lib) {
      assert.ok(
        typeof lib === "function",
        `mongoose.Promise must be a function, got ${lib}`
      );
      store._promise = lib;
      mquery.Promise = lib;
    };
    store.set(global.Promise);
    module2.exports = store;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/promiseOrCallback.js
var require_promiseOrCallback = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/promiseOrCallback.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var PromiseProvider = require_promise_provider();
    var immediate = require_immediate();
    var emittedSymbol = Symbol("mongoose:emitted");
    module2.exports = function promiseOrCallback(callback, fn, ee, Promise2) {
      if (typeof callback === "function") {
        return fn(function(error) {
          if (error != null) {
            if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
              error[emittedSymbol] = true;
              ee.emit("error", error);
            }
            try {
              callback(error);
            } catch (error2) {
              return immediate(() => {
                throw error2;
              });
            }
            return;
          }
          callback.apply(this, arguments);
        });
      }
      Promise2 = Promise2 || PromiseProvider.get();
      return new Promise2((resolve, reject) => {
        fn(function(error, res) {
          if (error != null) {
            if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
              error[emittedSymbol] = true;
              ee.emit("error", error);
            }
            return reject(error);
          }
          if (arguments.length > 2) {
            return resolve(Array.prototype.slice.call(arguments, 1));
          }
          resolve(res);
        });
      });
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/merge.js
var require_merge = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/merge.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function merge2(s1, s2, skipConflictingPaths) {
      const paths = Object.keys(s2.tree);
      const pathsToAdd = {};
      for (const key of paths) {
        if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {
          continue;
        }
        pathsToAdd[key] = s2.tree[key];
      }
      s1.add(pathsToAdd);
      s1.callQueue = s1.callQueue.concat(s2.callQueue);
      s1.method(s2.methods);
      s1.static(s2.statics);
      for (const query in s2.query) {
        s1.query[query] = s2.query[query];
      }
      for (const virtual in s2.virtuals) {
        s1.virtuals[virtual] = s2.virtuals[virtual].clone();
      }
      s1.s.hooks.merge(s2.s.hooks, false);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/statemachine.js
var require_statemachine = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/statemachine.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var utils = require_utils2();
    var StateMachine = module2.exports = exports2 = function StateMachine2() {
    };
    StateMachine.ctor = function() {
      const states = utils.args(arguments);
      const ctor = function() {
        StateMachine.apply(this, arguments);
        this.paths = {};
        this.states = {};
        this.stateNames = states;
        let i = states.length, state;
        while (i--) {
          state = states[i];
          this.states[state] = {};
        }
      };
      ctor.prototype = new StateMachine();
      states.forEach(function(state) {
        ctor.prototype[state] = function(path3) {
          this._changeState(path3, state);
        };
      });
      return ctor;
    };
    StateMachine.prototype._changeState = function _changeState(path3, nextState) {
      const prevBucket = this.states[this.paths[path3]];
      if (prevBucket)
        delete prevBucket[path3];
      this.paths[path3] = nextState;
      this.states[nextState][path3] = true;
    };
    StateMachine.prototype.clear = function clear2(state) {
      const keys = Object.keys(this.states[state]);
      let i = keys.length;
      let path3;
      while (i--) {
        path3 = keys[i];
        delete this.states[state][path3];
        delete this.paths[path3];
      }
    };
    StateMachine.prototype.some = function some() {
      const _this = this;
      const what = arguments.length ? arguments : this.stateNames;
      return Array.prototype.some.call(what, function(state) {
        return Object.keys(_this.states[state]).length;
      });
    };
    StateMachine.prototype._iter = function _iter(iterMethod) {
      return function() {
        const numArgs = arguments.length;
        let states = utils.args(arguments, 0, numArgs - 1);
        const callback = arguments[numArgs - 1];
        if (!states.length)
          states = this.stateNames;
        const _this = this;
        const paths = states.reduce(function(paths2, state) {
          return paths2.concat(Object.keys(_this.states[state]));
        }, []);
        return paths[iterMethod](function(path3, i, paths2) {
          return callback(path3, i, paths2);
        });
      };
    };
    StateMachine.prototype.forEach = function forEach() {
      this.forEach = this._iter("forEach");
      return this.forEach.apply(this, arguments);
    };
    StateMachine.prototype.map = function map() {
      this.map = this._iter("map");
      return this.map.apply(this, arguments);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/internal.js
var require_internal = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/internal.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var StateMachine = require_statemachine();
    var ActiveRoster = StateMachine.ctor("require", "modify", "init", "default", "ignore");
    module2.exports = exports2 = InternalCache;
    function InternalCache() {
      this.strictMode = void 0;
      this.selected = void 0;
      this.shardval = void 0;
      this.saveError = void 0;
      this.validationError = void 0;
      this.adhocPaths = void 0;
      this.removing = void 0;
      this.inserting = void 0;
      this.saving = void 0;
      this.version = void 0;
      this.getters = {};
      this._id = void 0;
      this.populate = void 0;
      this.populated = void 0;
      this.wasPopulated = false;
      this.scope = void 0;
      this.activePaths = new ActiveRoster();
      this.pathsToScopes = {};
      this.cachedRequired = {};
      this.session = null;
      this.$setCalled = /* @__PURE__ */ new Set();
      this.ownerDocument = void 0;
      this.fullPath = void 0;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/messages.js
var require_messages = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/messages.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var msg = module2.exports = exports2 = {};
    msg.DocumentNotFoundError = null;
    msg.general = {};
    msg.general.default = "Validator failed for path `{PATH}` with value `{VALUE}`";
    msg.general.required = "Path `{PATH}` is required.";
    msg.Number = {};
    msg.Number.min = "Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).";
    msg.Number.max = "Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).";
    msg.Number.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
    msg.Date = {};
    msg.Date.min = "Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).";
    msg.Date.max = "Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).";
    msg.String = {};
    msg.String.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
    msg.String.match = "Path `{PATH}` is invalid ({VALUE}).";
    msg.String.minlength = "Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).";
    msg.String.maxlength = "Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).";
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/notFound.js
var require_notFound = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/notFound.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var util2 = require("util");
    var DocumentNotFoundError = class extends MongooseError {
      /*!
       * OverwriteModel Error constructor.
       */
      constructor(filter, model, numAffected, result) {
        let msg;
        const messages = MongooseError.messages;
        if (messages.DocumentNotFoundError != null) {
          msg = typeof messages.DocumentNotFoundError === "function" ? messages.DocumentNotFoundError(filter, model) : messages.DocumentNotFoundError;
        } else {
          msg = 'No document found for query "' + util2.inspect(filter) + '" on model "' + model + '"';
        }
        super(msg);
        this.result = result;
        this.numAffected = numAffected;
        this.filter = filter;
        this.query = filter;
      }
    };
    Object.defineProperty(DocumentNotFoundError.prototype, "name", {
      value: "DocumentNotFoundError"
    });
    module2.exports = DocumentNotFoundError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/cast.js
var require_cast = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/cast.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_mongooseError();
    var get = require_get();
    var util2 = require("util");
    var CastError = class extends MongooseError {
      constructor(type, value, path3, reason, schemaType) {
        if (arguments.length > 0) {
          const stringValue = getStringValue(value);
          const valueType = getValueType(value);
          const messageFormat = getMessageFormat(schemaType);
          const msg = formatMessage(null, type, stringValue, path3, messageFormat, valueType);
          super(msg);
          this.init(type, value, path3, reason, schemaType);
        } else {
          super(formatMessage());
        }
      }
      toJSON() {
        return {
          stringValue: this.stringValue,
          valueType: this.valueType,
          kind: this.kind,
          value: this.value,
          path: this.path,
          reason: this.reason,
          name: this.name,
          message: this.message
        };
      }
      /*!
       * ignore
       */
      init(type, value, path3, reason, schemaType) {
        this.stringValue = getStringValue(value);
        this.messageFormat = getMessageFormat(schemaType);
        this.kind = type;
        this.value = value;
        this.path = path3;
        this.reason = reason;
        this.valueType = getValueType(value);
      }
      /*!
       * ignore
       * @param {Readonly<CastError>} other
       */
      copy(other) {
        this.messageFormat = other.messageFormat;
        this.stringValue = other.stringValue;
        this.kind = other.kind;
        this.value = other.value;
        this.path = other.path;
        this.reason = other.reason;
        this.message = other.message;
        this.valueType = other.valueType;
      }
      /*!
       * ignore
       */
      setModel(model) {
        this.model = model;
        this.message = formatMessage(
          model,
          this.kind,
          this.stringValue,
          this.path,
          this.messageFormat,
          this.valueType
        );
      }
    };
    Object.defineProperty(CastError.prototype, "name", {
      value: "CastError"
    });
    function getStringValue(value) {
      let stringValue = util2.inspect(value);
      stringValue = stringValue.replace(/^'|'$/g, '"');
      if (!stringValue.startsWith('"')) {
        stringValue = '"' + stringValue + '"';
      }
      return stringValue;
    }
    function getValueType(value) {
      if (value == null) {
        return "" + value;
      }
      const t = typeof value;
      if (t !== "object") {
        return t;
      }
      if (typeof value.constructor !== "function") {
        return t;
      }
      return value.constructor.name;
    }
    function getMessageFormat(schemaType) {
      const messageFormat = get(schemaType, "options.cast", null);
      if (typeof messageFormat === "string") {
        return messageFormat;
      }
    }
    function formatMessage(model, kind, stringValue, path3, messageFormat, valueType) {
      if (messageFormat != null) {
        let ret2 = messageFormat.replace("{KIND}", kind).replace("{VALUE}", stringValue).replace("{PATH}", path3);
        if (model != null) {
          ret2 = ret2.replace("{MODEL}", model.modelName);
        }
        return ret2;
      } else {
        const valueTypeMsg = valueType ? " (type " + valueType + ")" : "";
        let ret2 = "Cast to " + kind + " failed for value " + stringValue + valueTypeMsg + ' at path "' + path3 + '"';
        if (model != null) {
          ret2 += ' for model "' + model.modelName + '"';
        }
        return ret2;
      }
    }
    module2.exports = CastError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/validation.js
var require_validation = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/validation.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_mongooseError();
    var getConstructorName = require_getConstructorName();
    var util2 = require("util");
    var ValidationError = class extends MongooseError {
      /**
       * Document Validation Error
       *
       * @api private
       * @param {Document} [instance]
       * @inherits MongooseError
       */
      constructor(instance) {
        let _message;
        if (getConstructorName(instance) === "model") {
          _message = instance.constructor.modelName + " validation failed";
        } else {
          _message = "Validation failed";
        }
        super(_message);
        this.errors = {};
        this._message = _message;
        if (instance) {
          instance.errors = this.errors;
        }
      }
      /**
       * Console.log helper
       */
      toString() {
        return this.name + ": " + _generateMessage(this);
      }
      /*!
       * inspect helper
       */
      inspect() {
        return Object.assign(new Error(this.message), this);
      }
      /*!
      * add message
      */
      addError(path3, error) {
        this.errors[path3] = error;
        this.message = this._message + ": " + _generateMessage(this);
      }
    };
    if (util2.inspect.custom) {
      ValidationError.prototype[util2.inspect.custom] = ValidationError.prototype.inspect;
    }
    Object.defineProperty(ValidationError.prototype, "toJSON", {
      enumerable: false,
      writable: false,
      configurable: true,
      value: function() {
        return Object.assign({}, this, { name: this.name, message: this.message });
      }
    });
    Object.defineProperty(ValidationError.prototype, "name", {
      value: "ValidationError"
    });
    function _generateMessage(err) {
      const keys = Object.keys(err.errors || {});
      const len = keys.length;
      const msgs = [];
      let key;
      for (let i = 0; i < len; ++i) {
        key = keys[i];
        if (err === err.errors[key]) {
          continue;
        }
        msgs.push(key + ": " + err.errors[key].message);
      }
      return msgs.join(", ");
    }
    module2.exports = ValidationError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/validator.js
var require_validator = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/validator.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var ValidatorError = class extends MongooseError {
      /**
       * Schema validator error
       *
       * @param {Object} properties
       * @api private
       */
      constructor(properties) {
        let msg = properties.message;
        if (!msg) {
          msg = MongooseError.messages.general.default;
        }
        const message = formatMessage(msg, properties);
        super(message);
        properties = Object.assign({}, properties, { message });
        this.properties = properties;
        this.kind = properties.type;
        this.path = properties.path;
        this.value = properties.value;
        this.reason = properties.reason;
      }
      /*!
       * toString helper
       * TODO remove? This defaults to `${this.name}: ${this.message}`
       */
      toString() {
        return this.message;
      }
      /*!
       * Ensure `name` and `message` show up in toJSON output re: gh-9296
       */
      toJSON() {
        return Object.assign({ name: this.name, message: this.message }, this);
      }
    };
    Object.defineProperty(ValidatorError.prototype, "name", {
      value: "ValidatorError"
    });
    Object.defineProperty(ValidatorError.prototype, "properties", {
      enumerable: false,
      writable: true,
      value: null
    });
    ValidatorError.prototype.formatMessage = formatMessage;
    function formatMessage(msg, properties) {
      if (typeof msg === "function") {
        return msg(properties);
      }
      const propertyNames = Object.keys(properties);
      for (const propertyName of propertyNames) {
        if (propertyName === "message") {
          continue;
        }
        msg = msg.replace("{" + propertyName.toUpperCase() + "}", properties[propertyName]);
      }
      return msg;
    }
    module2.exports = ValidatorError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/version.js
var require_version = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/version.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var VersionError = class extends MongooseError {
      /**
       * Version Error constructor.
       *
       * @param {Document} doc
       * @param {Number} currentVersion
       * @param {Array<String>} modifiedPaths
       * @api private
       */
      constructor(doc, currentVersion, modifiedPaths) {
        const modifiedPathsStr = modifiedPaths.join(", ");
        super('No matching document found for id "' + doc._id + '" version ' + currentVersion + ' modifiedPaths "' + modifiedPathsStr + '"');
        this.version = currentVersion;
        this.modifiedPaths = modifiedPaths;
      }
    };
    Object.defineProperty(VersionError.prototype, "name", {
      value: "VersionError"
    });
    module2.exports = VersionError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/parallelSave.js
var require_parallelSave = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/parallelSave.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var ParallelSaveError = class extends MongooseError {
      /**
       * ParallelSave Error constructor.
       *
       * @param {Document} doc
       * @api private
       */
      constructor(doc) {
        const msg = "Can't save() the same doc multiple times in parallel. Document: ";
        super(msg + doc._id);
      }
    };
    Object.defineProperty(ParallelSaveError.prototype, "name", {
      value: "ParallelSaveError"
    });
    module2.exports = ParallelSaveError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/overwriteModel.js
var require_overwriteModel = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/overwriteModel.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var OverwriteModelError = class extends MongooseError {
      /*!
       * OverwriteModel Error constructor.
       * @param {String} name
       */
      constructor(name) {
        super("Cannot overwrite `" + name + "` model once compiled.");
      }
    };
    Object.defineProperty(OverwriteModelError.prototype, "name", {
      value: "OverwriteModelError"
    });
    module2.exports = OverwriteModelError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/missingSchema.js
var require_missingSchema = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/missingSchema.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var MissingSchemaError = class extends MongooseError {
      /*!
       * MissingSchema Error constructor.
       * @param {String} name
       */
      constructor(name) {
        const msg = `Schema hasn't been registered for model "` + name + '".\nUse mongoose.model(name, schema)';
        super(msg);
      }
    };
    Object.defineProperty(MissingSchemaError.prototype, "name", {
      value: "MissingSchemaError"
    });
    module2.exports = MissingSchemaError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/divergentArray.js
var require_divergentArray = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/divergentArray.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var DivergentArrayError = class extends MongooseError {
      /*!
       * DivergentArrayError constructor.
       * @param {Array<String>} paths
       */
      constructor(paths) {
        const msg = "For your own good, using `document.save()` to update an array which was selected using an $elemMatch projection OR populated using skip, limit, query conditions, or exclusion of the _id field when the operation results in a $pop or $set of the entire array is not supported. The following path(s) would have been modified unsafely:\n  " + paths.join("\n  ") + "\nUse Model.update() to update these arrays instead.";
        super(msg);
      }
    };
    Object.defineProperty(DivergentArrayError.prototype, "name", {
      value: "DivergentArrayError"
    });
    module2.exports = DivergentArrayError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/strict.js
var require_strict = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/strict.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var StrictModeError = class extends MongooseError {
      /**
       * Strict mode error constructor
       *
       * @param {String} path
       * @param {String} [msg]
       * @param {Boolean} [immutable]
       * @inherits MongooseError
       * @api private
       */
      constructor(path3, msg, immutable) {
        msg = msg || "Field `" + path3 + "` is not in schema and strict mode is set to throw.";
        super(msg);
        this.isImmutableError = !!immutable;
        this.path = path3;
      }
    };
    Object.defineProperty(StrictModeError.prototype, "name", {
      value: "StrictModeError"
    });
    module2.exports = StrictModeError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/index.js
var require_error = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_mongooseError();
    module2.exports = exports2 = MongooseError;
    MongooseError.messages = require_messages();
    MongooseError.Messages = MongooseError.messages;
    MongooseError.DocumentNotFoundError = require_notFound();
    MongooseError.CastError = require_cast();
    MongooseError.ValidationError = require_validation();
    MongooseError.ValidatorError = require_validator();
    MongooseError.VersionError = require_version();
    MongooseError.ParallelSaveError = require_parallelSave();
    MongooseError.OverwriteModelError = require_overwriteModel();
    MongooseError.MissingSchemaError = require_missingSchema();
    MongooseError.DivergentArrayError = require_divergentArray();
    MongooseError.StrictModeError = require_strict();
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/propertyOptions.js
var require_propertyOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/propertyOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = Object.freeze({
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaTypeOptions.js
var require_SchemaTypeOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaTypeOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var clone = require_clone();
    var SchemaTypeOptions = class {
      constructor(obj2) {
        if (obj2 == null) {
          return this;
        }
        Object.assign(this, clone(obj2));
      }
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaTypeOptions.prototype, "type", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "validate", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "cast", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "required", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "default", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "ref", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "select", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "index", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "unique", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "immutable", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "sparse", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "text", opts);
    Object.defineProperty(SchemaTypeOptions.prototype, "transform", opts);
    module2.exports = SchemaTypeOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast/boolean.js
var require_boolean = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast/boolean.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var CastError = require_cast();
    module2.exports = function castBoolean(value, path3) {
      if (module2.exports.convertToTrue.has(value)) {
        return true;
      }
      if (module2.exports.convertToFalse.has(value)) {
        return false;
      }
      if (value == null) {
        return value;
      }
      throw new CastError("boolean", value, path3);
    };
    module2.exports.convertToTrue = /* @__PURE__ */ new Set([true, "true", 1, "1", "yes"]);
    module2.exports.convertToFalse = /* @__PURE__ */ new Set([false, "false", 0, "0", "no"]);
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/operators/exists.js
var require_exists = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/operators/exists.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var castBoolean = require_boolean();
    module2.exports = function(val) {
      const path3 = this != null ? this.path : null;
      return castBoolean(val, path3);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/operators/type.js
var require_type = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/operators/type.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(val) {
      if (Array.isArray(val)) {
        if (!val.every((v) => typeof v === "number" || typeof v === "string")) {
          throw new Error("$type array values must be strings or numbers");
        }
        return val;
      }
      if (typeof val !== "number" && typeof val !== "string") {
        throw new Error("$type parameter must be number, string, or array of numbers and strings");
      }
      return val;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js
var require_handleImmutable = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var StrictModeError = require_strict();
    module2.exports = function(schematype) {
      if (schematype.$immutable) {
        schematype.$immutableSetter = createImmutableSetter(
          schematype.path,
          schematype.options.immutable
        );
        schematype.set(schematype.$immutableSetter);
      } else if (schematype.$immutableSetter) {
        schematype.setters = schematype.setters.filter((fn) => fn !== schematype.$immutableSetter);
        delete schematype.$immutableSetter;
      }
    };
    function createImmutableSetter(path3, immutable) {
      return function immutableSetter(v) {
        if (this == null || this.$__ == null) {
          return v;
        }
        if (this.isNew) {
          return v;
        }
        const _immutable = typeof immutable === "function" ? immutable.call(this, this) : immutable;
        if (!_immutable) {
          return v;
        }
        const _value = this.$__getValue(path3);
        if (this.$__.strictMode === "throw" && v !== _value) {
          throw new StrictModeError(path3, "Path `" + path3 + "` is immutable and strict mode is set to throw.", true);
        }
        return _value;
      };
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schematype.js
var require_schematype = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schematype.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var $exists2 = require_exists();
    var $type2 = require_type();
    var get = require_get();
    var handleImmutable = require_handleImmutable();
    var immediate = require_immediate();
    var schemaTypeSymbol = require_symbols().schemaTypeSymbol;
    var util2 = require("util");
    var utils = require_utils2();
    var validatorErrorSymbol = require_symbols().validatorErrorSymbol;
    var documentIsModified = require_symbols().documentIsModified;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var CastError = MongooseError.CastError;
    var ValidatorError = MongooseError.ValidatorError;
    function SchemaType(path3, options, instance) {
      this[schemaTypeSymbol] = true;
      this.path = path3;
      this.instance = instance;
      this.validators = [];
      this.getters = this.constructor.hasOwnProperty("getters") ? this.constructor.getters.slice() : [];
      this.setters = [];
      this.splitPath();
      options = options || {};
      const defaultOptions = this.constructor.defaultOptions || {};
      const defaultOptionsKeys = Object.keys(defaultOptions);
      for (const option of defaultOptionsKeys) {
        if (defaultOptions.hasOwnProperty(option) && !options.hasOwnProperty(option)) {
          options[option] = defaultOptions[option];
        }
      }
      if (options.select == null) {
        delete options.select;
      }
      const Options = this.OptionsConstructor || SchemaTypeOptions;
      this.options = new Options(options);
      this._index = null;
      if (utils.hasUserDefinedProperty(this.options, "immutable")) {
        this.$immutable = this.options.immutable;
        handleImmutable(this);
      }
      const keys = Object.keys(this.options);
      for (const prop of keys) {
        if (prop === "cast") {
          this.castFunction(this.options[prop]);
          continue;
        }
        if (utils.hasUserDefinedProperty(this.options, prop) && typeof this[prop] === "function") {
          if (prop === "index" && this._index) {
            if (options.index === false) {
              const index = this._index;
              if (typeof index === "object" && index != null) {
                if (index.unique) {
                  throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
                }
                if (index.sparse) {
                  throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
                }
              }
              this._index = false;
            }
            continue;
          }
          const val = options[prop];
          if (prop === "default") {
            this.default(val);
            continue;
          }
          const opts = Array.isArray(val) ? val : [val];
          this[prop].apply(this, opts);
        }
      }
      Object.defineProperty(this, "$$context", {
        enumerable: false,
        configurable: false,
        writable: true,
        value: null
      });
    }
    SchemaType.prototype.OptionsConstructor = SchemaTypeOptions;
    SchemaType.prototype.splitPath = function() {
      if (this._presplitPath != null) {
        return this._presplitPath;
      }
      if (this.path == null) {
        return void 0;
      }
      this._presplitPath = this.path.indexOf(".") === -1 ? [this.path] : this.path.split(".");
      return this._presplitPath;
    };
    SchemaType.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = (v) => v;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaType.prototype.castFunction = function castFunction(caster) {
      if (arguments.length === 0) {
        return this._castFunction;
      }
      if (caster === false) {
        caster = this.constructor._defaultCaster || ((v) => v);
      }
      this._castFunction = caster;
      return this._castFunction;
    };
    SchemaType.prototype.cast = function cast() {
      throw new Error("Base SchemaType class does not implement a `cast()` function");
    };
    SchemaType.set = function set(option, value) {
      if (!this.hasOwnProperty("defaultOptions")) {
        this.defaultOptions = Object.assign({}, this.defaultOptions);
      }
      this.defaultOptions[option] = value;
    };
    SchemaType.get = function(getter) {
      this.getters = this.hasOwnProperty("getters") ? this.getters : [];
      this.getters.push(getter);
    };
    SchemaType.prototype.default = function(val) {
      if (arguments.length === 1) {
        if (val === void 0) {
          this.defaultValue = void 0;
          return void 0;
        }
        if (val != null && val.instanceOfSchema) {
          throw new MongooseError("Cannot set default value of path `" + this.path + "` to a mongoose Schema instance.");
        }
        this.defaultValue = val;
        return this.defaultValue;
      } else if (arguments.length > 1) {
        this.defaultValue = utils.args(arguments);
      }
      return this.defaultValue;
    };
    SchemaType.prototype.index = function(options) {
      this._index = options;
      utils.expires(this._index);
      return this;
    };
    SchemaType.prototype.unique = function(bool) {
      if (this._index === false) {
        if (!bool) {
          return;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
      }
      if (this._index == null || this._index === true) {
        this._index = {};
      } else if (typeof this._index === "string") {
        this._index = { type: this._index };
      }
      this._index.unique = bool;
      return this;
    };
    SchemaType.prototype.text = function(bool) {
      if (this._index === false) {
        if (!bool) {
          return;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to false and `text` set to true');
      }
      if (this._index === null || this._index === void 0 || typeof this._index === "boolean") {
        this._index = {};
      } else if (typeof this._index === "string") {
        this._index = { type: this._index };
      }
      this._index.text = bool;
      return this;
    };
    SchemaType.prototype.sparse = function(bool) {
      if (this._index === false) {
        if (!bool) {
          return;
        }
        throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
      }
      if (this._index == null || typeof this._index === "boolean") {
        this._index = {};
      } else if (typeof this._index === "string") {
        this._index = { type: this._index };
      }
      this._index.sparse = bool;
      return this;
    };
    SchemaType.prototype.immutable = function(bool) {
      this.$immutable = bool;
      handleImmutable(this);
      return this;
    };
    SchemaType.prototype.transform = function(fn) {
      this.options.transform = fn;
      return this;
    };
    SchemaType.prototype.set = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError("A setter must be a function.");
      }
      this.setters.push(fn);
      return this;
    };
    SchemaType.prototype.get = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError("A getter must be a function.");
      }
      this.getters.push(fn);
      return this;
    };
    SchemaType.prototype.validate = function(obj2, message, type) {
      if (typeof obj2 === "function" || obj2 && utils.getFunctionName(obj2.constructor) === "RegExp") {
        let properties;
        if (typeof message === "function") {
          properties = { validator: obj2, message };
          properties.type = type || "user defined";
        } else if (message instanceof Object && !type) {
          properties = utils.clone(message);
          if (!properties.message) {
            properties.message = properties.msg;
          }
          properties.validator = obj2;
          properties.type = properties.type || "user defined";
        } else {
          if (message == null) {
            message = MongooseError.messages.general.default;
          }
          if (!type) {
            type = "user defined";
          }
          properties = { message, type, validator: obj2 };
        }
        if (properties.isAsync) {
          handleIsAsync();
        }
        this.validators.push(properties);
        return this;
      }
      let i;
      let length;
      let arg;
      for (i = 0, length = arguments.length; i < length; i++) {
        arg = arguments[i];
        if (!utils.isPOJO(arg)) {
          const msg = "Invalid validator. Received (" + typeof arg + ") " + arg + ". See http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate";
          throw new Error(msg);
        }
        this.validate(arg.validator, arg);
      }
      return this;
    };
    var handleIsAsync = util2.deprecate(
      function handleIsAsync2() {
      },
      "Mongoose: the `isAsync` option for custom validators is deprecated. Make your async validators return a promise instead: https://mongoosejs.com/docs/validation.html#async-custom-validators"
    );
    SchemaType.prototype.required = function(required, message) {
      let customOptions = {};
      if (arguments.length > 0 && required == null) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.requiredValidator;
        }, this);
        this.isRequired = false;
        delete this.originalRequiredValue;
        return this;
      }
      if (typeof required === "object") {
        customOptions = required;
        message = customOptions.message || message;
        required = required.isRequired;
      }
      if (required === false) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.requiredValidator;
        }, this);
        this.isRequired = false;
        delete this.originalRequiredValue;
        return this;
      }
      const _this = this;
      this.isRequired = true;
      this.requiredValidator = function(v) {
        const cachedRequired = get(this, "$__.cachedRequired");
        if (cachedRequired != null && !this.$__isSelected(_this.path) && !this[documentIsModified](_this.path)) {
          return true;
        }
        if (cachedRequired != null && _this.path in cachedRequired) {
          const res = cachedRequired[_this.path] ? _this.checkRequired(v, this) : true;
          delete cachedRequired[_this.path];
          return res;
        } else if (typeof required === "function") {
          return required.apply(this) ? _this.checkRequired(v, this) : true;
        }
        return _this.checkRequired(v, this);
      };
      this.originalRequiredValue = required;
      if (typeof required === "string") {
        message = required;
        required = void 0;
      }
      const msg = message || MongooseError.messages.general.required;
      this.validators.unshift(Object.assign({}, customOptions, {
        validator: this.requiredValidator,
        message: msg,
        type: "required"
      }));
      return this;
    };
    SchemaType.prototype.ref = function(ref) {
      this.options.ref = ref;
      return this;
    };
    SchemaType.prototype.getDefault = function(scope, init) {
      let ret2 = typeof this.defaultValue === "function" ? this.defaultValue.call(scope) : this.defaultValue;
      if (ret2 !== null && ret2 !== void 0) {
        if (typeof ret2 === "object" && (!this.options || !this.options.shared)) {
          ret2 = utils.clone(ret2);
        }
        const casted = this.applySetters(ret2, scope, init);
        if (casted && casted.$isSingleNested) {
          casted.$__parent = scope;
        }
        return casted;
      }
      return ret2;
    };
    SchemaType.prototype._applySetters = function(value, scope, init) {
      let v = value;
      if (init) {
        return v;
      }
      const setters = this.setters;
      for (let i = setters.length - 1; i >= 0; i--) {
        v = setters[i].call(scope, v, this);
      }
      return v;
    };
    SchemaType.prototype._castNullish = function _castNullish(v) {
      return v;
    };
    SchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {
      let v = this._applySetters(value, scope, init, priorVal, options);
      if (v == null) {
        return this._castNullish(v);
      }
      v = this.cast(v, scope, init, priorVal, options);
      return v;
    };
    SchemaType.prototype.applyGetters = function(value, scope) {
      let v = value;
      const getters = this.getters;
      const len = getters.length;
      if (len === 0) {
        return v;
      }
      for (let i = 0; i < len; ++i) {
        v = getters[i].call(scope, v, this);
      }
      return v;
    };
    SchemaType.prototype.select = function select(val) {
      this.selected = !!val;
      return this;
    };
    SchemaType.prototype.doValidate = function(value, fn, scope, options) {
      let err = false;
      const path3 = this.path;
      const validators = this.validators.filter((v) => v != null && typeof v === "object");
      let count = validators.length;
      if (!count) {
        return fn(null);
      }
      const _this = this;
      validators.forEach(function(v) {
        if (err) {
          return;
        }
        const validator = v.validator;
        let ok;
        const validatorProperties = utils.clone(v);
        validatorProperties.path = options && options.path ? options.path : path3;
        validatorProperties.value = value;
        if (validator instanceof RegExp) {
          validate(validator.test(value), validatorProperties);
          return;
        }
        if (typeof validator !== "function") {
          return;
        }
        if (value === void 0 && validator !== _this.requiredValidator) {
          validate(true, validatorProperties);
          return;
        }
        if (validatorProperties.isAsync) {
          asyncValidate(validator, scope, value, validatorProperties, validate);
          return;
        }
        try {
          if (validatorProperties.propsParameter) {
            ok = validator.call(scope, value, validatorProperties);
          } else {
            ok = validator.call(scope, value);
          }
        } catch (error) {
          ok = false;
          validatorProperties.reason = error;
          if (error.message) {
            validatorProperties.message = error.message;
          }
        }
        if (ok != null && typeof ok.then === "function") {
          ok.then(
            function(ok2) {
              validate(ok2, validatorProperties);
            },
            function(error) {
              validatorProperties.reason = error;
              validatorProperties.message = error.message;
              ok = false;
              validate(ok, validatorProperties);
            }
          );
        } else {
          validate(ok, validatorProperties);
        }
      });
      function validate(ok, validatorProperties) {
        if (err) {
          return;
        }
        if (ok === void 0 || ok) {
          if (--count <= 0) {
            immediate(function() {
              fn(null);
            });
          }
        } else {
          const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
          err = new ErrorConstructor(validatorProperties);
          err[validatorErrorSymbol] = true;
          immediate(function() {
            fn(err);
          });
        }
      }
    };
    function asyncValidate(validator, scope, value, props, cb) {
      let called = false;
      const returnVal = validator.call(scope, value, function(ok, customMsg) {
        if (called) {
          return;
        }
        called = true;
        if (customMsg) {
          props.message = customMsg;
        }
        cb(ok, props);
      });
      if (typeof returnVal === "boolean") {
        called = true;
        cb(returnVal, props);
      } else if (returnVal && typeof returnVal.then === "function") {
        returnVal.then(
          function(ok) {
            if (called) {
              return;
            }
            called = true;
            cb(ok, props);
          },
          function(error) {
            if (called) {
              return;
            }
            called = true;
            props.reason = error;
            props.message = error.message;
            cb(false, props);
          }
        );
      }
    }
    SchemaType.prototype.doValidateSync = function(value, scope, options) {
      const path3 = this.path;
      const count = this.validators.length;
      if (!count) {
        return null;
      }
      let validators = this.validators;
      if (value === void 0) {
        if (this.validators.length > 0 && this.validators[0].type === "required") {
          validators = [this.validators[0]];
        } else {
          return null;
        }
      }
      let err = null;
      validators.forEach(function(v) {
        if (err) {
          return;
        }
        if (v == null || typeof v !== "object") {
          return;
        }
        const validator = v.validator;
        const validatorProperties = utils.clone(v);
        validatorProperties.path = options && options.path ? options.path : path3;
        validatorProperties.value = value;
        let ok;
        if (validator.isAsync) {
          return;
        }
        if (validator instanceof RegExp) {
          validate(validator.test(value), validatorProperties);
          return;
        }
        if (typeof validator !== "function") {
          return;
        }
        try {
          if (validatorProperties.propsParameter) {
            ok = validator.call(scope, value, validatorProperties);
          } else {
            ok = validator.call(scope, value);
          }
        } catch (error) {
          ok = false;
          validatorProperties.reason = error;
        }
        if (ok != null && typeof ok.then === "function") {
          return;
        }
        validate(ok, validatorProperties);
      });
      return err;
      function validate(ok, validatorProperties) {
        if (err) {
          return;
        }
        if (ok !== void 0 && !ok) {
          const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
          err = new ErrorConstructor(validatorProperties);
          err[validatorErrorSymbol] = true;
        }
      }
    };
    SchemaType._isRef = function(self2, value, doc, init) {
      let ref = init && self2.options && (self2.options.ref || self2.options.refPath);
      if (!ref && doc && doc.$__ != null) {
        const path3 = doc.$__fullPath(self2.path);
        const owner = doc.ownerDocument ? doc.ownerDocument() : doc;
        ref = owner.populated(path3) || doc.populated(self2.path);
      }
      if (ref) {
        if (value == null) {
          return true;
        }
        if (!Buffer.isBuffer(value) && // buffers are objects too
        value._bsontype !== "Binary" && utils.isObject(value)) {
          return true;
        }
        return init;
      }
      return false;
    };
    SchemaType.prototype._castRef = function _castRef(value, doc, init) {
      if (value == null) {
        return value;
      }
      if (value.$__ != null) {
        value.$__.wasPopulated = true;
        return value;
      }
      if (Buffer.isBuffer(value) || !utils.isObject(value)) {
        if (init) {
          return value;
        }
        throw new CastError(this.instance, value, this.path, null, this);
      }
      const path3 = doc.$__fullPath(this.path);
      const owner = doc.ownerDocument ? doc.ownerDocument() : doc;
      const pop = owner.populated(path3, true);
      let ret2 = value;
      if (!doc.$__.populated || !doc.$__.populated[path3] || !doc.$__.populated[path3].options || !doc.$__.populated[path3].options.options || !doc.$__.populated[path3].options.options.lean) {
        ret2 = new pop.options[populateModelSymbol](value);
        ret2.$__.wasPopulated = true;
      }
      return ret2;
    };
    function handleSingle(val) {
      return this.castForQuery(val);
    }
    function handleArray(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.castForQuery(val)];
      }
      return val.map(function(m) {
        return _this.castForQuery(m);
      });
    }
    function handle$in(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.castForQuery(val)];
      }
      return val.map(function(m) {
        if (Array.isArray(m) && m.length === 0) {
          return m;
        }
        return _this.castForQuery(m);
      });
    }
    SchemaType.prototype.$conditionalHandlers = {
      $all: handleArray,
      $eq: handleSingle,
      $in: handle$in,
      $ne: handleSingle,
      $nin: handle$in,
      $exists: $exists2,
      $type: $type2
    };
    SchemaType.prototype.castForQueryWrapper = function(params) {
      this.$$context = params.context;
      if ("$conditional" in params) {
        const ret3 = this.castForQuery(params.$conditional, params.val);
        this.$$context = null;
        return ret3;
      }
      if (params.$skipQueryCastForUpdate || params.$applySetters) {
        const ret3 = this._castForQuery(params.val);
        this.$$context = null;
        return ret3;
      }
      const ret2 = this.castForQuery(params.val);
      this.$$context = null;
      return ret2;
    };
    SchemaType.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional);
        }
        return handler.call(this, val);
      }
      val = $conditional;
      return this._castForQuery(val);
    };
    SchemaType.prototype._castForQuery = function(val) {
      return this.applySetters(val, this.$$context);
    };
    SchemaType.checkRequired = function(fn) {
      if (arguments.length > 0) {
        this._checkRequired = fn;
      }
      return this._checkRequired;
    };
    SchemaType.prototype.checkRequired = function(val) {
      return val != null;
    };
    SchemaType.prototype.clone = function() {
      const options = Object.assign({}, this.options);
      const schematype = new this.constructor(this.path, options, this.instance);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0)
        schematype.requiredValidator = this.requiredValidator;
      if (this.defaultValue !== void 0)
        schematype.defaultValue = this.defaultValue;
      if (this.$immutable !== void 0 && this.options.immutable === void 0) {
        schematype.$immutable = this.$immutable;
        handleImmutable(schematype);
      }
      if (this._index !== void 0)
        schematype._index = this._index;
      if (this.selected !== void 0)
        schematype.selected = this.selected;
      if (this.isRequired !== void 0)
        schematype.isRequired = this.isRequired;
      if (this.originalRequiredValue !== void 0)
        schematype.originalRequiredValue = this.originalRequiredValue;
      schematype.getters = this.getters.slice();
      schematype.setters = this.setters.slice();
      return schematype;
    };
    module2.exports = exports2 = SchemaType;
    exports2.CastError = CastError;
    exports2.ValidatorError = ValidatorError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/symbols.js"(exports2) {
    "use strict";
    init_cjs_shims();
    exports2.schemaMixedSymbol = Symbol.for("mongoose:schema_mixed");
    exports2.builtInMiddleware = Symbol.for("mongoose:built-in-middleware");
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/mixed.js
var require_mixed = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/mixed.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SchemaType = require_schematype();
    var symbols = require_symbols2();
    var isObject3 = require_isObject();
    var utils = require_utils2();
    function Mixed(path3, options) {
      if (options && options.default) {
        const def = options.default;
        if (Array.isArray(def) && def.length === 0) {
          options.default = Array;
        } else if (!options.shared && isObject3(def) && Object.keys(def).length === 0) {
          options.default = function() {
            return {};
          };
        }
      }
      SchemaType.call(this, path3, options, "Mixed");
      this[symbols.schemaMixedSymbol] = true;
    }
    Mixed.schemaName = "Mixed";
    Mixed.defaultOptions = {};
    Mixed.prototype = Object.create(SchemaType.prototype);
    Mixed.prototype.constructor = Mixed;
    Mixed.get = SchemaType.get;
    Mixed.set = SchemaType.set;
    Mixed.prototype.cast = function(val) {
      if (val instanceof Error) {
        return utils.errorToPOJO(val);
      }
      return val;
    };
    Mixed.prototype.castForQuery = function($cond, val) {
      if (arguments.length === 2) {
        return val;
      }
      return $cond;
    };
    module2.exports = Mixed;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/objectExpected.js
var require_objectExpected = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/objectExpected.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var ObjectExpectedError = class extends MongooseError {
      /**
       * Strict mode error constructor
       *
       * @param {string} type
       * @param {string} value
       * @api private
       */
      constructor(path3, val) {
        const typeDescription = Array.isArray(val) ? "array" : "primitive value";
        super("Tried to set nested object field `" + path3 + `\` to ${typeDescription} \`` + val + "` and strict mode is set to throw.");
        this.path = path3;
      }
    };
    Object.defineProperty(ObjectExpectedError.prototype, "name", {
      value: "ObjectExpectedError"
    });
    module2.exports = ObjectExpectedError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/objectParameter.js
var require_objectParameter = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/objectParameter.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var ObjectParameterError = class extends MongooseError {
      /**
       * Constructor for errors that happen when a parameter that's expected to be
       * an object isn't an object
       *
       * @param {Any} value
       * @param {String} paramName
       * @param {String} fnName
       * @api private
       */
      constructor(value, paramName, fnName) {
        super('Parameter "' + paramName + '" to ' + fnName + "() must be an object, got " + value.toString());
      }
    };
    Object.defineProperty(ObjectParameterError.prototype, "name", {
      value: "ObjectParameterError"
    });
    module2.exports = ObjectParameterError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/parallelValidate.js
var require_parallelValidate = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/parallelValidate.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_mongooseError();
    var ParallelValidateError = class extends MongooseError {
      /**
       * ParallelValidate Error constructor.
       *
       * @param {Document} doc
       * @api private
       */
      constructor(doc) {
        const msg = "Can't validate() the same doc multiple times in parallel. Document: ";
        super(msg + doc._id);
      }
    };
    Object.defineProperty(ParallelValidateError.prototype, "name", {
      value: "ParallelValidateError"
    });
    module2.exports = ParallelValidateError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+kareem@2.3.2/node_modules/kareem/index.js
var require_kareem = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+kareem@2.3.2/node_modules/kareem/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    function Kareem() {
      this._pres = /* @__PURE__ */ new Map();
      this._posts = /* @__PURE__ */ new Map();
    }
    Kareem.prototype.execPre = function(name, context, args, callback) {
      if (arguments.length === 3) {
        callback = args;
        args = [];
      }
      var pres = get(this._pres, name, []);
      var numPres = pres.length;
      var numAsyncPres = pres.numAsync || 0;
      var currentPre = 0;
      var asyncPresLeft = numAsyncPres;
      var done = false;
      var $args = args;
      if (!numPres) {
        return process.nextTick(function() {
          callback(null);
        });
      }
      var next = function() {
        if (currentPre >= numPres) {
          return;
        }
        var pre = pres[currentPre];
        if (pre.isAsync) {
          var args2 = [
            decorateNextFn(_next),
            decorateNextFn(function(error) {
              if (error) {
                if (done) {
                  return;
                }
                done = true;
                return callback(error);
              }
              if (--asyncPresLeft === 0 && currentPre >= numPres) {
                return callback(null);
              }
            })
          ];
          callMiddlewareFunction(pre.fn, context, args2, args2[0]);
        } else if (pre.fn.length > 0) {
          var args2 = [decorateNextFn(_next)];
          var _args = arguments.length >= 2 ? arguments : [null].concat($args);
          for (var i = 1; i < _args.length; ++i) {
            args2.push(_args[i]);
          }
          callMiddlewareFunction(pre.fn, context, args2, args2[0]);
        } else {
          let maybePromise = null;
          try {
            maybePromise = pre.fn.call(context);
          } catch (err) {
            if (err != null) {
              return callback(err);
            }
          }
          if (isPromise(maybePromise)) {
            maybePromise.then(() => _next(), (err) => _next(err));
          } else {
            if (++currentPre >= numPres) {
              if (asyncPresLeft > 0) {
                return;
              } else {
                return process.nextTick(function() {
                  callback(null);
                });
              }
            }
            next();
          }
        }
      };
      next.apply(null, [null].concat(args));
      function _next(error) {
        if (error) {
          if (done) {
            return;
          }
          done = true;
          return callback(error);
        }
        if (++currentPre >= numPres) {
          if (asyncPresLeft > 0) {
            return;
          } else {
            return callback(null);
          }
        }
        next.apply(context, arguments);
      }
    };
    Kareem.prototype.execPreSync = function(name, context, args) {
      var pres = get(this._pres, name, []);
      var numPres = pres.length;
      for (var i = 0; i < numPres; ++i) {
        pres[i].fn.apply(context, args || []);
      }
    };
    Kareem.prototype.execPost = function(name, context, args, options, callback) {
      if (arguments.length < 5) {
        callback = options;
        options = null;
      }
      var posts = get(this._posts, name, []);
      var numPosts = posts.length;
      var currentPost = 0;
      var firstError = null;
      if (options && options.error) {
        firstError = options.error;
      }
      if (!numPosts) {
        return process.nextTick(function() {
          callback.apply(null, [firstError].concat(args));
        });
      }
      var next = function() {
        var post = posts[currentPost].fn;
        var numArgs = 0;
        var argLength = args.length;
        var newArgs = [];
        for (var i = 0; i < argLength; ++i) {
          numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;
          if (!args[i] || !args[i]._kareemIgnore) {
            newArgs.push(args[i]);
          }
        }
        if (firstError) {
          if (post.length === numArgs + 2) {
            var _cb = decorateNextFn(function(error) {
              if (error) {
                firstError = error;
              }
              if (++currentPost >= numPosts) {
                return callback.call(null, firstError);
              }
              next();
            });
            callMiddlewareFunction(
              post,
              context,
              [firstError].concat(newArgs).concat([_cb]),
              _cb
            );
          } else {
            if (++currentPost >= numPosts) {
              return callback.call(null, firstError);
            }
            next();
          }
        } else {
          const _cb2 = decorateNextFn(function(error) {
            if (error) {
              firstError = error;
              return next();
            }
            if (++currentPost >= numPosts) {
              return callback.apply(null, [null].concat(args));
            }
            next();
          });
          if (post.length === numArgs + 2) {
            if (++currentPost >= numPosts) {
              return callback.apply(null, [null].concat(args));
            }
            return next();
          }
          if (post.length === numArgs + 1) {
            callMiddlewareFunction(post, context, newArgs.concat([_cb2]), _cb2);
          } else {
            let error;
            let maybePromise;
            try {
              maybePromise = post.apply(context, newArgs);
            } catch (err) {
              error = err;
              firstError = err;
            }
            if (isPromise(maybePromise)) {
              return maybePromise.then(() => _cb2(), (err) => _cb2(err));
            }
            if (++currentPost >= numPosts) {
              return callback.apply(null, [error].concat(args));
            }
            next(error);
          }
        }
      };
      next();
    };
    Kareem.prototype.execPostSync = function(name, context, args) {
      const posts = get(this._posts, name, []);
      const numPosts = posts.length;
      for (let i = 0; i < numPosts; ++i) {
        posts[i].fn.apply(context, args || []);
      }
    };
    Kareem.prototype.createWrapperSync = function(name, fn) {
      var kareem = this;
      return function syncWrapper() {
        kareem.execPreSync(name, this, arguments);
        var toReturn = fn.apply(this, arguments);
        kareem.execPostSync(name, this, [toReturn]);
        return toReturn;
      };
    };
    function _handleWrapError(instance, error, name, context, args, options, callback) {
      if (options.useErrorHandlers) {
        var _options = { error };
        return instance.execPost(name, context, args, _options, function(error2) {
          return typeof callback === "function" && callback(error2);
        });
      } else {
        return typeof callback === "function" ? callback(error) : void 0;
      }
    }
    Kareem.prototype.wrap = function(name, fn, context, args, options) {
      const lastArg = args.length > 0 ? args[args.length - 1] : null;
      const argsWithoutCb = typeof lastArg === "function" ? args.slice(0, args.length - 1) : args;
      const _this = this;
      options = options || {};
      const checkForPromise = options.checkForPromise;
      this.execPre(name, context, args, function(error) {
        if (error) {
          const numCallbackParams = options.numCallbackParams || 0;
          const errorArgs = options.contextParameter ? [context] : [];
          for (var i = errorArgs.length; i < numCallbackParams; ++i) {
            errorArgs.push(null);
          }
          return _handleWrapError(
            _this,
            error,
            name,
            context,
            errorArgs,
            options,
            lastArg
          );
        }
        const end = typeof lastArg === "function" ? args.length - 1 : args.length;
        const numParameters = fn.length;
        const ret2 = fn.apply(context, args.slice(0, end).concat(_cb));
        if (checkForPromise) {
          if (ret2 != null && typeof ret2.then === "function") {
            return ret2.then(
              (res) => _cb(null, res),
              (err) => _cb(err)
            );
          }
          if (numParameters < end + 1) {
            return _cb(null, ret2);
          }
        }
        function _cb() {
          const args2 = arguments;
          const argsWithoutError = Array.prototype.slice.call(arguments, 1);
          if (options.nullResultByDefault && argsWithoutError.length === 0) {
            argsWithoutError.push(null);
          }
          if (arguments[0]) {
            return _handleWrapError(
              _this,
              arguments[0],
              name,
              context,
              argsWithoutError,
              options,
              lastArg
            );
          } else {
            _this.execPost(name, context, argsWithoutError, function() {
              if (arguments[0]) {
                return typeof lastArg === "function" ? lastArg(arguments[0]) : void 0;
              }
              return typeof lastArg === "function" ? lastArg.apply(context, arguments) : void 0;
            });
          }
        }
      });
    };
    Kareem.prototype.filter = function(fn) {
      const clone = this.clone();
      const pres = Array.from(clone._pres.keys());
      for (const name of pres) {
        const hooks = this._pres.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
        if (hooks.length === 0) {
          clone._pres.delete(name);
          continue;
        }
        hooks.numAsync = hooks.filter((h) => h.isAsync).length;
        clone._pres.set(name, hooks);
      }
      const posts = Array.from(clone._posts.keys());
      for (const name of posts) {
        const hooks = this._posts.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
        if (hooks.length === 0) {
          clone._posts.delete(name);
          continue;
        }
        clone._posts.set(name, hooks);
      }
      return clone;
    };
    Kareem.prototype.hasHooks = function(name) {
      return this._pres.has(name) || this._posts.has(name);
    };
    Kareem.prototype.createWrapper = function(name, fn, context, options) {
      var _this = this;
      if (!this.hasHooks(name)) {
        return function() {
          process.nextTick(() => fn.apply(this, arguments));
        };
      }
      return function() {
        var _context = context || this;
        var args = Array.prototype.slice.call(arguments);
        _this.wrap(name, fn, _context, args, options);
      };
    };
    Kareem.prototype.pre = function(name, isAsync, fn, error, unshift) {
      let options = {};
      if (typeof isAsync === "object" && isAsync != null) {
        options = isAsync;
        isAsync = options.isAsync;
      } else if (typeof arguments[1] !== "boolean") {
        error = fn;
        fn = isAsync;
        isAsync = false;
      }
      const pres = get(this._pres, name, []);
      this._pres.set(name, pres);
      if (isAsync) {
        pres.numAsync = pres.numAsync || 0;
        ++pres.numAsync;
      }
      if (typeof fn !== "function") {
        throw new Error('pre() requires a function, got "' + typeof fn + '"');
      }
      if (unshift) {
        pres.unshift(Object.assign({}, options, { fn, isAsync }));
      } else {
        pres.push(Object.assign({}, options, { fn, isAsync }));
      }
      return this;
    };
    Kareem.prototype.post = function(name, options, fn, unshift) {
      const hooks = get(this._posts, name, []);
      if (typeof options === "function") {
        unshift = !!fn;
        fn = options;
        options = {};
      }
      if (typeof fn !== "function") {
        throw new Error('post() requires a function, got "' + typeof fn + '"');
      }
      if (unshift) {
        hooks.unshift(Object.assign({}, options, { fn }));
      } else {
        hooks.push(Object.assign({}, options, { fn }));
      }
      this._posts.set(name, hooks);
      return this;
    };
    Kareem.prototype.clone = function() {
      const n = new Kareem();
      for (let key of this._pres.keys()) {
        const clone = this._pres.get(key).slice();
        clone.numAsync = this._pres.get(key).numAsync;
        n._pres.set(key, clone);
      }
      for (let key of this._posts.keys()) {
        n._posts.set(key, this._posts.get(key).slice());
      }
      return n;
    };
    Kareem.prototype.merge = function(other, clone) {
      clone = arguments.length === 1 ? true : clone;
      var ret2 = clone ? this.clone() : this;
      for (let key of other._pres.keys()) {
        const sourcePres = get(ret2._pres, key, []);
        const deduplicated = other._pres.get(key).filter((p) => sourcePres.map((_p) => _p.fn).indexOf(p.fn) === -1);
        const combined = sourcePres.concat(deduplicated);
        combined.numAsync = sourcePres.numAsync || 0;
        combined.numAsync += deduplicated.filter((p) => p.isAsync).length;
        ret2._pres.set(key, combined);
      }
      for (let key of other._posts.keys()) {
        const sourcePosts = get(ret2._posts, key, []);
        const deduplicated = other._posts.get(key).filter((p) => sourcePosts.indexOf(p) === -1);
        ret2._posts.set(key, sourcePosts.concat(deduplicated));
      }
      return ret2;
    };
    function get(map, key, def) {
      if (map.has(key)) {
        return map.get(key);
      }
      return def;
    }
    function callMiddlewareFunction(fn, context, args, next) {
      let maybePromise;
      try {
        maybePromise = fn.apply(context, args);
      } catch (error) {
        return next(error);
      }
      if (isPromise(maybePromise)) {
        maybePromise.then(() => next(), (err) => next(err));
      }
    }
    function isPromise(v) {
      return v != null && typeof v.then === "function";
    }
    function decorateNextFn(fn) {
      var called = false;
      var _this = this;
      return function() {
        if (called) {
          return;
        }
        called = true;
        return process.nextTick(() => fn.apply(_this, arguments));
      };
    }
    module2.exports = Kareem;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/VirtualOptions.js
var require_VirtualOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/VirtualOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var opts = require_propertyOptions();
    var VirtualOptions = class {
      constructor(obj2) {
        Object.assign(this, obj2);
        if (obj2 != null && obj2.options != null) {
          this.options = Object.assign({}, obj2.options);
        }
      }
    };
    Object.defineProperty(VirtualOptions.prototype, "ref", opts);
    Object.defineProperty(VirtualOptions.prototype, "refPath", opts);
    Object.defineProperty(VirtualOptions.prototype, "localField", opts);
    Object.defineProperty(VirtualOptions.prototype, "foreignField", opts);
    Object.defineProperty(VirtualOptions.prototype, "justOne", opts);
    Object.defineProperty(VirtualOptions.prototype, "count", opts);
    Object.defineProperty(VirtualOptions.prototype, "match", opts);
    Object.defineProperty(VirtualOptions.prototype, "options", opts);
    Object.defineProperty(VirtualOptions.prototype, "skip", opts);
    Object.defineProperty(VirtualOptions.prototype, "limit", opts);
    Object.defineProperty(VirtualOptions.prototype, "perDocumentLimit", opts);
    module2.exports = VirtualOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/virtualtype.js
var require_virtualtype = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/virtualtype.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var utils = require_utils2();
    function VirtualType(options, name) {
      this.path = name;
      this.getters = [];
      this.setters = [];
      this.options = Object.assign({}, options);
    }
    VirtualType.prototype._applyDefaultGetters = function() {
      if (this.getters.length > 0 || this.setters.length > 0) {
        return;
      }
      const path3 = this.path;
      const internalProperty = "$" + path3;
      this.getters.push(function() {
        return this[internalProperty];
      });
      this.setters.push(function(v) {
        this[internalProperty] = v;
      });
    };
    VirtualType.prototype.clone = function() {
      const clone = new VirtualType(this.options, this.path);
      clone.getters = [].concat(this.getters);
      clone.setters = [].concat(this.setters);
      return clone;
    };
    VirtualType.prototype.get = function(fn) {
      this.getters.push(fn);
      return this;
    };
    VirtualType.prototype.set = function(fn) {
      this.setters.push(fn);
      return this;
    };
    VirtualType.prototype.applyGetters = function(value, doc) {
      if (utils.hasUserDefinedProperty(this.options, ["ref", "refPath"]) && doc.$$populatedVirtuals && doc.$$populatedVirtuals.hasOwnProperty(this.path)) {
        value = doc.$$populatedVirtuals[this.path];
      }
      let v = value;
      for (let l2 = this.getters.length - 1; l2 >= 0; l2--) {
        v = this.getters[l2].call(doc, v, this, doc);
      }
      return v;
    };
    VirtualType.prototype.applySetters = function(value, doc) {
      let v = value;
      for (let l2 = this.setters.length - 1; l2 >= 0; l2--) {
        v = this.setters[l2].call(doc, v, this, doc);
      }
      return v;
    };
    module2.exports = VirtualType;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/addAutoId.js
var require_addAutoId = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/addAutoId.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function addAutoId(schema) {
      const _obj = { _id: { auto: true } };
      _obj._id[schema.options.typeKey] = "ObjectId";
      schema.add(_obj);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/getIndexes.js
var require_getIndexes = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/getIndexes.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var get = require_get();
    var helperIsObject = require_isObject();
    module2.exports = function getIndexes(schema) {
      let indexes = [];
      const schemaStack = /* @__PURE__ */ new WeakMap();
      const indexTypes = schema.constructor.indexTypes;
      const indexByName = /* @__PURE__ */ new Map();
      collectIndexes(schema);
      return indexes;
      function collectIndexes(schema2, prefix, baseSchema) {
        if (schemaStack.has(schema2)) {
          return;
        }
        schemaStack.set(schema2, true);
        prefix = prefix || "";
        const keys = Object.keys(schema2.paths);
        for (const key of keys) {
          const path3 = schema2.paths[key];
          if (baseSchema != null && baseSchema.paths[key]) {
            continue;
          }
          if (path3.$isMongooseDocumentArray || path3.$isSingleNested) {
            if (get(path3, "options.excludeIndexes") !== true && get(path3, "schemaOptions.excludeIndexes") !== true && get(path3, "schema.options.excludeIndexes") !== true) {
              collectIndexes(path3.schema, prefix + key + ".");
            }
            if (path3.schema.discriminators != null) {
              const discriminators = path3.schema.discriminators;
              const discriminatorKeys = Object.keys(discriminators);
              for (const discriminatorKey of discriminatorKeys) {
                collectIndexes(
                  discriminators[discriminatorKey],
                  prefix + key + ".",
                  path3.schema
                );
              }
            }
            if (path3.$isMongooseDocumentArray) {
              continue;
            }
          }
          const index = path3._index || path3.caster && path3.caster._index;
          if (index !== false && index !== null && index !== void 0) {
            const field = {};
            const isObject3 = helperIsObject(index);
            const options = isObject3 ? index : {};
            const type = typeof index === "string" ? index : isObject3 ? index.type : false;
            if (type && indexTypes.indexOf(type) !== -1) {
              field[prefix + key] = type;
            } else if (options.text) {
              field[prefix + key] = "text";
              delete options.text;
            } else {
              const isDescendingIndex = Number(index) === -1;
              field[prefix + key] = isDescendingIndex ? -1 : 1;
            }
            delete options.type;
            if (!("background" in options)) {
              options.background = true;
            }
            if (schema2.options.autoIndex != null) {
              options._autoIndex = schema2.options.autoIndex;
            }
            const indexName = options && options.name;
            if (typeof indexName === "string") {
              if (indexByName.has(indexName)) {
                Object.assign(indexByName.get(indexName), field);
              } else {
                indexes.push([field, options]);
                indexByName.set(indexName, field);
              }
            } else {
              indexes.push([field, options]);
              indexByName.set(indexName, field);
            }
          }
        }
        schemaStack.delete(schema2);
        if (prefix) {
          fixSubIndexPaths(schema2, prefix);
        } else {
          schema2._indexes.forEach(function(index) {
            if (!("background" in index[1])) {
              index[1].background = true;
            }
          });
          indexes = indexes.concat(schema2._indexes);
        }
      }
      function fixSubIndexPaths(schema2, prefix) {
        const subindexes = schema2._indexes;
        const len = subindexes.length;
        for (let i = 0; i < len; ++i) {
          const indexObj = subindexes[i][0];
          const indexOptions = subindexes[i][1];
          const keys = Object.keys(indexObj);
          const klen = keys.length;
          const newindex = {};
          for (let j = 0; j < klen; ++j) {
            const key = keys[j];
            newindex[prefix + key] = indexObj[key];
          }
          const newIndexOptions = Object.assign({}, indexOptions);
          if (indexOptions != null && indexOptions.partialFilterExpression != null) {
            newIndexOptions.partialFilterExpression = {};
            const partialFilterExpression = indexOptions.partialFilterExpression;
            for (const key of Object.keys(partialFilterExpression)) {
              newIndexOptions.partialFilterExpression[prefix + key] = partialFilterExpression[key];
            }
          }
          indexes.push([newindex, newIndexOptions]);
        }
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js
var require_cleanPositionalOperators = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function cleanPositionalOperators(path3) {
      return path3.replace(/\.\$(\[[^\]]*\])?(?=\.)/g, ".0").replace(/\.\$(\[[^\]]*\])?$/g, ".0");
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js
var require_handleTimestampOption = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = handleTimestampOption;
    function handleTimestampOption(arg, prop) {
      if (arg == null) {
        return null;
      }
      if (typeof arg === "boolean") {
        return prop;
      }
      if (typeof arg[prop] === "boolean") {
        return arg[prop] ? prop : null;
      }
      if (!(prop in arg)) {
        return prop;
      }
      return arg[prop];
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js
var require_applyTimestampsToChildren = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var handleTimestampOption = require_handleTimestampOption();
    module2.exports = applyTimestampsToChildren;
    function applyTimestampsToChildren(now, update, schema) {
      if (update == null) {
        return;
      }
      const keys = Object.keys(update);
      const hasDollarKey = keys.some((key) => key.startsWith("$"));
      if (hasDollarKey) {
        if (update.$push) {
          _applyTimestampToUpdateOperator(update.$push);
        }
        if (update.$addToSet) {
          _applyTimestampToUpdateOperator(update.$addToSet);
        }
        if (update.$set != null) {
          const keys2 = Object.keys(update.$set);
          for (const key of keys2) {
            applyTimestampsToUpdateKey(schema, key, update.$set, now);
          }
        }
        if (update.$setOnInsert != null) {
          const keys2 = Object.keys(update.$setOnInsert);
          for (const key of keys2) {
            applyTimestampsToUpdateKey(schema, key, update.$setOnInsert, now);
          }
        }
      }
      const updateKeys = Object.keys(update).filter((key) => !key.startsWith("$"));
      for (const key of updateKeys) {
        applyTimestampsToUpdateKey(schema, key, update, now);
      }
      function _applyTimestampToUpdateOperator(op) {
        for (const key of Object.keys(op)) {
          const $path = schema.path(key.replace(/\.\$\./i, ".").replace(/.\$$/, ""));
          if (op[key] && $path && $path.$isMongooseDocumentArray && $path.schema.options.timestamps) {
            const timestamps = $path.schema.options.timestamps;
            const createdAt = handleTimestampOption(timestamps, "createdAt");
            const updatedAt = handleTimestampOption(timestamps, "updatedAt");
            if (op[key].$each) {
              op[key].$each.forEach(function(subdoc) {
                if (updatedAt != null) {
                  subdoc[updatedAt] = now;
                }
                if (createdAt != null) {
                  subdoc[createdAt] = now;
                }
              });
            } else {
              if (updatedAt != null) {
                op[key][updatedAt] = now;
              }
              if (createdAt != null) {
                op[key][createdAt] = now;
              }
            }
          }
        }
      }
    }
    function applyTimestampsToDocumentArray(arr, schematype, now) {
      const timestamps = schematype.schema.options.timestamps;
      if (!timestamps) {
        return;
      }
      const len = arr.length;
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      for (let i = 0; i < len; ++i) {
        if (updatedAt != null) {
          arr[i][updatedAt] = now;
        }
        if (createdAt != null) {
          arr[i][createdAt] = now;
        }
        applyTimestampsToChildren(now, arr[i], schematype.schema);
      }
    }
    function applyTimestampsToSingleNested(subdoc, schematype, now) {
      const timestamps = schematype.schema.options.timestamps;
      if (!timestamps) {
        return;
      }
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      if (updatedAt != null) {
        subdoc[updatedAt] = now;
      }
      if (createdAt != null) {
        subdoc[createdAt] = now;
      }
      applyTimestampsToChildren(now, subdoc, schematype.schema);
    }
    function applyTimestampsToUpdateKey(schema, key, update, now) {
      const keyToSearch = cleanPositionalOperators(key);
      const path3 = schema.path(keyToSearch);
      if (!path3) {
        return;
      }
      const parentSchemaTypes = [];
      const pieces = keyToSearch.split(".");
      for (let i = pieces.length - 1; i > 0; --i) {
        const s = schema.path(pieces.slice(0, i).join("."));
        if (s != null && (s.$isMongooseDocumentArray || s.$isSingleNested)) {
          parentSchemaTypes.push({ parentPath: key.split(".").slice(0, i).join("."), parentSchemaType: s });
        }
      }
      if (Array.isArray(update[key]) && path3.$isMongooseDocumentArray) {
        applyTimestampsToDocumentArray(update[key], path3, now);
      } else if (update[key] && path3.$isSingleNested) {
        applyTimestampsToSingleNested(update[key], path3, now);
      } else if (parentSchemaTypes.length > 0) {
        for (const item of parentSchemaTypes) {
          const parentPath = item.parentPath;
          const parentSchemaType = item.parentSchemaType;
          const timestamps = parentSchemaType.schema.options.timestamps;
          const updatedAt = handleTimestampOption(timestamps, "updatedAt");
          if (!timestamps || updatedAt == null) {
            continue;
          }
          if (parentSchemaType.$isSingleNested) {
            update[parentPath + "." + updatedAt] = now;
          } else if (parentSchemaType.$isMongooseDocumentArray) {
            let childPath = key.substr(parentPath.length + 1);
            if (/^\d+$/.test(childPath)) {
              update[parentPath + "." + childPath][updatedAt] = now;
              continue;
            }
            const firstDot = childPath.indexOf(".");
            childPath = firstDot !== -1 ? childPath.substr(0, firstDot) : childPath;
            update[parentPath + "." + childPath + "." + updatedAt] = now;
          }
        }
      } else if (path3.schema != null && path3.schema != schema && update[key]) {
        const timestamps = path3.schema.options.timestamps;
        const createdAt = handleTimestampOption(timestamps, "createdAt");
        const updatedAt = handleTimestampOption(timestamps, "updatedAt");
        if (!timestamps) {
          return;
        }
        if (updatedAt != null) {
          update[key][updatedAt] = now;
        }
        if (createdAt != null) {
          update[key][createdAt] = now;
        }
      }
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js
var require_applyTimestampsToUpdate = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var get = require_get();
    module2.exports = applyTimestampsToUpdate;
    function applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options) {
      const updates = currentUpdate;
      let _updates = updates;
      const overwrite = get(options, "overwrite", false);
      const timestamps = get(options, "timestamps", true);
      if (!timestamps || updates == null) {
        return currentUpdate;
      }
      const skipCreatedAt = timestamps != null && timestamps.createdAt === false;
      const skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;
      if (overwrite) {
        if (currentUpdate && currentUpdate.$set) {
          currentUpdate = currentUpdate.$set;
          updates.$set = {};
          _updates = updates.$set;
        }
        if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {
          _updates[updatedAt] = now;
        }
        if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {
          _updates[createdAt] = now;
        }
        return updates;
      }
      currentUpdate = currentUpdate || {};
      if (Array.isArray(updates)) {
        updates.push({ $set: { updatedAt: now } });
        return updates;
      }
      updates.$set = updates.$set || {};
      if (!skipUpdatedAt && updatedAt && (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {
        let timestampSet = false;
        if (updatedAt.indexOf(".") !== -1) {
          const pieces = updatedAt.split(".");
          for (let i = 1; i < pieces.length; ++i) {
            const remnant = pieces.slice(-i).join(".");
            const start = pieces.slice(0, -i).join(".");
            if (currentUpdate[start] != null) {
              currentUpdate[start][remnant] = now;
              timestampSet = true;
              break;
            } else if (currentUpdate.$set && currentUpdate.$set[start]) {
              currentUpdate.$set[start][remnant] = now;
              timestampSet = true;
              break;
            }
          }
        }
        if (!timestampSet) {
          updates.$set[updatedAt] = now;
        }
        if (updates.hasOwnProperty(updatedAt)) {
          delete updates[updatedAt];
        }
      }
      if (!skipCreatedAt && createdAt) {
        if (currentUpdate[createdAt]) {
          delete currentUpdate[createdAt];
        }
        if (currentUpdate.$set && currentUpdate.$set[createdAt]) {
          delete currentUpdate.$set[createdAt];
        }
        let timestampSet = false;
        if (createdAt.indexOf(".") !== -1) {
          const pieces = createdAt.split(".");
          for (let i = 1; i < pieces.length; ++i) {
            const remnant = pieces.slice(-i).join(".");
            const start = pieces.slice(0, -i).join(".");
            if (currentUpdate[start] != null) {
              currentUpdate[start][remnant] = now;
              timestampSet = true;
              break;
            } else if (currentUpdate.$set && currentUpdate.$set[start]) {
              currentUpdate.$set[start][remnant] = now;
              timestampSet = true;
              break;
            }
          }
        }
        if (!timestampSet) {
          updates.$setOnInsert = updates.$setOnInsert || {};
          updates.$setOnInsert[createdAt] = now;
        }
      }
      if (Object.keys(updates.$set).length === 0) {
        delete updates.$set;
      }
      return updates;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js
var require_setupTimestamps = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var applyTimestampsToChildren = require_applyTimestampsToChildren();
    var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
    var get = require_get();
    var handleTimestampOption = require_handleTimestampOption();
    var symbols = require_symbols2();
    module2.exports = function setupTimestamps(schema, timestamps) {
      const childHasTimestamp = schema.childSchemas.find(withTimestamp);
      function withTimestamp(s) {
        const ts = s.schema.options.timestamps;
        return !!ts;
      }
      if (!timestamps && !childHasTimestamp) {
        return;
      }
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      const currentTime = timestamps != null && timestamps.hasOwnProperty("currentTime") ? timestamps.currentTime : null;
      const schemaAdditions = {};
      schema.$timestamps = { createdAt, updatedAt };
      if (updatedAt && !schema.paths[updatedAt]) {
        schemaAdditions[updatedAt] = Date;
      }
      if (createdAt && !schema.paths[createdAt]) {
        schemaAdditions[createdAt] = Date;
      }
      schema.add(schemaAdditions);
      schema.pre("save", function(next) {
        const timestampOption = get(this, "$__.saveOptions.timestamps");
        if (timestampOption === false) {
          return next();
        }
        const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;
        const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;
        const defaultTimestamp = currentTime != null ? currentTime() : (this.ownerDocument ? this.ownerDocument() : this).constructor.base.now();
        const auto_id = this._id && this._id.auto;
        if (!skipCreatedAt && this.isNew && createdAt && !this.get(createdAt) && this.$__isSelected(createdAt)) {
          this.$set(createdAt, auto_id ? this._id.getTimestamp() : defaultTimestamp);
        }
        if (!skipUpdatedAt && updatedAt && (this.isNew || this.isModified())) {
          let ts = defaultTimestamp;
          if (this.isNew) {
            if (createdAt != null) {
              ts = this.$__getValue(createdAt);
            } else if (auto_id) {
              ts = this._id.getTimestamp();
            }
          }
          this.$set(updatedAt, ts);
        }
        next();
      });
      schema.methods.initializeTimestamps = function() {
        const ts = currentTime != null ? currentTime() : this.constructor.base.now();
        if (createdAt && !this.get(createdAt)) {
          this.$set(createdAt, ts);
        }
        if (updatedAt && !this.get(updatedAt)) {
          this.$set(updatedAt, ts);
        }
        return this;
      };
      _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;
      const opts = { query: true, model: false };
      schema.pre("findOneAndReplace", opts, _setTimestampsOnUpdate);
      schema.pre("findOneAndUpdate", opts, _setTimestampsOnUpdate);
      schema.pre("replaceOne", opts, _setTimestampsOnUpdate);
      schema.pre("update", opts, _setTimestampsOnUpdate);
      schema.pre("updateOne", opts, _setTimestampsOnUpdate);
      schema.pre("updateMany", opts, _setTimestampsOnUpdate);
      function _setTimestampsOnUpdate(next) {
        const now = currentTime != null ? currentTime() : this.model.base.now();
        if (this.op === "findOneAndReplace" && this.getUpdate() == null) {
          this.setUpdate({});
        }
        applyTimestampsToUpdate(
          now,
          createdAt,
          updatedAt,
          this.getUpdate(),
          this.options,
          this.schema
        );
        applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);
        next();
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/validateRef.js
var require_validateRef = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/validateRef.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_mongooseError();
    var util2 = require("util");
    module2.exports = validateRef;
    function validateRef(ref, path3) {
      if (typeof ref === "string") {
        return;
      }
      if (typeof ref === "function") {
        return;
      }
      throw new MongooseError('Invalid ref at path "' + path3 + '". Got ' + util2.inspect(ref, { depth: 0 }));
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js
var require_applyQueryMiddleware = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = applyQueryMiddleware;
    applyQueryMiddleware.middlewareFunctions = [
      "count",
      "countDocuments",
      "deleteMany",
      "deleteOne",
      "distinct",
      "estimatedDocumentCount",
      "find",
      "findOne",
      "findOneAndDelete",
      "findOneAndRemove",
      "findOneAndReplace",
      "findOneAndUpdate",
      "remove",
      "replaceOne",
      "update",
      "updateMany",
      "updateOne",
      "validate"
    ];
    function applyQueryMiddleware(Query, model) {
      const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1,
        nullResultByDefault: true
      };
      const middleware = model.hooks.filter((hook) => {
        const contexts = _getContexts(hook);
        if (hook.name === "updateOne") {
          return contexts.query == null || !!contexts.query;
        }
        if (hook.name === "deleteOne") {
          return !!contexts.query || Object.keys(contexts).length === 0;
        }
        if (hook.name === "validate" || hook.name === "remove") {
          return !!contexts.query;
        }
        if (hook.query != null || hook.document != null) {
          return !!hook.query;
        }
        return true;
      });
      Query.prototype._execUpdate = middleware.createWrapper(
        "update",
        Query.prototype._execUpdate,
        null,
        kareemOptions
      );
      Query.prototype.__distinct = middleware.createWrapper(
        "distinct",
        Query.prototype.__distinct,
        null,
        kareemOptions
      );
      Query.prototype.validate = middleware.createWrapper(
        "validate",
        Query.prototype.validate,
        null,
        kareemOptions
      );
      applyQueryMiddleware.middlewareFunctions.filter((v) => v !== "update" && v !== "distinct" && v !== "validate").forEach((fn) => {
        Query.prototype[`_${fn}`] = middleware.createWrapper(
          fn,
          Query.prototype[`_${fn}`],
          null,
          kareemOptions
        );
      });
    }
    function _getContexts(hook) {
      const ret2 = {};
      if (hook.hasOwnProperty("query")) {
        ret2.query = hook.query;
      }
      if (hook.hasOwnProperty("document")) {
        ret2.document = hook.document;
      }
      return ret2;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/model/applyHooks.js
var require_applyHooks = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/model/applyHooks.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var symbols = require_symbols2();
    var promiseOrCallback = require_promiseOrCallback();
    module2.exports = applyHooks;
    applyHooks.middlewareFunctions = [
      "deleteOne",
      "save",
      "validate",
      "remove",
      "updateOne",
      "init"
    ];
    function applyHooks(model, schema, options) {
      options = options || {};
      const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1,
        nullResultByDefault: true,
        contextParameter: true
      };
      const objToDecorate = options.decorateDoc ? model : model.prototype;
      model.$appliedHooks = true;
      for (const key of Object.keys(schema.paths)) {
        const type = schema.paths[key];
        let childModel = null;
        if (type.$isSingleNested) {
          childModel = type.caster;
        } else if (type.$isMongooseDocumentArray) {
          childModel = type.Constructor;
        } else {
          continue;
        }
        if (childModel.$appliedHooks) {
          continue;
        }
        applyHooks(childModel, type.schema, options);
        if (childModel.discriminators != null) {
          const keys = Object.keys(childModel.discriminators);
          for (const key2 of keys) {
            applyHooks(
              childModel.discriminators[key2],
              childModel.discriminators[key2].schema,
              options
            );
          }
        }
      }
      const middleware = schema.s.hooks.filter((hook) => {
        if (hook.name === "updateOne" || hook.name === "deleteOne") {
          return !!hook["document"];
        }
        if (hook.name === "remove" || hook.name === "init") {
          return hook["document"] == null || !!hook["document"];
        }
        if (hook.query != null || hook.document != null) {
          return hook.document !== false;
        }
        return true;
      }).filter((hook) => {
        if (schema.methods[hook.name]) {
          return !hook.fn[symbols.builtInMiddleware];
        }
        return true;
      });
      model._middleware = middleware;
      objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;
      for (const method of ["save", "validate", "remove", "deleteOne"]) {
        const toWrap = method === "validate" ? "$__originalValidate" : `$__${method}`;
        const wrapped = middleware.createWrapper(method, objToDecorate[toWrap], null, kareemOptions);
        objToDecorate[`$__${method}`] = wrapped;
      }
      objToDecorate.$__init = middleware.createWrapperSync("init", objToDecorate.$__init, null, kareemOptions);
      const customMethods = Object.keys(schema.methods);
      const customMethodOptions = Object.assign({}, kareemOptions, {
        // Only use `checkForPromise` for custom methods, because mongoose
        // query thunks are not as consistent as I would like about returning
        // a nullish value rather than the query. If a query thunk returns
        // a query, `checkForPromise` causes infinite recursion
        checkForPromise: true
      });
      for (const method of customMethods) {
        if (!middleware.hasHooks(method)) {
          continue;
        }
        const originalMethod = objToDecorate[method];
        objToDecorate[method] = function() {
          const args = Array.prototype.slice.call(arguments);
          const cb = args.slice(-1).pop();
          const argsWithoutCallback = typeof cb === "function" ? args.slice(0, args.length - 1) : args;
          return promiseOrCallback(cb, (callback) => {
            return this[`$__${method}`].apply(
              this,
              argsWithoutCallback.concat([callback])
            );
          }, model.events);
        };
        objToDecorate[`$__${method}`] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);
      }
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaStringOptions.js
var require_SchemaStringOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaStringOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaStringOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaStringOptions.prototype, "enum", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "match", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "lowercase", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "trim", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "uppercase", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "minLength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "minlength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "maxLength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "maxlength", opts);
    Object.defineProperty(SchemaStringOptions.prototype, "populate", opts);
    module2.exports = SchemaStringOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast/string.js
var require_string = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast/string.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var CastError = require_cast();
    module2.exports = function castString(value, path3) {
      if (value == null) {
        return value;
      }
      if (value._id && typeof value._id === "string") {
        return value._id;
      }
      if (value.toString && value.toString !== Object.prototype.toString && !Array.isArray(value)) {
        return value.toString();
      }
      throw new CastError("string", value, path3);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/string.js
var require_string2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/string.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SchemaType = require_schematype();
    var MongooseError = require_error();
    var SchemaStringOptions = require_SchemaStringOptions();
    var castString = require_string();
    var utils = require_utils2();
    var CastError = SchemaType.CastError;
    function SchemaString(key, options) {
      this.enumValues = [];
      this.regExp = null;
      SchemaType.call(this, key, options, "String");
    }
    SchemaString.schemaName = "String";
    SchemaString.defaultOptions = {};
    SchemaString.prototype = Object.create(SchemaType.prototype);
    SchemaString.prototype.constructor = SchemaString;
    Object.defineProperty(SchemaString.prototype, "OptionsConstructor", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: SchemaStringOptions
    });
    SchemaString._cast = castString;
    SchemaString.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaString._defaultCaster = (v) => {
      if (v != null && typeof v !== "string") {
        throw new Error();
      }
      return v;
    };
    SchemaString.get = SchemaType.get;
    SchemaString.set = SchemaType.set;
    SchemaString._checkRequired = (v) => (v instanceof String || typeof v === "string") && v.length;
    SchemaString.checkRequired = SchemaType.checkRequired;
    SchemaString.prototype.enum = function() {
      if (this.enumValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.enumValidator;
        }, this);
        this.enumValidator = false;
      }
      if (arguments[0] === void 0 || arguments[0] === false) {
        return this;
      }
      let values;
      let errorMessage;
      if (utils.isObject(arguments[0])) {
        if (Array.isArray(arguments[0].values)) {
          values = arguments[0].values;
          errorMessage = arguments[0].message;
        } else {
          values = utils.object.vals(arguments[0]);
          errorMessage = MongooseError.messages.String.enum;
        }
      } else {
        values = arguments;
        errorMessage = MongooseError.messages.String.enum;
      }
      for (const value of values) {
        if (value !== void 0) {
          this.enumValues.push(this.cast(value));
        }
      }
      const vals = this.enumValues;
      this.enumValidator = function(v) {
        return void 0 === v || ~vals.indexOf(v);
      };
      this.validators.push({
        validator: this.enumValidator,
        message: errorMessage,
        type: "enum",
        enumValues: vals
      });
      return this;
    };
    SchemaString.prototype.lowercase = function(shouldApply) {
      if (arguments.length > 0 && !shouldApply) {
        return this;
      }
      return this.set(function(v, self2) {
        if (typeof v !== "string") {
          v = self2.cast(v);
        }
        if (v) {
          return v.toLowerCase();
        }
        return v;
      });
    };
    SchemaString.prototype.uppercase = function(shouldApply) {
      if (arguments.length > 0 && !shouldApply) {
        return this;
      }
      return this.set(function(v, self2) {
        if (typeof v !== "string") {
          v = self2.cast(v);
        }
        if (v) {
          return v.toUpperCase();
        }
        return v;
      });
    };
    SchemaString.prototype.trim = function(shouldTrim) {
      if (arguments.length > 0 && !shouldTrim) {
        return this;
      }
      return this.set(function(v, self2) {
        if (typeof v !== "string") {
          v = self2.cast(v);
        }
        if (v) {
          return v.trim();
        }
        return v;
      });
    };
    SchemaString.prototype.minlength = function(value, message) {
      if (this.minlengthValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.minlengthValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.String.minlength;
        msg = msg.replace(/{MINLENGTH}/, value);
        this.validators.push({
          validator: this.minlengthValidator = function(v) {
            return v === null || v.length >= value;
          },
          message: msg,
          type: "minlength",
          minlength: value
        });
      }
      return this;
    };
    SchemaString.prototype.minLength = SchemaString.prototype.minlength;
    SchemaString.prototype.maxlength = function(value, message) {
      if (this.maxlengthValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.maxlengthValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.String.maxlength;
        msg = msg.replace(/{MAXLENGTH}/, value);
        this.validators.push({
          validator: this.maxlengthValidator = function(v) {
            return v === null || v.length <= value;
          },
          message: msg,
          type: "maxlength",
          maxlength: value
        });
      }
      return this;
    };
    SchemaString.prototype.maxLength = SchemaString.prototype.maxlength;
    SchemaString.prototype.match = function match(regExp, message) {
      const msg = message || MongooseError.messages.String.match;
      const matchValidator = function(v) {
        if (!regExp) {
          return false;
        }
        regExp.lastIndex = 0;
        const ret2 = v != null && v !== "" ? regExp.test(v) : true;
        return ret2;
      };
      this.validators.push({
        validator: matchValidator,
        message: msg,
        type: "regexp",
        regexp: regExp
      });
      return this;
    };
    SchemaString.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : SchemaString.checkRequired();
      return _checkRequired(value);
    };
    SchemaString.prototype.cast = function(value, doc, init) {
      if (SchemaType._isRef(this, value, doc, init)) {
        if (typeof value === "string") {
          return value;
        }
        return this._castRef(value, doc, init);
      }
      let castString2;
      if (typeof this._castFunction === "function") {
        castString2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castString2 = this.constructor.cast();
      } else {
        castString2 = SchemaString.cast();
      }
      try {
        return castString2(value);
      } catch (error) {
        throw new CastError("string", value, this.path, null, this);
      }
    };
    function handleSingle(val) {
      return this.castForQuery(val);
    }
    function handleArray(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.castForQuery(val)];
      }
      return val.map(function(m) {
        return _this.castForQuery(m);
      });
    }
    var $conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
      $all: handleArray,
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle,
      $options: String,
      $regex: handleSingle,
      $not: handleSingle
    });
    Object.defineProperty(SchemaString.prototype, "$conditionalHandlers", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: Object.freeze($conditionalHandlers)
    });
    SchemaString.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional + " with String.");
        }
        return handler.call(this, val);
      }
      val = $conditional;
      if (Object.prototype.toString.call(val) === "[object RegExp]") {
        return val;
      }
      return this._castForQuery(val);
    };
    module2.exports = SchemaString;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaNumberOptions.js
var require_SchemaNumberOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaNumberOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaNumberOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaNumberOptions.prototype, "min", opts);
    Object.defineProperty(SchemaNumberOptions.prototype, "max", opts);
    Object.defineProperty(SchemaNumberOptions.prototype, "enum", opts);
    Object.defineProperty(SchemaNumberOptions.prototype, "populate", opts);
    module2.exports = SchemaNumberOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast/number.js
var require_number = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast/number.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var assert = require("assert");
    module2.exports = function castNumber(val) {
      if (val == null) {
        return val;
      }
      if (val === "") {
        return null;
      }
      if (typeof val === "string" || typeof val === "boolean") {
        val = Number(val);
      }
      assert.ok(!isNaN(val));
      if (val instanceof Number) {
        return val.valueOf();
      }
      if (typeof val === "number") {
        return val;
      }
      if (!Array.isArray(val) && typeof val.valueOf === "function") {
        return Number(val.valueOf());
      }
      if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {
        return Number(val);
      }
      assert.ok(false);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/operators/bitwise.js
var require_bitwise = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/operators/bitwise.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var CastError = require_cast();
    function handleBitwiseOperator(val) {
      const _this = this;
      if (Array.isArray(val)) {
        return val.map(function(v) {
          return _castNumber(_this.path, v);
        });
      } else if (Buffer.isBuffer(val)) {
        return val;
      }
      return _castNumber(_this.path, val);
    }
    function _castNumber(path3, num) {
      const v = Number(num);
      if (isNaN(v)) {
        throw new CastError("number", num, path3);
      }
      return v;
    }
    module2.exports = handleBitwiseOperator;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/number.js
var require_number2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/number.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var SchemaNumberOptions = require_SchemaNumberOptions();
    var SchemaType = require_schematype();
    var castNumber = require_number();
    var handleBitwiseOperator = require_bitwise();
    var utils = require_utils2();
    var CastError = SchemaType.CastError;
    function SchemaNumber(key, options) {
      SchemaType.call(this, key, options, "Number");
    }
    SchemaNumber.get = SchemaType.get;
    SchemaNumber.set = SchemaType.set;
    SchemaNumber._cast = castNumber;
    SchemaNumber.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaNumber._defaultCaster = (v) => {
      if (typeof v !== "number") {
        throw new Error();
      }
      return v;
    };
    SchemaNumber.schemaName = "Number";
    SchemaNumber.defaultOptions = {};
    SchemaNumber.prototype = Object.create(SchemaType.prototype);
    SchemaNumber.prototype.constructor = SchemaNumber;
    SchemaNumber.prototype.OptionsConstructor = SchemaNumberOptions;
    SchemaNumber._checkRequired = (v) => typeof v === "number" || v instanceof Number;
    SchemaNumber.checkRequired = SchemaType.checkRequired;
    SchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : SchemaNumber.checkRequired();
      return _checkRequired(value);
    };
    SchemaNumber.prototype.min = function(value, message) {
      if (this.minValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.minValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.Number.min;
        msg = msg.replace(/{MIN}/, value);
        this.validators.push({
          validator: this.minValidator = function(v) {
            return v == null || v >= value;
          },
          message: msg,
          type: "min",
          min: value
        });
      }
      return this;
    };
    SchemaNumber.prototype.max = function(value, message) {
      if (this.maxValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.maxValidator;
        }, this);
      }
      if (value !== null && value !== void 0) {
        let msg = message || MongooseError.messages.Number.max;
        msg = msg.replace(/{MAX}/, value);
        this.validators.push({
          validator: this.maxValidator = function(v) {
            return v == null || v <= value;
          },
          message: msg,
          type: "max",
          max: value
        });
      }
      return this;
    };
    SchemaNumber.prototype.enum = function(values, message) {
      if (this.enumValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.enumValidator;
        }, this);
      }
      if (!Array.isArray(values)) {
        if (utils.isObject(values)) {
          values = utils.object.vals(values);
        } else {
          values = Array.prototype.slice.call(arguments);
        }
        message = MongooseError.messages.Number.enum;
      }
      message = message == null ? MongooseError.messages.Number.enum : message;
      this.enumValidator = (v) => v == null || values.indexOf(v) !== -1;
      this.validators.push({
        validator: this.enumValidator,
        message,
        type: "enum",
        enumValues: values
      });
      return this;
    };
    SchemaNumber.prototype.cast = function(value, doc, init) {
      if (SchemaType._isRef(this, value, doc, init)) {
        if (typeof value === "number") {
          return value;
        }
        return this._castRef(value, doc, init);
      }
      const val = value && typeof value._id !== "undefined" ? value._id : (
        // documents
        value
      );
      let castNumber2;
      if (typeof this._castFunction === "function") {
        castNumber2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castNumber2 = this.constructor.cast();
      } else {
        castNumber2 = SchemaNumber.cast();
      }
      try {
        return castNumber2(val);
      } catch (err) {
        throw new CastError("Number", val, this.path, err, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    function handleArray(val) {
      const _this = this;
      if (!Array.isArray(val)) {
        return [this.cast(val)];
      }
      return val.map(function(m) {
        return _this.cast(m);
      });
    }
    SchemaNumber.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
      $bitsAllClear: handleBitwiseOperator,
      $bitsAnyClear: handleBitwiseOperator,
      $bitsAllSet: handleBitwiseOperator,
      $bitsAnySet: handleBitwiseOperator,
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle,
      $mod: handleArray
    });
    SchemaNumber.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new CastError("number", val, this.path, null, this);
        }
        return handler.call(this, val);
      }
      val = this._castForQuery($conditional);
      return val;
    };
    module2.exports = SchemaNumber;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/boolean.js
var require_boolean2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/boolean.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var CastError = require_cast();
    var SchemaType = require_schematype();
    var castBoolean = require_boolean();
    var utils = require_utils2();
    function SchemaBoolean(path3, options) {
      SchemaType.call(this, path3, options, "Boolean");
    }
    SchemaBoolean.schemaName = "Boolean";
    SchemaBoolean.defaultOptions = {};
    SchemaBoolean.prototype = Object.create(SchemaType.prototype);
    SchemaBoolean.prototype.constructor = SchemaBoolean;
    SchemaBoolean._cast = castBoolean;
    SchemaBoolean.set = SchemaType.set;
    SchemaBoolean.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaBoolean._defaultCaster = (v) => {
      if (v != null && typeof v !== "boolean") {
        throw new Error();
      }
      return v;
    };
    SchemaBoolean._checkRequired = (v) => v === true || v === false;
    SchemaBoolean.checkRequired = SchemaType.checkRequired;
    SchemaBoolean.prototype.checkRequired = function(value) {
      return this.constructor._checkRequired(value);
    };
    Object.defineProperty(SchemaBoolean, "convertToTrue", {
      get: () => castBoolean.convertToTrue,
      set: (v) => {
        castBoolean.convertToTrue = v;
      }
    });
    Object.defineProperty(SchemaBoolean, "convertToFalse", {
      get: () => castBoolean.convertToFalse,
      set: (v) => {
        castBoolean.convertToFalse = v;
      }
    });
    SchemaBoolean.prototype.cast = function(value) {
      let castBoolean2;
      if (typeof this._castFunction === "function") {
        castBoolean2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castBoolean2 = this.constructor.cast();
      } else {
        castBoolean2 = SchemaBoolean.cast();
      }
      try {
        return castBoolean2(value);
      } catch (error) {
        throw new CastError("Boolean", value, this.path, error, this);
      }
    };
    SchemaBoolean.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {});
    SchemaBoolean.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = SchemaBoolean.$conditionalHandlers[$conditional];
        if (handler) {
          return handler.call(this, val);
        }
        return this._castForQuery(val);
      }
      return this._castForQuery($conditional);
    };
    SchemaBoolean.prototype._castNullish = function _castNullish(v) {
      if (typeof v === "undefined" && this.$$context != null && this.$$context._mongooseOptions != null && this.$$context._mongooseOptions.omitUndefined) {
        return v;
      }
      const castBoolean2 = typeof this.constructor.cast === "function" ? this.constructor.cast() : SchemaBoolean.cast();
      if (castBoolean2 == null) {
        return v;
      }
      if (castBoolean2.convertToFalse instanceof Set && castBoolean2.convertToFalse.has(v)) {
        return false;
      }
      if (castBoolean2.convertToTrue instanceof Set && castBoolean2.convertToTrue.has(v)) {
        return true;
      }
      return v;
    };
    module2.exports = SchemaBoolean;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaArrayOptions.js
var require_SchemaArrayOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaArrayOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaArrayOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaArrayOptions.prototype, "enum", opts);
    Object.defineProperty(SchemaArrayOptions.prototype, "of", opts);
    module2.exports = SchemaArrayOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/arrayDepth.js
var require_arrayDepth = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/arrayDepth.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = arrayDepth;
    function arrayDepth(arr) {
      if (!Array.isArray(arr)) {
        return { min: 0, max: 0, containsNonArrayItem: true };
      }
      if (arr.length === 0) {
        return { min: 1, max: 1, containsNonArrayItem: false };
      }
      if (arr.length === 1 && !Array.isArray(arr[0])) {
        return { min: 1, max: 1, containsNonArrayItem: false };
      }
      const res = arrayDepth(arr[0]);
      for (let i = 1; i < arr.length; ++i) {
        const _res = arrayDepth(arr[i]);
        if (_res.min < res.min) {
          res.min = _res.min;
        }
        if (_res.max > res.max) {
          res.max = _res.max;
        }
        res.containsNonArrayItem = res.containsNonArrayItem || _res.containsNonArrayItem;
      }
      res.min = res.min + 1;
      res.max = res.max + 1;
      return res;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/operators/text.js
var require_text = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/operators/text.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var CastError = require_cast();
    var castBoolean = require_boolean();
    var castString = require_string();
    module2.exports = function(val, path3) {
      if (val == null || typeof val !== "object") {
        throw new CastError("$text", val, path3);
      }
      if (val.$search != null) {
        val.$search = castString(val.$search, path3 + ".$search");
      }
      if (val.$language != null) {
        val.$language = castString(val.$language, path3 + ".$language");
      }
      if (val.$caseSensitive != null) {
        val.$caseSensitive = castBoolean(
          val.$caseSensitive,
          path3 + ".$castSensitive"
        );
      }
      if (val.$diacriticSensitive != null) {
        val.$diacriticSensitive = castBoolean(
          val.$diacriticSensitive,
          path3 + ".$diacriticSensitive"
        );
      }
      return val;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js
var require_areDiscriminatorValuesEqual = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ObjectId2 = require_objectid2();
    module2.exports = function areDiscriminatorValuesEqual(a, b) {
      if (typeof a === "string" && typeof b === "string") {
        return a === b;
      }
      if (typeof a === "number" && typeof b === "number") {
        return a === b;
      }
      if (a instanceof ObjectId2 && b instanceof ObjectId2) {
        return a.toString() === b.toString();
      }
      return false;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js
var require_getSchemaDiscriminatorByValue = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
    module2.exports = function getSchemaDiscriminatorByValue(schema, value) {
      if (schema == null || schema.discriminators == null) {
        return null;
      }
      for (const key of Object.keys(schema.discriminators)) {
        const discriminatorSchema = schema.discriminators[key];
        if (discriminatorSchema.discriminatorMapping == null) {
          continue;
        }
        if (areDiscriminatorValuesEqual(discriminatorSchema.discriminatorMapping.value, value)) {
          return discriminatorSchema;
        }
      }
      return null;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/isOperator.js
var require_isOperator = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/isOperator.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var specialKeys = /* @__PURE__ */ new Set([
      "$ref",
      "$id",
      "$db"
    ]);
    module2.exports = function isOperator(path3) {
      return path3.startsWith("$") && !specialKeys.has(path3);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast.js
var require_cast2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var CastError = require_cast();
    var StrictModeError = require_strict();
    var Types2 = require_schema();
    var castTextSearch = require_text();
    var get = require_get();
    var getConstructorName = require_getConstructorName();
    var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
    var isOperator = require_isOperator();
    var util2 = require("util");
    var isObject3 = require_isObject();
    var isMongooseObject = require_isMongooseObject();
    var ALLOWED_GEOWITHIN_GEOJSON_TYPES = ["Polygon", "MultiPolygon"];
    module2.exports = function cast(schema, obj2, options, context) {
      if (Array.isArray(obj2)) {
        throw new Error("Query filter must be an object, got an array ", util2.inspect(obj2));
      }
      if (obj2 == null) {
        return obj2;
      }
      if (obj2.hasOwnProperty("_bsontype") && obj2._bsontype !== "ObjectID") {
        delete obj2._bsontype;
      }
      if (schema != null && schema.discriminators != null && obj2[schema.options.discriminatorKey] != null) {
        schema = getSchemaDiscriminatorByValue(schema, obj2[schema.options.discriminatorKey]) || schema;
      }
      const paths = Object.keys(obj2);
      let i = paths.length;
      let _keys;
      let any$conditionals;
      let schematype;
      let nested;
      let path3;
      let type;
      let val;
      options = options || {};
      while (i--) {
        path3 = paths[i];
        val = obj2[path3];
        if (path3 === "$or" || path3 === "$nor" || path3 === "$and") {
          if (!Array.isArray(val)) {
            throw new CastError("Array", val, path3);
          }
          for (let k = 0; k < val.length; ++k) {
            if (val[k] == null || typeof val[k] !== "object") {
              throw new CastError("Object", val[k], path3 + "." + k);
            }
            val[k] = cast(schema, val[k], options, context);
          }
        } else if (path3 === "$where") {
          type = typeof val;
          if (type !== "string" && type !== "function") {
            throw new Error("Must have a string or function for $where");
          }
          if (type === "function") {
            obj2[path3] = val.toString();
          }
          continue;
        } else if (path3 === "$elemMatch") {
          val = cast(schema, val, options, context);
        } else if (path3 === "$text") {
          val = castTextSearch(val, path3);
        } else {
          if (!schema) {
            continue;
          }
          schematype = schema.path(path3);
          if (!schematype) {
            const split = path3.split(".");
            let j = split.length;
            while (j--) {
              const pathFirstHalf = split.slice(0, j).join(".");
              const pathLastHalf = split.slice(j).join(".");
              const _schematype = schema.path(pathFirstHalf);
              const discriminatorKey = get(_schematype, "schema.options.discriminatorKey");
              if (_schematype != null && get(_schematype, "schema.discriminators") != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {
                const discriminatorVal = get(obj2, pathFirstHalf + "." + discriminatorKey);
                if (discriminatorVal != null) {
                  schematype = _schematype.schema.discriminators[discriminatorVal].path(pathLastHalf);
                }
              }
            }
          }
          if (!schematype) {
            const split = path3.split(".");
            let j = split.length;
            let pathFirstHalf;
            let pathLastHalf;
            let remainingConds;
            while (j--) {
              pathFirstHalf = split.slice(0, j).join(".");
              schematype = schema.path(pathFirstHalf);
              if (schematype) {
                break;
              }
            }
            if (schematype) {
              if (schematype.caster && schematype.caster.schema) {
                remainingConds = {};
                pathLastHalf = split.slice(j).join(".");
                remainingConds[pathLastHalf] = val;
                obj2[path3] = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];
              } else {
                obj2[path3] = val;
              }
              continue;
            }
            if (isObject3(val)) {
              let geo = "";
              if (val.$near) {
                geo = "$near";
              } else if (val.$nearSphere) {
                geo = "$nearSphere";
              } else if (val.$within) {
                geo = "$within";
              } else if (val.$geoIntersects) {
                geo = "$geoIntersects";
              } else if (val.$geoWithin) {
                geo = "$geoWithin";
              }
              if (geo) {
                const numbertype = new Types2.Number("__QueryCasting__");
                let value = val[geo];
                if (val.$maxDistance != null) {
                  val.$maxDistance = numbertype.castForQueryWrapper({
                    val: val.$maxDistance,
                    context
                  });
                }
                if (val.$minDistance != null) {
                  val.$minDistance = numbertype.castForQueryWrapper({
                    val: val.$minDistance,
                    context
                  });
                }
                if (geo === "$within") {
                  const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;
                  if (!withinType) {
                    throw new Error("Bad $within parameter: " + JSON.stringify(val));
                  }
                  value = withinType;
                } else if (geo === "$near" && typeof value.type === "string" && Array.isArray(value.coordinates)) {
                  value = value.coordinates;
                } else if ((geo === "$near" || geo === "$nearSphere" || geo === "$geoIntersects") && value.$geometry && typeof value.$geometry.type === "string" && Array.isArray(value.$geometry.coordinates)) {
                  if (value.$maxDistance != null) {
                    value.$maxDistance = numbertype.castForQueryWrapper({
                      val: value.$maxDistance,
                      context
                    });
                  }
                  if (value.$minDistance != null) {
                    value.$minDistance = numbertype.castForQueryWrapper({
                      val: value.$minDistance,
                      context
                    });
                  }
                  if (isMongooseObject(value.$geometry)) {
                    value.$geometry = value.$geometry.toObject({
                      transform: false,
                      virtuals: false
                    });
                  }
                  value = value.$geometry.coordinates;
                } else if (geo === "$geoWithin") {
                  if (value.$geometry) {
                    if (isMongooseObject(value.$geometry)) {
                      value.$geometry = value.$geometry.toObject({ virtuals: false });
                    }
                    const geoWithinType = value.$geometry.type;
                    if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {
                      throw new Error('Invalid geoJSON type for $geoWithin "' + geoWithinType + '", must be "Polygon" or "MultiPolygon"');
                    }
                    value = value.$geometry.coordinates;
                  } else {
                    value = value.$box || value.$polygon || value.$center || value.$centerSphere;
                    if (isMongooseObject(value)) {
                      value = value.toObject({ virtuals: false });
                    }
                  }
                }
                _cast(value, numbertype, context);
                continue;
              }
            }
            if (schema.nested[path3]) {
              continue;
            }
            if (options.upsert && options.strict) {
              if (options.strict === "throw") {
                throw new StrictModeError(path3);
              }
              throw new StrictModeError(path3, 'Path "' + path3 + '" is not in schema, strict mode is `true`, and upsert is `true`.');
            } else if (options.strictQuery === "throw") {
              throw new StrictModeError(path3, 'Path "' + path3 + `" is not in schema and strictQuery is 'throw'.`);
            } else if (options.strictQuery) {
              delete obj2[path3];
            }
          } else if (val == null) {
            continue;
          } else if (getConstructorName(val) === "Object") {
            any$conditionals = Object.keys(val).some(isOperator);
            if (!any$conditionals) {
              obj2[path3] = schematype.castForQueryWrapper({
                val,
                context
              });
            } else {
              const ks = Object.keys(val);
              let $cond;
              let k = ks.length;
              while (k--) {
                $cond = ks[k];
                nested = val[$cond];
                if ($cond === "$not") {
                  if (nested && schematype && !schematype.caster) {
                    _keys = Object.keys(nested);
                    if (_keys.length && isOperator(_keys[0])) {
                      for (const key in nested) {
                        nested[key] = schematype.castForQueryWrapper({
                          $conditional: key,
                          val: nested[key],
                          context
                        });
                      }
                    } else {
                      val[$cond] = schematype.castForQueryWrapper({
                        $conditional: $cond,
                        val: nested,
                        context
                      });
                    }
                    continue;
                  }
                  cast(schematype.caster ? schematype.caster.schema : schema, nested, options, context);
                } else {
                  val[$cond] = schematype.castForQueryWrapper({
                    $conditional: $cond,
                    val: nested,
                    context
                  });
                }
              }
            }
          } else if (Array.isArray(val) && ["Buffer", "Array"].indexOf(schematype.instance) === -1) {
            const casted = [];
            const valuesArray = val;
            for (const _val of valuesArray) {
              casted.push(schematype.castForQueryWrapper({
                val: _val,
                context
              }));
            }
            obj2[path3] = { $in: casted };
          } else {
            obj2[path3] = schematype.castForQueryWrapper({
              val,
              context
            });
          }
        }
      }
      return obj2;
    };
    function _cast(val, numbertype, context) {
      if (Array.isArray(val)) {
        val.forEach(function(item, i) {
          if (Array.isArray(item) || isObject3(item)) {
            return _cast(item, numbertype, context);
          }
          val[i] = numbertype.castForQueryWrapper({ val: item, context });
        });
      } else {
        const nearKeys = Object.keys(val);
        let nearLen = nearKeys.length;
        while (nearLen--) {
          const nkey = nearKeys[nearLen];
          const item = val[nkey];
          if (Array.isArray(item) || isObject3(item)) {
            _cast(item, numbertype, context);
            val[nkey] = item;
          } else {
            val[nkey] = numbertype.castForQuery({ val: item, context });
          }
        }
      }
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/operators/helpers.js
var require_helpers = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/operators/helpers.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var SchemaNumber = require_number2();
    exports2.castToNumber = castToNumber;
    exports2.castArraysOfNumbers = castArraysOfNumbers;
    function castToNumber(val) {
      return SchemaNumber.cast()(val);
    }
    function castArraysOfNumbers(arr, self2) {
      arr.forEach(function(v, i) {
        if (Array.isArray(v)) {
          castArraysOfNumbers(v, self2);
        } else {
          arr[i] = castToNumber.call(self2, v);
        }
      });
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/operators/geospatial.js
var require_geospatial = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/operators/geospatial.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var castArraysOfNumbers = require_helpers().castArraysOfNumbers;
    var castToNumber = require_helpers().castToNumber;
    exports2.cast$geoIntersects = cast$geoIntersects;
    exports2.cast$near = cast$near;
    exports2.cast$within = cast$within;
    function cast$near(val) {
      const SchemaArray = require_array2();
      if (Array.isArray(val)) {
        castArraysOfNumbers(val, this);
        return val;
      }
      _castMinMaxDistance(this, val);
      if (val && val.$geometry) {
        return cast$geometry(val, this);
      }
      if (!Array.isArray(val)) {
        throw new TypeError("$near must be either an array or an object with a $geometry property");
      }
      return SchemaArray.prototype.castForQuery.call(this, val);
    }
    function cast$geometry(val, self2) {
      switch (val.$geometry.type) {
        case "Polygon":
        case "LineString":
        case "Point":
          castArraysOfNumbers(val.$geometry.coordinates, self2);
          break;
        default:
          break;
      }
      _castMinMaxDistance(self2, val);
      return val;
    }
    function cast$within(val) {
      _castMinMaxDistance(this, val);
      if (val.$box || val.$polygon) {
        const type = val.$box ? "$box" : "$polygon";
        val[type].forEach((arr) => {
          if (!Array.isArray(arr)) {
            const msg = "Invalid $within $box argument. Expected an array, received " + arr;
            throw new TypeError(msg);
          }
          arr.forEach((v, i) => {
            arr[i] = castToNumber.call(this, v);
          });
        });
      } else if (val.$center || val.$centerSphere) {
        const type = val.$center ? "$center" : "$centerSphere";
        val[type].forEach((item, i) => {
          if (Array.isArray(item)) {
            item.forEach((v, j) => {
              item[j] = castToNumber.call(this, v);
            });
          } else {
            val[type][i] = castToNumber.call(this, item);
          }
        });
      } else if (val.$geometry) {
        cast$geometry(val, this);
      }
      return val;
    }
    function cast$geoIntersects(val) {
      const geo = val.$geometry;
      if (!geo) {
        return;
      }
      cast$geometry(val, this);
      return val;
    }
    function _castMinMaxDistance(self2, val) {
      if (val.$maxDistance) {
        val.$maxDistance = castToNumber.call(self2, val.$maxDistance);
      }
      if (val.$minDistance) {
        val.$minDistance = castToNumber.call(self2, val.$minDistance);
      }
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js
var require_getDiscriminatorByValue = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
    module2.exports = function getDiscriminatorByValue(discriminators, value) {
      if (discriminators == null) {
        return null;
      }
      for (const name of Object.keys(discriminators)) {
        const it = discriminators[name];
        if (it.schema && it.schema.discriminatorMapping && areDiscriminatorValuesEqual(it.schema.discriminatorMapping.value, value)) {
          return it;
        }
      }
      return null;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/browserDocument.js
var require_browserDocument = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/browserDocument.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var NodeJSDocument = require_document();
    var EventEmitter = require("events").EventEmitter;
    var MongooseError = require_error();
    var Schema6 = require_schema2();
    var ObjectId2 = require_objectid2();
    var ValidationError = MongooseError.ValidationError;
    var applyHooks = require_applyHooks();
    var isObject3 = require_isObject();
    function Document6(obj2, schema, fields, skipId, skipInit) {
      if (!(this instanceof Document6)) {
        return new Document6(obj2, schema, fields, skipId, skipInit);
      }
      if (isObject3(schema) && !schema.instanceOfSchema) {
        schema = new Schema6(schema);
      }
      schema = this.schema || schema;
      if (!this.schema && schema.options._id) {
        obj2 = obj2 || {};
        if (obj2._id === void 0) {
          obj2._id = new ObjectId2();
        }
      }
      if (!schema) {
        throw new MongooseError.MissingSchemaError();
      }
      this.$__setSchema(schema);
      NodeJSDocument.call(this, obj2, fields, skipId, skipInit);
      applyHooks(this, schema, { decorateDoc: true });
      for (const m in schema.methods) {
        this[m] = schema.methods[m];
      }
      for (const s in schema.statics) {
        this[s] = schema.statics[s];
      }
    }
    Document6.prototype = Object.create(NodeJSDocument.prototype);
    Document6.prototype.constructor = Document6;
    Document6.events = new EventEmitter();
    Document6.$emitter = new EventEmitter();
    [
      "on",
      "once",
      "emit",
      "listeners",
      "removeListener",
      "setMaxListeners",
      "removeAllListeners",
      "addListener"
    ].forEach(function(emitterFn) {
      Document6[emitterFn] = function() {
        return Document6.$emitter[emitterFn].apply(Document6.$emitter, arguments);
      };
    });
    Document6.ValidationError = ValidationError;
    module2.exports = exports2 = Document6;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/document_provider.js
var require_document_provider = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/document_provider.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Document6 = require_document();
    var BrowserDocument = require_browserDocument();
    var isBrowser = false;
    module2.exports = function() {
      if (isBrowser) {
        return BrowserDocument;
      }
      return Document6;
    };
    module2.exports.setBrowser = function(flag) {
      isBrowser = flag;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options.js
var require_options = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options.js"(exports2) {
    "use strict";
    init_cjs_shims();
    exports2.internalToObjectOptions = {
      transform: false,
      virtuals: false,
      getters: false,
      _skipDepopulateTopLevel: true,
      depopulate: true,
      flattenDecimals: false,
      useProjection: false
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/embedded.js
var require_embedded = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/embedded.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Document6 = require_document_provider()();
    var EventEmitter = require("events").EventEmitter;
    var ValidationError = require_validation();
    var immediate = require_immediate();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var get = require_get();
    var promiseOrCallback = require_promiseOrCallback();
    var util2 = require("util");
    var documentArrayParent = require_symbols().documentArrayParent;
    var validatorErrorSymbol = require_symbols().validatorErrorSymbol;
    function EmbeddedDocument(obj2, parentArr, skipId, fields, index) {
      const options = {};
      if (parentArr != null && parentArr.isMongooseDocumentArray) {
        this.__parentArray = parentArr;
        this[documentArrayParent] = parentArr.$parent();
      } else {
        this.__parentArray = void 0;
        this[documentArrayParent] = void 0;
      }
      this.$setIndex(index);
      this.$isDocumentArrayElement = true;
      if (this[documentArrayParent] != null) {
        options.defaults = this[documentArrayParent].$__.$options.defaults;
      }
      Document6.call(this, obj2, fields, skipId, options);
      const _this = this;
      this.on("isNew", function(val) {
        _this.isNew = val;
      });
      _this.on("save", function() {
        _this.constructor.emit("save", _this);
      });
    }
    EmbeddedDocument.prototype = Object.create(Document6.prototype);
    EmbeddedDocument.prototype.constructor = EmbeddedDocument;
    for (const i in EventEmitter.prototype) {
      EmbeddedDocument[i] = EventEmitter.prototype[i];
    }
    EmbeddedDocument.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    EmbeddedDocument.prototype.$setIndex = function(index) {
      this.__index = index;
      if (get(this, "$__.validationError", null) != null) {
        const keys = Object.keys(this.$__.validationError.errors);
        for (const key of keys) {
          this.invalidate(key, this.$__.validationError.errors[key]);
        }
      }
    };
    EmbeddedDocument.prototype.markModified = function(path3) {
      this.$__.activePaths.modify(path3);
      if (!this.__parentArray) {
        return;
      }
      const pathToCheck = this.__parentArray.$path() + ".0." + path3;
      if (this.isNew && this.ownerDocument().$__isSelected(pathToCheck)) {
        this.__parentArray._markModified();
      } else {
        this.__parentArray._markModified(this, path3);
      }
    };
    EmbeddedDocument.prototype.populate = function() {
      throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.arr[0].populate("path")`, use `doc.populate("arr.0.path")`');
    };
    EmbeddedDocument.prototype.save = function(options, fn) {
      if (typeof options === "function") {
        fn = options;
        options = {};
      }
      options = options || {};
      if (!options.suppressWarning) {
        console.warn("mongoose: calling `save()` on a subdoc does **not** save the document to MongoDB, it only runs save middleware. Use `subdoc.save({ suppressWarning: true })` to hide this warning if you're sure this behavior is right for your app.");
      }
      return promiseOrCallback(fn, (cb) => {
        this.$__save(cb);
      });
    };
    EmbeddedDocument.prototype.$__save = function(fn) {
      return immediate(() => fn(null, this));
    };
    function registerRemoveListener(sub) {
      let owner = sub.ownerDocument();
      function emitRemove() {
        owner.removeListener("save", emitRemove);
        owner.removeListener("remove", emitRemove);
        sub.emit("remove", sub);
        sub.constructor.emit("remove", sub);
        owner = sub = null;
      }
      owner.on("save", emitRemove);
      owner.on("remove", emitRemove);
    }
    EmbeddedDocument.prototype.$__remove = function(cb) {
      if (cb == null) {
        return;
      }
      return cb(null, this);
    };
    EmbeddedDocument.prototype.remove = function(options, fn) {
      if (typeof options === "function" && !fn) {
        fn = options;
        options = void 0;
      }
      if (!this.__parentArray || options && options.noop) {
        this.$__remove(fn);
        return this;
      }
      let _id;
      if (!this.willRemove) {
        _id = this._doc._id;
        if (!_id) {
          throw new Error("For your own good, Mongoose does not know how to remove an EmbeddedDocument that has no _id");
        }
        this.__parentArray.pull({ _id });
        this.willRemove = true;
        registerRemoveListener(this);
      }
      this.$__remove(fn);
      return this;
    };
    EmbeddedDocument.prototype.update = function() {
      throw new Error("The #update method is not available on EmbeddedDocuments");
    };
    EmbeddedDocument.prototype.inspect = function() {
      return this.toObject({
        transform: false,
        virtuals: false,
        flattenDecimals: false
      });
    };
    if (util2.inspect.custom) {
      EmbeddedDocument.prototype[util2.inspect.custom] = EmbeddedDocument.prototype.inspect;
    }
    EmbeddedDocument.prototype.invalidate = function(path3, err, val) {
      Document6.prototype.invalidate.call(this, path3, err, val);
      if (!this[documentArrayParent] || this.__index == null) {
        if (err[validatorErrorSymbol] || err instanceof ValidationError) {
          return this.ownerDocument().$__.validationError;
        }
        throw err;
      }
      const index = this.__index;
      const parentPath = this.__parentArray.$path();
      const fullPath = [parentPath, index, path3].join(".");
      this[documentArrayParent].invalidate(fullPath, err, val);
      return this.ownerDocument().$__.validationError;
    };
    EmbeddedDocument.prototype.$markValid = function(path3) {
      if (!this[documentArrayParent]) {
        return;
      }
      const index = this.__index;
      if (typeof index !== "undefined") {
        const parentPath = this.__parentArray.$path();
        const fullPath = [parentPath, index, path3].join(".");
        this[documentArrayParent].$markValid(fullPath);
      }
    };
    EmbeddedDocument.prototype.$ignore = function(path3) {
      Document6.prototype.$ignore.call(this, path3);
      if (!this[documentArrayParent]) {
        return;
      }
      const index = this.__index;
      if (typeof index !== "undefined") {
        const parentPath = this.__parentArray.$path();
        const fullPath = [parentPath, index, path3].join(".");
        this[documentArrayParent].$ignore(fullPath);
      }
    };
    EmbeddedDocument.prototype.$isValid = function(path3) {
      const index = this.__index;
      if (typeof index !== "undefined" && this[documentArrayParent]) {
        return !this[documentArrayParent].$__.validationError || !this[documentArrayParent].$__.validationError.errors[this.$__fullPath(path3)];
      }
      return true;
    };
    EmbeddedDocument.prototype.ownerDocument = function() {
      if (this.$__.ownerDocument) {
        return this.$__.ownerDocument;
      }
      let parent = this[documentArrayParent];
      if (!parent) {
        return this;
      }
      while (parent[documentArrayParent] || parent.$__parent) {
        parent = parent[documentArrayParent] || parent.$__parent;
      }
      this.$__.ownerDocument = parent;
      return this.$__.ownerDocument;
    };
    EmbeddedDocument.prototype.$__fullPath = function(path3) {
      if (!this.$__.fullPath) {
        let parent = this;
        if (!parent[documentArrayParent]) {
          return path3;
        }
        const paths = [];
        while (parent[documentArrayParent] || parent.$__parent) {
          if (parent[documentArrayParent]) {
            paths.unshift(parent.__parentArray.$path());
          } else {
            paths.unshift(parent.$basePath);
          }
          parent = parent[documentArrayParent] || parent.$__parent;
        }
        this.$__.fullPath = paths.join(".");
        if (!this.$__.ownerDocument) {
          this.$__.ownerDocument = parent;
        }
      }
      return path3 ? this.$__.fullPath + "." + path3 : this.$__.fullPath;
    };
    EmbeddedDocument.prototype.parent = function() {
      return this[documentArrayParent];
    };
    EmbeddedDocument.prototype.$parent = EmbeddedDocument.prototype.parent;
    EmbeddedDocument.prototype.parentArray = function() {
      return this.__parentArray;
    };
    module2.exports = EmbeddedDocument;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js
var require_cleanModifiedSubpaths = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function cleanModifiedSubpaths(doc, path3, options) {
      options = options || {};
      const skipDocArrays = options.skipDocArrays;
      let deleted = 0;
      if (!doc) {
        return deleted;
      }
      for (const modifiedPath of Object.keys(doc.$__.activePaths.states.modify)) {
        if (skipDocArrays) {
          const schemaType = doc.$__schema.path(modifiedPath);
          if (schemaType && schemaType.$isMongooseDocumentArray) {
            continue;
          }
        }
        if (modifiedPath.startsWith(path3 + ".")) {
          delete doc.$__.activePaths.states.modify[modifiedPath];
          ++deleted;
        }
      }
      return deleted;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/core_array.js
var require_core_array = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/core_array.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Document6 = require_document();
    var EmbeddedDocument = require_embedded();
    var MongooseError = require_mongooseError();
    var ObjectId2 = require_objectid2();
    var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
    var get = require_get();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var utils = require_utils2();
    var util2 = require("util");
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var slicedSymbol = Symbol("mongoose#Array#sliced");
    var _basePush = Array.prototype.push;
    var validatorsSymbol = Symbol("mongoose#MongooseCoreArray#validators");
    var CoreMongooseArray = class extends Array {
      get isMongooseArray() {
        return true;
      }
      get validators() {
        return this[validatorsSymbol];
      }
      set validators(v) {
        this[validatorsSymbol] = v;
      }
      /**
       * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.
       *
       * If no atomics exist, we return all array values after conversion.
       *
       * @return {Array}
       * @method $__getAtomics
       * @memberOf MongooseArray
       * @instance
       * @api private
       */
      $__getAtomics() {
        const ret2 = [];
        const keys = Object.keys(this[arrayAtomicsSymbol] || {});
        let i = keys.length;
        const opts = Object.assign({}, internalToObjectOptions, { _isNested: true });
        if (i === 0) {
          ret2[0] = ["$set", this.toObject(opts)];
          return ret2;
        }
        while (i--) {
          const op = keys[i];
          let val = this[arrayAtomicsSymbol][op];
          if (utils.isMongooseObject(val)) {
            val = val.toObject(opts);
          } else if (Array.isArray(val)) {
            val = this.toObject.call(val, opts);
          } else if (val != null && Array.isArray(val.$each)) {
            val.$each = this.toObject.call(val.$each, opts);
          } else if (val != null && typeof val.valueOf === "function") {
            val = val.valueOf();
          }
          if (op === "$addToSet") {
            val = { $each: val };
          }
          ret2.push([op, val]);
        }
        return ret2;
      }
      /*!
       * ignore
       */
      $atomics() {
        return this[arrayAtomicsSymbol] || {};
      }
      /*!
       * ignore
       */
      $parent() {
        return this[arrayParentSymbol];
      }
      /*!
       * ignore
       */
      $path() {
        return this[arrayPathSymbol];
      }
      /**
       * Atomically shifts the array at most one time per document `save()`.
       *
       * ####NOTE:
       *
       * _Calling this multiple times on an array before saving sends the same command as calling it once._
       * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
       *
       *      doc.array = [1,2,3];
       *
       *      const shifted = doc.array.$shift();
       *      console.log(shifted); // 1
       *      console.log(doc.array); // [2,3]
       *
       *      // no affect
       *      shifted = doc.array.$shift();
       *      console.log(doc.array); // [2,3]
       *
       *      doc.save(function (err) {
       *        if (err) return handleError(err);
       *
       *        // we saved, now $shift works again
       *        shifted = doc.array.$shift();
       *        console.log(shifted ); // 2
       *        console.log(doc.array); // [3]
       *      })
       *
       * @api public
       * @memberOf MongooseArray
       * @instance
       * @method $shift
       * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
       */
      $shift() {
        this._registerAtomic("$pop", -1);
        this._markModified();
        if (this._shifted) {
          return;
        }
        this._shifted = true;
        return [].shift.call(this);
      }
      /**
       * Pops the array atomically at most one time per document `save()`.
       *
       * #### NOTE:
       *
       * _Calling this mulitple times on an array before saving sends the same command as calling it once._
       * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._
       *
       *      doc.array = [1,2,3];
       *
       *      const popped = doc.array.$pop();
       *      console.log(popped); // 3
       *      console.log(doc.array); // [1,2]
       *
       *      // no affect
       *      popped = doc.array.$pop();
       *      console.log(doc.array); // [1,2]
       *
       *      doc.save(function (err) {
       *        if (err) return handleError(err);
       *
       *        // we saved, now $pop works again
       *        popped = doc.array.$pop();
       *        console.log(popped); // 2
       *        console.log(doc.array); // [1]
       *      })
       *
       * @api public
       * @method $pop
       * @memberOf MongooseArray
       * @instance
       * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop
       * @method $pop
       * @memberOf MongooseArray
       */
      $pop() {
        this._registerAtomic("$pop", 1);
        this._markModified();
        if (this._popped) {
          return;
        }
        this._popped = true;
        return [].pop.call(this);
      }
      /*!
       * ignore
       */
      $schema() {
        return this[arraySchemaSymbol];
      }
      /**
       * Casts a member based on this arrays schema.
       *
       * @param {any} value
       * @return value the casted value
       * @method _cast
       * @api private
       * @memberOf MongooseArray
       */
      _cast(value) {
        let populated = false;
        let Model6;
        if (this[arrayParentSymbol]) {
          populated = this[arrayParentSymbol].populated(this[arrayPathSymbol], true);
        }
        if (populated && value !== null && value !== void 0) {
          Model6 = populated.options[populateModelSymbol];
          if (Buffer.isBuffer(value) || value instanceof ObjectId2 || !utils.isObject(value)) {
            value = { _id: value };
          }
          const isDisc = value.$__schema && value.$__schema.discriminatorMapping && value.$__schema.discriminatorMapping.key !== void 0;
          if (!isDisc) {
            value = new Model6(value);
          }
          return this[arraySchemaSymbol].caster.applySetters(value, this[arrayParentSymbol], true);
        }
        return this[arraySchemaSymbol].caster.applySetters(value, this[arrayParentSymbol], false);
      }
      /**
       * Internal helper for .map()
       *
       * @api private
       * @return {Number}
       * @method _mapCast
       * @memberOf MongooseArray
       */
      _mapCast(val, index) {
        return this._cast(val, this.length + index);
      }
      /**
       * Marks this array as modified.
       *
       * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)
       *
       * @param {EmbeddedDocument} embeddedDoc the embedded doc that invoked this method on the Array
       * @param {String} embeddedPath the path which changed in the embeddedDoc
       * @method _markModified
       * @api private
       * @memberOf MongooseArray
       */
      _markModified(elem) {
        const parent = this[arrayParentSymbol];
        let dirtyPath;
        if (parent) {
          dirtyPath = this[arrayPathSymbol];
          if (arguments.length) {
            dirtyPath = dirtyPath + "." + elem;
          }
          if (dirtyPath != null && dirtyPath.endsWith(".$")) {
            return this;
          }
          parent.markModified(dirtyPath, arguments.length > 0 ? elem : parent);
        }
        return this;
      }
      /**
       * Register an atomic operation with the parent.
       *
       * @param {Array} op operation
       * @param {any} val
       * @method _registerAtomic
       * @api private
       * @memberOf MongooseArray
       */
      _registerAtomic(op, val) {
        if (this[slicedSymbol]) {
          return;
        }
        if (op === "$set") {
          this[arrayAtomicsSymbol] = { $set: val };
          cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);
          this._markModified();
          return this;
        }
        this[arrayAtomicsSymbol] || (this[arrayAtomicsSymbol] = {});
        const atomics = this[arrayAtomicsSymbol];
        if (op === "$pop" && !("$pop" in atomics)) {
          const _this = this;
          this[arrayParentSymbol].once("save", function() {
            _this._popped = _this._shifted = null;
          });
        }
        if (this[arrayAtomicsSymbol].$set || Object.keys(atomics).length && !(op in atomics)) {
          this[arrayAtomicsSymbol] = { $set: this };
          return this;
        }
        let selector;
        if (op === "$pullAll" || op === "$addToSet") {
          atomics[op] || (atomics[op] = []);
          atomics[op] = atomics[op].concat(val);
        } else if (op === "$pullDocs") {
          const pullOp = atomics["$pull"] || (atomics["$pull"] = {});
          if (val[0] instanceof EmbeddedDocument) {
            selector = pullOp["$or"] || (pullOp["$or"] = []);
            Array.prototype.push.apply(selector, val.map(function(v) {
              return v.toObject({ transform: false, virtuals: false });
            }));
          } else {
            selector = pullOp["_id"] || (pullOp["_id"] = { $in: [] });
            selector["$in"] = selector["$in"].concat(val);
          }
        } else if (op === "$push") {
          atomics.$push = atomics.$push || { $each: [] };
          if (val != null && utils.hasUserDefinedProperty(val, "$each")) {
            atomics.$push = val;
          } else {
            atomics.$push.$each = atomics.$push.$each.concat(val);
          }
        } else {
          atomics[op] = val;
        }
        return this;
      }
      /**
       * Adds values to the array if not already present.
       *
       * ####Example:
       *
       *     console.log(doc.array) // [2,3,4]
       *     const added = doc.array.addToSet(4,5);
       *     console.log(doc.array) // [2,3,4,5]
       *     console.log(added)     // [5]
       *
       * @param {any} [args...]
       * @return {Array} the values that were added
       * @memberOf MongooseArray
       * @api public
       * @method addToSet
       */
      addToSet() {
        _checkManualPopulation(this, arguments);
        let values = [].map.call(arguments, this._mapCast, this);
        values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
        const added = [];
        let type = "";
        if (values[0] instanceof EmbeddedDocument) {
          type = "doc";
        } else if (values[0] instanceof Date) {
          type = "date";
        }
        values.forEach(function(v) {
          let found;
          const val = +v;
          switch (type) {
            case "doc":
              found = this.some(function(doc) {
                return doc.equals(v);
              });
              break;
            case "date":
              found = this.some(function(d) {
                return +d === val;
              });
              break;
            default:
              found = ~this.indexOf(v);
          }
          if (!found) {
            [].push.call(this, v);
            this._registerAtomic("$addToSet", v);
            this._markModified();
            [].push.call(added, v);
          }
        }, this);
        return added;
      }
      /**
       * Returns the number of pending atomic operations to send to the db for this array.
       *
       * @api private
       * @return {Number}
       * @method hasAtomics
       * @memberOf MongooseArray
       */
      hasAtomics() {
        if (!utils.isPOJO(this[arrayAtomicsSymbol])) {
          return 0;
        }
        return Object.keys(this[arrayAtomicsSymbol]).length;
      }
      /**
       * Return whether or not the `obj` is included in the array.
       *
       * @param {Object} obj the item to check
       * @return {Boolean}
       * @api public
       * @method includes
       * @memberOf MongooseArray
       */
      includes(obj2, fromIndex) {
        const ret2 = this.indexOf(obj2, fromIndex);
        return ret2 !== -1;
      }
      /**
       * Return the index of `obj` or `-1` if not found.
       *
       * @param {Object} obj the item to look for
       * @return {Number}
       * @api public
       * @method indexOf
       * @memberOf MongooseArray
       */
      indexOf(obj2, fromIndex) {
        if (obj2 instanceof ObjectId2) {
          obj2 = obj2.toString();
        }
        fromIndex = fromIndex == null ? 0 : fromIndex;
        const len = this.length;
        for (let i = fromIndex; i < len; ++i) {
          if (obj2 == this[i]) {
            return i;
          }
        }
        return -1;
      }
      /**
       * Helper for console.log
       *
       * @api public
       * @method inspect
       * @memberOf MongooseArray
       */
      inspect() {
        return JSON.stringify(this);
      }
      /**
       * Pushes items to the array non-atomically.
       *
       * ####NOTE:
       *
       * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
       *
       * @param {any} [args...]
       * @api public
       * @method nonAtomicPush
       * @memberOf MongooseArray
       */
      nonAtomicPush() {
        const values = [].map.call(arguments, this._mapCast, this);
        const ret2 = [].push.apply(this, values);
        this._registerAtomic("$set", this);
        this._markModified();
        return ret2;
      }
      /**
       * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.
       *
       * ####Note:
       *
       * _marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it._
       *
       * @see MongooseArray#$pop #types_array_MongooseArray-%24pop
       * @api public
       * @method pop
       * @memberOf MongooseArray
       */
      pop() {
        const ret2 = [].pop.call(this);
        this._registerAtomic("$set", this);
        this._markModified();
        return ret2;
      }
      /**
       * Pulls items from the array atomically. Equality is determined by casting
       * the provided value to an embedded document and comparing using
       * [the `Document.equals()` function.](./api.html#document_Document-equals)
       *
       * ####Examples:
       *
       *     doc.array.pull(ObjectId)
       *     doc.array.pull({ _id: 'someId' })
       *     doc.array.pull(36)
       *     doc.array.pull('tag 1', 'tag 2')
       *
       * To remove a document from a subdocument array we may pass an object with a matching `_id`.
       *
       *     doc.subdocs.push({ _id: 4815162342 })
       *     doc.subdocs.pull({ _id: 4815162342 }) // removed
       *
       * Or we may passing the _id directly and let mongoose take care of it.
       *
       *     doc.subdocs.push({ _id: 4815162342 })
       *     doc.subdocs.pull(4815162342); // works
       *
       * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.
       *
       * @param {any} [args...]
       * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
       * @api public
       * @method pull
       * @memberOf MongooseArray
       */
      pull() {
        const values = [].map.call(arguments, this._cast, this);
        const cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);
        let i = cur.length;
        let mem;
        while (i--) {
          mem = cur[i];
          if (mem instanceof Document6) {
            const some = values.some(function(v) {
              return mem.equals(v);
            });
            if (some) {
              [].splice.call(cur, i, 1);
            }
          } else if (~cur.indexOf.call(values, mem)) {
            [].splice.call(cur, i, 1);
          }
        }
        if (values[0] instanceof EmbeddedDocument) {
          this._registerAtomic("$pullDocs", values.map(function(v) {
            return v.$__getValue("_id") || v;
          }));
        } else {
          this._registerAtomic("$pullAll", values);
        }
        this._markModified();
        if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {
          this._registerAtomic("$set", this);
        }
        return this;
      }
      /**
       * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.
       *
       * ####Example:
       *
       *     const schema = Schema({ nums: [Number] });
       *     const Model = mongoose.model('Test', schema);
       *
       *     const doc = await Model.create({ nums: [3, 4] });
       *     doc.nums.push(5); // Add 5 to the end of the array
       *     await doc.save();
       *
       *     // You can also pass an object with `$each` as the
       *     // first parameter to use MongoDB's `$position`
       *     doc.nums.push({
       *       $each: [1, 2],
       *       $position: 0
       *     });
       *     doc.nums; // [1, 2, 3, 4, 5]
       *
       * @param {Object} [args...]
       * @api public
       * @method push
       * @memberOf MongooseArray
       */
      push() {
        let values = arguments;
        let atomic = values;
        const isOverwrite = values[0] != null && utils.hasUserDefinedProperty(values[0], "$each");
        if (isOverwrite) {
          atomic = values[0];
          values = values[0].$each;
        }
        if (this[arraySchemaSymbol] == null) {
          return _basePush.apply(this, values);
        }
        _checkManualPopulation(this, values);
        const parent = this[arrayParentSymbol];
        values = [].map.call(values, this._mapCast, this);
        values = this[arraySchemaSymbol].applySetters(
          values,
          parent,
          void 0,
          void 0,
          { skipDocumentArrayCast: true }
        );
        let ret2;
        const atomics = this[arrayAtomicsSymbol];
        if (isOverwrite) {
          atomic.$each = values;
          if (get(atomics, "$push.$each.length", 0) > 0 && atomics.$push.$position != atomics.$position) {
            throw new MongooseError("Cannot call `Array#push()` multiple times with different `$position`");
          }
          if (atomic.$position != null) {
            [].splice.apply(this, [atomic.$position, 0].concat(values));
            ret2 = this.length;
          } else {
            ret2 = [].push.apply(this, values);
          }
        } else {
          if (get(atomics, "$push.$each.length", 0) > 0 && atomics.$push.$position != null) {
            throw new MongooseError("Cannot call `Array#push()` multiple times with different `$position`");
          }
          atomic = values;
          ret2 = [].push.apply(this, values);
        }
        this._registerAtomic("$push", atomic);
        this._markModified();
        return ret2;
      }
      /**
       * Alias of [pull](#mongoosearray_MongooseArray-pull)
       *
       * @see MongooseArray#pull #types_array_MongooseArray-pull
       * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull
       * @api public
       * @memberOf MongooseArray
       * @instance
       * @method remove
       */
      remove() {
        return this.pull.apply(this, arguments);
      }
      /**
       * Sets the casted `val` at index `i` and marks the array modified.
       *
       * ####Example:
       *
       *     // given documents based on the following
       *     const Doc = mongoose.model('Doc', new Schema({ array: [Number] }));
       *
       *     const doc = new Doc({ array: [2,3,4] })
       *
       *     console.log(doc.array) // [2,3,4]
       *
       *     doc.array.set(1,"5");
       *     console.log(doc.array); // [2,5,4] // properly cast to number
       *     doc.save() // the change is saved
       *
       *     // VS not using array#set
       *     doc.array[1] = "5";
       *     console.log(doc.array); // [2,"5",4] // no casting
       *     doc.save() // change is not saved
       *
       * @return {Array} this
       * @api public
       * @method set
       * @memberOf MongooseArray
       */
      set(i, val) {
        const value = this._cast(val, i);
        this[i] = value;
        this._markModified(i);
        return this;
      }
      /**
       * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
       *
       * ####Example:
       *
       *     doc.array = [2,3];
       *     const res = doc.array.shift();
       *     console.log(res) // 2
       *     console.log(doc.array) // [3]
       *
       * ####Note:
       *
       * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
       *
       * @api public
       * @method shift
       * @memberOf MongooseArray
       */
      shift() {
        const ret2 = [].shift.call(this);
        this._registerAtomic("$set", this);
        this._markModified();
        return ret2;
      }
      /**
       * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.
       *
       * ####NOTE:
       *
       * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
       *
       * @api public
       * @method sort
       * @memberOf MongooseArray
       * @see https://masteringjs.io/tutorials/fundamentals/array-sort
       */
      sort() {
        const ret2 = [].sort.apply(this, arguments);
        this._registerAtomic("$set", this);
        return ret2;
      }
      /**
       * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.
       *
       * ####Note:
       *
       * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._
       *
       * @api public
       * @method splice
       * @memberOf MongooseArray
       * @see https://masteringjs.io/tutorials/fundamentals/array-splice
       */
      splice() {
        let ret2;
        _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));
        if (arguments.length) {
          let vals;
          if (this[arraySchemaSymbol] == null) {
            vals = arguments;
          } else {
            vals = [];
            for (let i = 0; i < arguments.length; ++i) {
              vals[i] = i < 2 ? arguments[i] : this._cast(arguments[i], arguments[0] + (i - 2));
            }
          }
          ret2 = [].splice.apply(this, vals);
          this._registerAtomic("$set", this);
        }
        return ret2;
      }
      /*!
       * ignore
       */
      slice() {
        const ret2 = super.slice.apply(this, arguments);
        ret2[arrayParentSymbol] = this[arrayParentSymbol];
        ret2[arraySchemaSymbol] = this[arraySchemaSymbol];
        ret2[arrayAtomicsSymbol] = this[arrayAtomicsSymbol];
        ret2[arrayPathSymbol] = this[arrayPathSymbol];
        ret2[slicedSymbol] = true;
        return ret2;
      }
      /*!
       * ignore
       */
      filter() {
        const ret2 = super.filter.apply(this, arguments);
        ret2[arrayParentSymbol] = this[arrayParentSymbol];
        ret2[arraySchemaSymbol] = this[arraySchemaSymbol];
        ret2[arrayAtomicsSymbol] = this[arrayAtomicsSymbol];
        ret2[arrayPathSymbol] = this[arrayPathSymbol];
        return ret2;
      }
      /*!
       * ignore
       */
      toBSON() {
        return this.toObject(internalToObjectOptions);
      }
      /**
       * Returns a native js Array.
       *
       * @param {Object} options
       * @return {Array}
       * @api public
       * @method toObject
       * @memberOf MongooseArray
       */
      toObject(options) {
        if (options && options.depopulate) {
          options = utils.clone(options);
          options._isNested = true;
          return [].concat(this).map(function(doc) {
            return doc instanceof Document6 ? doc.toObject(options) : doc;
          });
        }
        return [].concat(this);
      }
      /**
       * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
       *
       * ####Note:
       *
       * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwriting any changes that happen between when you retrieved the object and when you save it._
       *
       * @api public
       * @method unshift
       * @memberOf MongooseArray
       */
      unshift() {
        _checkManualPopulation(this, arguments);
        let values;
        if (this[arraySchemaSymbol] == null) {
          values = arguments;
        } else {
          values = [].map.call(arguments, this._cast, this);
          values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);
        }
        [].unshift.apply(this, values);
        this._registerAtomic("$set", this);
        this._markModified();
        return this.length;
      }
    };
    if (util2.inspect.custom) {
      CoreMongooseArray.prototype[util2.inspect.custom] = CoreMongooseArray.prototype.inspect;
    }
    function _isAllSubdocs(docs, ref) {
      if (!ref) {
        return false;
      }
      for (const arg of docs) {
        if (arg == null) {
          return false;
        }
        const model = arg.constructor;
        if (!(arg instanceof Document6) || model.modelName !== ref && model.baseModelName !== ref) {
          return false;
        }
      }
      return true;
    }
    function _checkManualPopulation(arr, docs) {
      const ref = arr == null ? null : get(arr[arraySchemaSymbol], "caster.options.ref", null);
      if (arr.length === 0 && docs.length > 0) {
        if (_isAllSubdocs(docs, ref)) {
          arr[arrayParentSymbol].populated(arr[arrayPathSymbol], [], {
            [populateModelSymbol]: docs[0].constructor
          });
        }
      }
    }
    module2.exports = CoreMongooseArray;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/array.js
var require_array = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/array.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var CoreMongooseArray = require_core_array();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
    var _basePush = Array.prototype.push;
    function MongooseArray(values, path3, doc, schematype) {
      let arr;
      if (Array.isArray(values)) {
        const len = values.length;
        if (len === 0) {
          arr = new CoreMongooseArray();
        } else if (len === 1) {
          arr = new CoreMongooseArray(1);
          arr[0] = values[0];
        } else if (len < 1e4) {
          arr = new CoreMongooseArray();
          _basePush.apply(arr, values);
        } else {
          arr = new CoreMongooseArray();
          for (let i = 0; i < len; ++i) {
            _basePush.call(arr, values[i]);
          }
        }
        if (values[arrayAtomicsSymbol] != null) {
          arr[arrayAtomicsSymbol] = values[arrayAtomicsSymbol];
        }
      } else {
        arr = new CoreMongooseArray();
      }
      arr[arrayPathSymbol] = path3;
      if (doc != null && doc.$__ != null) {
        arr[arrayParentSymbol] = doc;
        arr[arraySchemaSymbol] = schematype || doc.schema.path(path3);
      }
      return arr;
    }
    module2.exports = exports2 = MongooseArray;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/buffer.js
var require_buffer = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/buffer.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Binary = require_driver().get().Binary;
    var utils = require_utils2();
    var Buffer2 = require_safe_buffer().Buffer;
    function MongooseBuffer(value, encode, offset) {
      const length = arguments.length;
      let val;
      if (length === 0 || arguments[0] === null || arguments[0] === void 0) {
        val = 0;
      } else {
        val = value;
      }
      let encoding;
      let path3;
      let doc;
      if (Array.isArray(encode)) {
        path3 = encode[0];
        doc = encode[1];
      } else {
        encoding = encode;
      }
      let buf;
      if (typeof val === "number" || val instanceof Number) {
        buf = Buffer2.alloc(val);
      } else {
        buf = Buffer2.from(val, encoding, offset);
      }
      utils.decorate(buf, MongooseBuffer.mixin);
      buf.isMongooseBuffer = true;
      buf[MongooseBuffer.pathSymbol] = path3;
      buf[parentSymbol] = doc;
      buf._subtype = 0;
      return buf;
    }
    var pathSymbol = Symbol.for("mongoose#Buffer#_path");
    var parentSymbol = Symbol.for("mongoose#Buffer#_parent");
    MongooseBuffer.pathSymbol = pathSymbol;
    MongooseBuffer.mixin = {
      /**
       * Default subtype for the Binary representing this Buffer
       *
       * @api private
       * @property _subtype
       * @receiver MongooseBuffer
       */
      _subtype: void 0,
      /**
       * Marks this buffer as modified.
       *
       * @api private
       * @method _markModified
       * @receiver MongooseBuffer
       */
      _markModified: function() {
        const parent = this[parentSymbol];
        if (parent) {
          parent.markModified(this[MongooseBuffer.pathSymbol]);
        }
        return this;
      },
      /**
       * Writes the buffer.
       *
       * @api public
       * @method write
       * @receiver MongooseBuffer
       */
      write: function() {
        const written = Buffer2.prototype.write.apply(this, arguments);
        if (written > 0) {
          this._markModified();
        }
        return written;
      },
      /**
       * Copies the buffer.
       *
       * ####Note:
       *
       * `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.
       *
       * @return {Number} The number of bytes copied.
       * @param {Buffer} target
       * @method copy
       * @receiver MongooseBuffer
       */
      copy: function(target) {
        const ret2 = Buffer2.prototype.copy.apply(this, arguments);
        if (target && target.isMongooseBuffer) {
          target._markModified();
        }
        return ret2;
      }
    };
    // node < 0.5
    "writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 writeFloat writeDouble fill utf8Write binaryWrite asciiWrite set writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE writeInt16LE writeInt16BE writeInt32LE writeInt32BE writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE".split(" ").forEach(function(method) {
      if (!Buffer2.prototype[method]) {
        return;
      }
      MongooseBuffer.mixin[method] = function() {
        const ret2 = Buffer2.prototype[method].apply(this, arguments);
        this._markModified();
        return ret2;
      };
    });
    MongooseBuffer.mixin.toObject = function(options) {
      const subtype = typeof options === "number" ? options : this._subtype || 0;
      return new Binary(Buffer2.from(this), subtype);
    };
    MongooseBuffer.mixin.toBSON = function() {
      return new Binary(this, this._subtype || 0);
    };
    MongooseBuffer.mixin.equals = function(other) {
      if (!Buffer2.isBuffer(other)) {
        return false;
      }
      if (this.length !== other.length) {
        return false;
      }
      for (let i = 0; i < this.length; ++i) {
        if (this[i] !== other[i]) {
          return false;
        }
      }
      return true;
    };
    MongooseBuffer.mixin.subtype = function(subtype) {
      if (typeof subtype !== "number") {
        throw new TypeError("Invalid subtype. Expected a number");
      }
      if (this._subtype !== subtype) {
        this._markModified();
      }
      this._subtype = subtype;
    };
    MongooseBuffer.Binary = Binary;
    module2.exports = MongooseBuffer;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast/objectid.js
var require_objectid3 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast/objectid.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ObjectId2 = require_driver().get().ObjectId;
    var assert = require("assert");
    module2.exports = function castObjectId(value) {
      if (value == null) {
        return value;
      }
      if (value instanceof ObjectId2) {
        return value;
      }
      if (value._id) {
        if (value._id instanceof ObjectId2) {
          return value._id;
        }
        if (value._id.toString instanceof Function) {
          return new ObjectId2(value._id.toString());
        }
      }
      if (value.toString instanceof Function) {
        return new ObjectId2(value.toString());
      }
      assert.ok(false);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/documentarray.js
var require_documentarray = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/documentarray.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var CoreMongooseArray = require_core_array();
    var Document6 = require_document();
    var ObjectId2 = require_objectid2();
    var castObjectId = require_objectid3();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var util2 = require("util");
    var utils = require_utils2();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
    var documentArrayParent = require_symbols().documentArrayParent;
    var _basePush = Array.prototype.push;
    var CoreDocumentArray = class extends CoreMongooseArray {
      get isMongooseDocumentArray() {
        return true;
      }
      /*!
       * ignore
       */
      toBSON() {
        return this.toObject(internalToObjectOptions);
      }
      /*!
       * ignore
       */
      map() {
        const ret2 = super.map.apply(this, arguments);
        ret2[arraySchemaSymbol] = null;
        ret2[arrayPathSymbol] = null;
        ret2[arrayParentSymbol] = null;
        return ret2;
      }
      /**
       * Overrides MongooseArray#cast
       *
       * @method _cast
       * @api private
       * @receiver MongooseDocumentArray
       */
      _cast(value, index) {
        if (this[arraySchemaSymbol] == null) {
          return value;
        }
        let Constructor = this[arraySchemaSymbol].casterConstructor;
        const isInstance = Constructor.$isMongooseDocumentArray ? value && value.isMongooseDocumentArray : value instanceof Constructor;
        if (isInstance || // Hack re: #5001, see #5005
        value && value.constructor && value.constructor.baseCasterConstructor === Constructor) {
          if (!(value[documentArrayParent] && value.__parentArray)) {
            value[documentArrayParent] = this[arrayParentSymbol];
            value.__parentArray = this;
          }
          value.$setIndex(index);
          return value;
        }
        if (value === void 0 || value === null) {
          return null;
        }
        if (Buffer.isBuffer(value) || value instanceof ObjectId2 || !utils.isObject(value)) {
          value = { _id: value };
        }
        if (value && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
          if (typeof value[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {
            Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];
          } else {
            const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[Constructor.schema.options.discriminatorKey]);
            if (constructorByValue) {
              Constructor = constructorByValue;
            }
          }
        }
        if (Constructor.$isMongooseDocumentArray) {
          return Constructor.cast(value, this, void 0, void 0, index);
        }
        return new Constructor(value, this, void 0, void 0, index);
      }
      /**
       * Searches array items for the first document with a matching _id.
       *
       * ####Example:
       *
       *     const embeddedDoc = m.array.id(some_id);
       *
       * @return {EmbeddedDocument|null} the subdocument or null if not found.
       * @param {ObjectId|String|Number|Buffer} id
       * @TODO cast to the _id based on schema for proper comparison
       * @method id
       * @api public
       * @receiver MongooseDocumentArray
       */
      id(id) {
        let casted;
        let sid;
        let _id;
        try {
          casted = castObjectId(id).toString();
        } catch (e) {
          casted = null;
        }
        for (const val of this) {
          if (!val) {
            continue;
          }
          _id = val.get("_id");
          if (_id === null || typeof _id === "undefined") {
            continue;
          } else if (_id instanceof Document6) {
            sid || (sid = String(id));
            if (sid == _id._id) {
              return val;
            }
          } else if (!(id instanceof ObjectId2) && !(_id instanceof ObjectId2)) {
            if (id == _id || utils.deepEqual(id, _id)) {
              return val;
            }
          } else if (casted == _id) {
            return val;
          }
        }
        return null;
      }
      /**
       * Returns a native js Array of plain js objects
       *
       * ####NOTE:
       *
       * _Each sub-document is converted to a plain object by calling its `#toObject` method._
       *
       * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion
       * @return {Array}
       * @method toObject
       * @api public
       * @receiver MongooseDocumentArray
       */
      toObject(options) {
        return [].concat(this.map(function(doc) {
          if (doc == null) {
            return null;
          }
          if (typeof doc.toObject !== "function") {
            return doc;
          }
          return doc.toObject(options);
        }));
      }
      slice() {
        const arr = super.slice.apply(this, arguments);
        arr[arrayParentSymbol] = this[arrayParentSymbol];
        arr[arrayPathSymbol] = this[arrayPathSymbol];
        return arr;
      }
      /**
       * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.
       *
       * @param {Object} [args...]
       * @api public
       * @method push
       * @memberOf MongooseDocumentArray
       */
      push() {
        const ret2 = super.push.apply(this, arguments);
        _updateParentPopulated(this);
        return ret2;
      }
      /**
       * Pulls items from the array atomically.
       *
       * @param {Object} [args...]
       * @api public
       * @method pull
       * @memberOf MongooseDocumentArray
       */
      pull() {
        const ret2 = super.pull.apply(this, arguments);
        _updateParentPopulated(this);
        return ret2;
      }
      /**
       * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.
       */
      shift() {
        const ret2 = super.shift.apply(this, arguments);
        _updateParentPopulated(this);
        return ret2;
      }
      /**
       * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.
       */
      splice() {
        const ret2 = super.splice.apply(this, arguments);
        _updateParentPopulated(this);
        return ret2;
      }
      /**
       * Helper for console.log
       *
       * @method inspect
       * @api public
       * @receiver MongooseDocumentArray
       */
      inspect() {
        return this.toObject();
      }
      /**
       * Creates a subdocument casted to this schema.
       *
       * This is the same subdocument constructor used for casting.
       *
       * @param {Object} obj the value to cast to this arrays SubDocument schema
       * @method create
       * @api public
       * @receiver MongooseDocumentArray
       */
      create(obj2) {
        let Constructor = this[arraySchemaSymbol].casterConstructor;
        if (obj2 && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
          if (typeof obj2[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[obj2[Constructor.schema.options.discriminatorKey]]) {
            Constructor = Constructor.discriminators[obj2[Constructor.schema.options.discriminatorKey]];
          } else {
            const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, obj2[Constructor.schema.options.discriminatorKey]);
            if (constructorByValue) {
              Constructor = constructorByValue;
            }
          }
        }
        return new Constructor(obj2, this);
      }
      /*!
       * ignore
       */
      notify(event) {
        const _this = this;
        return function notify(val, _arr) {
          _arr = _arr || _this;
          let i = _arr.length;
          while (i--) {
            if (_arr[i] == null) {
              continue;
            }
            switch (event) {
              case "save":
                val = _this[i];
                break;
              default:
                break;
            }
            if (_arr[i].isMongooseArray) {
              notify(val, _arr[i]);
            } else if (_arr[i]) {
              _arr[i].emit(event, val);
            }
          }
        };
      }
      _markModified(elem, embeddedPath) {
        const parent = this[arrayParentSymbol];
        let dirtyPath;
        if (parent) {
          dirtyPath = this[arrayPathSymbol];
          if (arguments.length) {
            if (embeddedPath != null) {
              const index = elem.__index;
              dirtyPath = dirtyPath + "." + index + "." + embeddedPath;
            } else {
              dirtyPath = dirtyPath + "." + elem;
            }
          }
          if (dirtyPath != null && dirtyPath.endsWith(".$")) {
            return this;
          }
          parent.markModified(dirtyPath, arguments.length > 0 ? elem : parent);
        }
        return this;
      }
    };
    if (util2.inspect.custom) {
      CoreDocumentArray.prototype[util2.inspect.custom] = CoreDocumentArray.prototype.inspect;
    }
    function _updateParentPopulated(arr) {
      const parent = arr[arrayParentSymbol];
      if (!parent || parent.$__.populated == null)
        return;
      const populatedPaths = Object.keys(parent.$__.populated).filter((p) => p.startsWith(arr[arrayPathSymbol] + "."));
      for (const path3 of populatedPaths) {
        const remnant = path3.slice((arr[arrayPathSymbol] + ".").length);
        if (!Array.isArray(parent.$__.populated[path3].value)) {
          continue;
        }
        parent.$__.populated[path3].value = arr.map((val) => val.populated(remnant));
      }
    }
    function MongooseDocumentArray(values, path3, doc) {
      const arr = new CoreDocumentArray();
      arr[arrayAtomicsSymbol] = {};
      arr[arraySchemaSymbol] = void 0;
      if (Array.isArray(values)) {
        if (values[arrayPathSymbol] === path3 && values[arrayParentSymbol] === doc) {
          arr[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);
        }
        values.forEach((v) => {
          _basePush.call(arr, v);
        });
      }
      arr[arrayPathSymbol] = path3;
      if (doc && doc instanceof Document6) {
        arr[arrayParentSymbol] = doc;
        arr[arraySchemaSymbol] = doc.schema.path(path3);
        while (arr != null && arr[arraySchemaSymbol] != null && arr[arraySchemaSymbol].$isMongooseArray && !arr[arraySchemaSymbol].$isMongooseDocumentArray) {
          arr[arraySchemaSymbol] = arr[arraySchemaSymbol].casterConstructor;
        }
      }
      return arr;
    }
    module2.exports = MongooseDocumentArray;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js
var require_handleSpreadDoc = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var utils = require_utils2();
    module2.exports = function handleSpreadDoc(v) {
      if (utils.isPOJO(v) && v.$__ != null && v._doc != null) {
        return v._doc;
      }
      return v;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/map.js
var require_map2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/map.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Mixed = require_mixed();
    var ObjectId2 = require_objectid2();
    var clone = require_clone();
    var deepEqual = require_utils2().deepEqual;
    var get = require_get();
    var getConstructorName = require_getConstructorName();
    var handleSpreadDoc = require_handleSpreadDoc();
    var util2 = require("util");
    var specialProperties = require_specialProperties();
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var MongooseMap = class extends Map {
      constructor(v, path3, doc, schemaType) {
        if (getConstructorName(v) === "Object") {
          v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);
        }
        super(v);
        this.$__parent = doc != null && doc.$__ != null ? doc : null;
        this.$__path = path3;
        this.$__schemaType = schemaType == null ? new Mixed(path3) : schemaType;
        this.$__runDeferred();
      }
      $init(key, value) {
        checkValidKey(key);
        super.set(key, value);
        if (value != null && value.$isSingleNested) {
          value.$basePath = this.$__path + "." + key;
        }
      }
      $__set(key, value) {
        super.set(key, value);
      }
      get(key, options) {
        if (key instanceof ObjectId2) {
          key = key.toString();
        }
        options = options || {};
        if (options.getters === false) {
          return super.get(key);
        }
        return this.$__schemaType.applyGetters(super.get(key), this.$__parent);
      }
      set(key, value) {
        if (key instanceof ObjectId2) {
          key = key.toString();
        }
        checkValidKey(key);
        value = handleSpreadDoc(value);
        if (this.$__schemaType == null) {
          this.$__deferred = this.$__deferred || [];
          this.$__deferred.push({ key, value });
          return;
        }
        const fullPath = this.$__path + "." + key;
        const populated = this.$__parent != null && this.$__parent.$__ ? this.$__parent.populated(fullPath) || this.$__parent.populated(this.$__path) : null;
        const priorVal = this.get(key);
        if (populated != null) {
          if (value.$__ == null) {
            value = new populated.options[populateModelSymbol](value);
          }
          value.$__.wasPopulated = true;
        } else {
          try {
            value = this.$__schemaType.applySetters(value, this.$__parent, false, this.get(key), { path: fullPath });
          } catch (error) {
            if (this.$__parent != null && this.$__parent.$__ != null) {
              this.$__parent.invalidate(fullPath, error);
              return;
            }
            throw error;
          }
        }
        super.set(key, value);
        if (value != null && value.$isSingleNested) {
          value.$basePath = this.$__path + "." + key;
        }
        const parent = this.$__parent;
        if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {
          parent.markModified(this.$__path + "." + key);
        }
      }
      clear() {
        super.clear();
        const parent = this.$__parent;
        if (parent != null) {
          parent.markModified(this.$__path);
        }
      }
      delete(key) {
        if (key instanceof ObjectId2) {
          key = key.toString();
        }
        this.set(key, void 0);
        super.delete(key);
      }
      toBSON() {
        return new Map(this);
      }
      toObject(options) {
        if (get(options, "flattenMaps")) {
          const ret2 = {};
          const keys = this.keys();
          for (const key of keys) {
            ret2[key] = clone(this.get(key));
          }
          return ret2;
        }
        return new Map(this);
      }
      toJSON() {
        const ret2 = {};
        const keys = this.keys();
        for (const key of keys) {
          ret2[key] = this.get(key);
        }
        return ret2;
      }
      inspect() {
        return new Map(this);
      }
      $__runDeferred() {
        if (!this.$__deferred) {
          return;
        }
        for (const keyValueObject of this.$__deferred) {
          this.set(keyValueObject.key, keyValueObject.value);
        }
        this.$__deferred = null;
      }
    };
    if (util2.inspect.custom) {
      Object.defineProperty(MongooseMap.prototype, util2.inspect.custom, {
        enumerable: false,
        writable: false,
        configurable: false,
        value: MongooseMap.prototype.inspect
      });
    }
    Object.defineProperty(MongooseMap.prototype, "$__set", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$__parent", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$__path", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$__schemaType", {
      enumerable: false,
      writable: true,
      configurable: false
    });
    Object.defineProperty(MongooseMap.prototype, "$isMongooseMap", {
      enumerable: false,
      writable: false,
      configurable: false,
      value: true
    });
    Object.defineProperty(MongooseMap.prototype, "$__deferredCalls", {
      enumerable: false,
      writable: false,
      configurable: false,
      value: true
    });
    function checkValidKey(key) {
      const keyType = typeof key;
      if (keyType !== "string") {
        throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);
      }
      if (key.startsWith("$")) {
        throw new Error(`Mongoose maps do not support keys that start with "$", got "${key}"`);
      }
      if (key.includes(".")) {
        throw new Error(`Mongoose maps do not support keys that contain ".", got "${key}"`);
      }
      if (specialProperties.has(key)) {
        throw new Error(`Mongoose maps do not support reserved key name "${key}"`);
      }
    }
    module2.exports = MongooseMap;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/subdocument.js
var require_subdocument = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/subdocument.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Document6 = require_document();
    var immediate = require_immediate();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var promiseOrCallback = require_promiseOrCallback();
    var documentArrayParent = require_symbols().documentArrayParent;
    module2.exports = Subdocument;
    function Subdocument(value, fields, parent, skipId, options) {
      this.$isSingleNested = true;
      if (options != null && options.path != null) {
        this.$basePath = options.path;
      }
      const hasPriorDoc = options != null && options.priorDoc;
      let initedPaths = null;
      if (hasPriorDoc) {
        this._doc = Object.assign({}, options.priorDoc._doc);
        delete this._doc[this.$__schema.options.discriminatorKey];
        initedPaths = Object.keys(options.priorDoc._doc || {}).filter((key) => key !== this.$__schema.options.discriminatorKey);
      }
      if (parent != null) {
        options = Object.assign({}, options, {
          isNew: parent.isNew,
          defaults: parent.$__.$options.defaults
        });
      }
      Document6.call(this, value, fields, skipId, options);
      if (hasPriorDoc) {
        for (const key of initedPaths) {
          if (!this.$__.activePaths.states.modify[key] && !this.$__.activePaths.states.default[key] && !this.$__.$setCalled.has(key)) {
            const schematype = this.$__schema.path(key);
            const def = schematype == null ? void 0 : schematype.getDefault(this);
            if (def === void 0) {
              delete this._doc[key];
            } else {
              this._doc[key] = def;
              this.$__.activePaths.default(key);
            }
          }
        }
        delete options.priorDoc;
        delete this.$__.$options.priorDoc;
      }
    }
    Subdocument.prototype = Object.create(Document6.prototype);
    Subdocument.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    Subdocument.prototype.save = function(options, fn) {
      if (typeof options === "function") {
        fn = options;
        options = {};
      }
      options = options || {};
      if (!options.suppressWarning) {
        console.warn("mongoose: calling `save()` on a subdoc does **not** save the document to MongoDB, it only runs save middleware. Use `subdoc.save({ suppressWarning: true })` to hide this warning if you're sure this behavior is right for your app.");
      }
      return promiseOrCallback(fn, (cb) => {
        this.$__save(cb);
      });
    };
    Subdocument.prototype.$__save = function(fn) {
      return immediate(() => fn(null, this));
    };
    Subdocument.prototype.$isValid = function(path3) {
      if (this.$__parent && this.$basePath) {
        return this.$__parent.$isValid([this.$basePath, path3].join("."));
      }
      return Document6.prototype.$isValid.call(this, path3);
    };
    Subdocument.prototype.markModified = function(path3) {
      Document6.prototype.markModified.call(this, path3);
      if (this.$__parent && this.$basePath) {
        if (this.$__parent.isDirectModified(this.$basePath)) {
          return;
        }
        this.$__parent.markModified([this.$basePath, path3].join("."), this);
      }
    };
    Subdocument.prototype.isModified = function(paths, modifiedPaths) {
      if (this.$__parent && this.$basePath) {
        if (Array.isArray(paths) || typeof paths === "string") {
          paths = Array.isArray(paths) ? paths : paths.split(" ");
          paths = paths.map((p) => [this.$basePath, p].join("."));
          return this.$__parent.isModified(paths, modifiedPaths);
        }
        return this.$__parent.isModified(this.$basePath);
      }
      return Document6.prototype.isModified.call(this, paths, modifiedPaths);
    };
    Subdocument.prototype.$markValid = function(path3) {
      Document6.prototype.$markValid.call(this, path3);
      if (this.$__parent && this.$basePath) {
        this.$__parent.$markValid([this.$basePath, path3].join("."));
      }
    };
    Subdocument.prototype.invalidate = function(path3, err, val) {
      if (err !== this.ownerDocument().$__.validationError) {
        Document6.prototype.invalidate.call(this, path3, err, val);
      }
      if (this.$__parent && this.$basePath) {
        this.$__parent.invalidate([this.$basePath, path3].join("."), err, val);
      } else if (err.kind === "cast" || err.name === "CastError") {
        throw err;
      }
      return this.ownerDocument().$__.validationError;
    };
    Subdocument.prototype.$ignore = function(path3) {
      Document6.prototype.$ignore.call(this, path3);
      if (this.$__parent && this.$basePath) {
        this.$__parent.$ignore([this.$basePath, path3].join("."));
      }
    };
    Subdocument.prototype.ownerDocument = function() {
      if (this.$__.ownerDocument) {
        return this.$__.ownerDocument;
      }
      let parent = this.$__parent;
      if (!parent) {
        return this;
      }
      while (parent.$__parent || parent[documentArrayParent]) {
        parent = parent.$__parent || parent[documentArrayParent];
      }
      this.$__.ownerDocument = parent;
      return this.$__.ownerDocument;
    };
    Subdocument.prototype.parent = function() {
      return this.$__parent;
    };
    Subdocument.prototype.$parent = Subdocument.prototype.parent;
    Subdocument.prototype.$__remove = function(cb) {
      return cb(null, this);
    };
    Subdocument.prototype.remove = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      registerRemoveListener(this);
      if (!options || !options.noop) {
        this.$__parent.set(this.$basePath, null);
      }
      if (typeof callback === "function") {
        callback(null);
      }
    };
    Subdocument.prototype.populate = function() {
      throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.nested.populate("path")`, use `doc.populate("nested.path")`');
    };
    function registerRemoveListener(sub) {
      let owner = sub.ownerDocument();
      function emitRemove() {
        owner.removeListener("save", emitRemove);
        owner.removeListener("remove", emitRemove);
        sub.emit("remove", sub);
        sub.constructor.emit("remove", sub);
        owner = sub = null;
      }
      owner.on("save", emitRemove);
      owner.on("remove", emitRemove);
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/index.js
var require_types = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/types/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    exports2.Array = require_array();
    exports2.Buffer = require_buffer();
    exports2.Document = // @deprecate
    exports2.Embedded = require_embedded();
    exports2.DocumentArray = require_documentarray();
    exports2.Decimal128 = require_decimal128();
    exports2.ObjectId = require_objectid2();
    exports2.Map = require_map2();
    exports2.Subdocument = require_subdocument();
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/array.js
var require_array2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/array.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var $exists2 = require_exists();
    var $type2 = require_type();
    var MongooseError = require_mongooseError();
    var SchemaArrayOptions = require_SchemaArrayOptions();
    var SchemaType = require_schematype();
    var CastError = SchemaType.CastError;
    var Mixed = require_mixed();
    var arrayDepth = require_arrayDepth();
    var cast = require_cast2();
    var get = require_get();
    var isOperator = require_isOperator();
    var util2 = require("util");
    var utils = require_utils2();
    var castToNumber = require_helpers().castToNumber;
    var geospatial = require_geospatial();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var MongooseArray;
    var EmbeddedDoc;
    var isNestedArraySymbol = Symbol("mongoose#isNestedArray");
    var emptyOpts = Object.freeze({});
    function SchemaArray(key, cast2, options, schemaOptions) {
      EmbeddedDoc || (EmbeddedDoc = require_types().Embedded);
      let typeKey = "type";
      if (schemaOptions && schemaOptions.typeKey) {
        typeKey = schemaOptions.typeKey;
      }
      this.schemaOptions = schemaOptions;
      if (cast2) {
        let castOptions = {};
        if (utils.isPOJO(cast2)) {
          if (cast2[typeKey]) {
            castOptions = utils.clone(cast2);
            delete castOptions[typeKey];
            cast2 = cast2[typeKey];
          } else {
            cast2 = Mixed;
          }
        }
        if (options != null && options.ref != null && castOptions.ref == null) {
          castOptions.ref = options.ref;
        }
        if (cast2 === Object) {
          cast2 = Mixed;
        }
        const name = typeof cast2 === "string" ? cast2 : utils.getFunctionName(cast2);
        const Types2 = require_schema();
        const caster = Types2.hasOwnProperty(name) ? Types2[name] : cast2;
        this.casterConstructor = caster;
        if (this.casterConstructor instanceof SchemaArray) {
          this.casterConstructor[isNestedArraySymbol] = true;
        }
        if (typeof caster === "function" && !caster.$isArraySubdocument && !caster.$isSchemaMap) {
          const path3 = this.caster instanceof EmbeddedDoc ? null : key;
          this.caster = new caster(path3, castOptions);
        } else {
          this.caster = caster;
          if (!(this.caster instanceof EmbeddedDoc)) {
            this.caster.path = key;
          }
        }
        this.$embeddedSchemaType = this.caster;
      }
      this.$isMongooseArray = true;
      SchemaType.call(this, key, options, "Array");
      let defaultArr;
      let fn;
      if (this.defaultValue != null) {
        defaultArr = this.defaultValue;
        fn = typeof defaultArr === "function";
      }
      if (!("defaultValue" in this) || this.defaultValue !== void 0) {
        const defaultFn = function() {
          let arr = [];
          if (fn) {
            arr = defaultArr.call(this);
          } else if (defaultArr != null) {
            arr = arr.concat(defaultArr);
          }
          return arr;
        };
        defaultFn.$runBeforeSetters = !fn;
        this.default(defaultFn);
      }
    }
    SchemaArray.schemaName = "Array";
    SchemaArray.options = { castNonArrays: true };
    SchemaArray.defaultOptions = {};
    SchemaArray.set = SchemaType.set;
    SchemaArray.prototype = Object.create(SchemaType.prototype);
    SchemaArray.prototype.constructor = SchemaArray;
    SchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;
    SchemaArray._checkRequired = SchemaType.prototype.checkRequired;
    SchemaArray.checkRequired = SchemaType.checkRequired;
    SchemaArray.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : SchemaArray.checkRequired();
      return _checkRequired(value);
    };
    SchemaArray.prototype.enum = function() {
      let arr = this;
      while (true) {
        const instance = get(arr, "caster.instance");
        if (instance === "Array") {
          arr = arr.caster;
          continue;
        }
        if (instance !== "String" && instance !== "Number") {
          throw new Error("`enum` can only be set on an array of strings or numbers , not " + instance);
        }
        break;
      }
      let enumArray = arguments;
      if (!Array.isArray(arguments) && utils.isObject(arguments)) {
        enumArray = utils.object.vals(enumArray);
      }
      arr.caster.enum.apply(arr.caster, enumArray);
      return this;
    };
    SchemaArray.prototype.applyGetters = function(value, scope) {
      if (scope != null && scope.$__ != null && scope.populated(this.path)) {
        return value;
      }
      const ret2 = SchemaType.prototype.applyGetters.call(this, value, scope);
      if (Array.isArray(ret2)) {
        const len = ret2.length;
        for (let i = 0; i < len; ++i) {
          ret2[i] = this.caster.applyGetters(ret2[i], scope);
        }
      }
      return ret2;
    };
    SchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {
      if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {
        let depth = 0;
        let arr = this;
        while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
          ++depth;
          arr = arr.casterConstructor;
        }
        if (value != null && value.length > 0) {
          const valueDepth = arrayDepth(value);
          if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {
            for (let i = valueDepth.max; i < depth; ++i) {
              value = [value];
            }
          }
        }
      }
      return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);
    };
    SchemaArray.prototype.cast = function(value, doc, init, prev, options) {
      MongooseArray || (MongooseArray = require_types().Array);
      let i;
      let l2;
      if (Array.isArray(value)) {
        const len = value.length;
        if (!len && doc) {
          const indexes = doc.schema.indexedPaths();
          const arrayPath = this.path;
          for (i = 0, l2 = indexes.length; i < l2; ++i) {
            const pathIndex = indexes[i][0][arrayPath];
            if (pathIndex === "2dsphere" || pathIndex === "2d") {
              return;
            }
          }
          const arrayGeojsonPath = this.path.endsWith(".coordinates") ? this.path.substr(0, this.path.lastIndexOf(".")) : null;
          if (arrayGeojsonPath != null) {
            for (i = 0, l2 = indexes.length; i < l2; ++i) {
              const pathIndex = indexes[i][0][arrayGeojsonPath];
              if (pathIndex === "2dsphere") {
                return;
              }
            }
          }
        }
        options = options || emptyOpts;
        value = MongooseArray(value, options.path || this._arrayPath || this.path, doc, this);
        if (init && doc != null && doc.$__ != null && doc.populated(this.path)) {
          return value;
        }
        const caster = this.caster;
        const isMongooseArray = caster.$isMongooseArray;
        const isArrayOfNumbers = caster.instance === "Number";
        if (caster && this.casterConstructor !== Mixed) {
          try {
            for (i = 0; i < len; i++) {
              if (isArrayOfNumbers && value[i] === void 0) {
                throw new MongooseError("Mongoose number arrays disallow storing undefined");
              }
              const opts = {};
              if (isMongooseArray) {
                if (options.arrayPath != null) {
                  opts.arrayPathIndex = i;
                } else if (caster._arrayParentPath != null) {
                  opts.arrayPathIndex = i;
                }
              }
              value[i] = caster.applySetters(value[i], doc, init, void 0, opts);
            }
          } catch (e) {
            throw new CastError("[" + e.kind + "]", util2.inspect(value), this.path + "." + i, e, this);
          }
        }
        return value;
      }
      if (init || SchemaArray.options.castNonArrays) {
        if (!!doc && !!init) {
          doc.markModified(this.path);
        }
        return this.cast([value], doc, init);
      }
      throw new CastError("Array", util2.inspect(value), this.path, null, this);
    };
    SchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {
      MongooseArray || (MongooseArray = require_types().Array);
      if (Array.isArray(value)) {
        let i;
        const len = value.length;
        const caster = this.caster;
        if (caster && this.casterConstructor !== Mixed) {
          try {
            for (i = 0; i < len; i++) {
              const opts = {};
              if (caster.$isMongooseArray && caster._arrayParentPath != null) {
                opts.arrayPathIndex = i;
              }
              value[i] = caster.cast(value[i], doc, false, void 0, opts);
            }
          } catch (e) {
            throw new CastError("[" + e.kind + "]", util2.inspect(value), this.path + "." + i, e, this);
          }
        }
        return value;
      }
      throw new CastError("Array", util2.inspect(value), this.path, null, this);
    };
    SchemaArray.prototype.discriminator = function(name, schema) {
      let arr = this;
      while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
        arr = arr.casterConstructor;
        if (arr == null || typeof arr === "function") {
          throw new MongooseError("You can only add an embedded discriminator on a document array, " + this.path + " is a plain array");
        }
      }
      return arr.discriminator(name, schema);
    };
    SchemaArray.prototype.clone = function() {
      const options = Object.assign({}, this.options);
      const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0) {
        schematype.requiredValidator = this.requiredValidator;
      }
      return schematype;
    };
    SchemaArray.prototype.castForQuery = function($conditional, value) {
      let handler;
      let val;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional + " with Array.");
        }
        val = handler.call(this, value);
      } else {
        val = $conditional;
        let Constructor = this.casterConstructor;
        if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
          if (typeof val[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {
            Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];
          } else {
            const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);
            if (constructorByValue) {
              Constructor = constructorByValue;
            }
          }
        }
        const proto = this.casterConstructor.prototype;
        let method = proto && (proto.castForQuery || proto.cast);
        if (!method && Constructor.castForQuery) {
          method = Constructor.castForQuery;
        }
        const caster = this.caster;
        if (Array.isArray(val)) {
          this.setters.reverse().forEach((setter) => {
            val = setter.call(this, val, this);
          });
          val = val.map(function(v) {
            if (utils.isObject(v) && v.$elemMatch) {
              return v;
            }
            if (method) {
              v = method.call(caster, v);
              return v;
            }
            if (v != null) {
              v = new Constructor(v);
              return v;
            }
            return v;
          });
        } else if (method) {
          val = method.call(caster, val);
        } else if (val != null) {
          val = new Constructor(val);
        }
      }
      return val;
    };
    function cast$all(val) {
      if (!Array.isArray(val)) {
        val = [val];
      }
      val = val.map(function(v) {
        if (utils.isObject(v)) {
          const o = {};
          o[this.path] = v;
          return cast(this.casterConstructor.schema, o)[this.path];
        }
        return v;
      }, this);
      return this.castForQuery(val);
    }
    function cast$elemMatch(val) {
      const keys = Object.keys(val);
      const numKeys = keys.length;
      for (let i = 0; i < numKeys; ++i) {
        const key = keys[i];
        const value = val[key];
        if (isOperator(key) && value != null) {
          val[key] = this.castForQuery(key, value);
        }
      }
      const discriminatorKey = get(
        this,
        "casterConstructor.schema.options.discriminatorKey"
      );
      const discriminators = get(this, "casterConstructor.schema.discriminators", {});
      if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {
        return cast(discriminators[val[discriminatorKey]], val);
      }
      return cast(this.casterConstructor.schema, val);
    }
    var handle = SchemaArray.prototype.$conditionalHandlers = {};
    handle.$all = cast$all;
    handle.$options = String;
    handle.$elemMatch = cast$elemMatch;
    handle.$geoIntersects = geospatial.cast$geoIntersects;
    handle.$or = createLogicalQueryOperatorHandler("$or");
    handle.$and = createLogicalQueryOperatorHandler("$and");
    handle.$nor = createLogicalQueryOperatorHandler("$nor");
    function createLogicalQueryOperatorHandler(op) {
      return function logicalQueryOperatorHandler(val) {
        if (!Array.isArray(val)) {
          throw new TypeError("conditional " + op + " requires an array");
        }
        const ret2 = [];
        for (const obj2 of val) {
          ret2.push(cast(this.casterConstructor.schema, obj2));
        }
        return ret2;
      };
    }
    handle.$near = handle.$nearSphere = geospatial.cast$near;
    handle.$within = handle.$geoWithin = geospatial.cast$within;
    handle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;
    handle.$exists = $exists2;
    handle.$type = $type2;
    handle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$ne = handle.$regex = SchemaArray.prototype.castForQuery;
    handle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;
    handle.$in = SchemaType.prototype.$conditionalHandlers.$in;
    module2.exports = SchemaArray;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaDocumentArrayOptions.js
var require_SchemaDocumentArrayOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaDocumentArrayOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaDocumentArrayOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaDocumentArrayOptions.prototype, "excludeIndexes", opts);
    Object.defineProperty(SchemaDocumentArrayOptions.prototype, "_id", opts);
    module2.exports = SchemaDocumentArrayOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/document/compile.js
var require_compile = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/document/compile.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
    var get = require_get();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var utils = require_utils2();
    var Document6;
    var getSymbol = require_symbols().getSymbol;
    var scopeSymbol = require_symbols().scopeSymbol;
    exports2.compile = compile;
    exports2.defineKey = defineKey;
    function compile(tree, proto, prefix, options) {
      Document6 = Document6 || require_document();
      const keys = Object.keys(tree);
      const len = keys.length;
      let limb;
      let key;
      for (let i = 0; i < len; ++i) {
        key = keys[i];
        limb = tree[key];
        const hasSubprops = utils.isPOJO(limb) && Object.keys(limb).length && (!limb[options.typeKey] || options.typeKey === "type" && limb.type.type);
        const subprops = hasSubprops ? limb : null;
        defineKey(key, subprops, proto, prefix, keys, options);
      }
    }
    function defineKey(prop, subprops, prototype, prefix, keys, options) {
      Document6 = Document6 || require_document();
      const path3 = (prefix ? prefix + "." : "") + prop;
      prefix = prefix || "";
      if (subprops) {
        Object.defineProperty(prototype, prop, {
          enumerable: true,
          configurable: true,
          get: function() {
            const _this = this;
            if (!this.$__.getters) {
              this.$__.getters = {};
            }
            if (!this.$__.getters[path3]) {
              const nested = Object.create(Document6.prototype, getOwnPropertyDescriptors(this));
              if (!prefix) {
                nested.$__[scopeSymbol] = this;
              }
              nested.$__.nestedPath = path3;
              Object.defineProperty(nested, "schema", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: prototype.schema
              });
              Object.defineProperty(nested, "$__schema", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: prototype.schema
              });
              Object.defineProperty(nested, documentSchemaSymbol, {
                enumerable: false,
                configurable: true,
                writable: false,
                value: prototype.schema
              });
              Object.defineProperty(nested, "toObject", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return utils.clone(_this.get(path3, null, {
                    virtuals: get(this, "schema.options.toObject.virtuals", null)
                  }));
                }
              });
              Object.defineProperty(nested, "$__get", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return _this.get(path3, null, {
                    virtuals: get(this, "schema.options.toObject.virtuals", null)
                  });
                }
              });
              Object.defineProperty(nested, "toJSON", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return _this.get(path3, null, {
                    virtuals: get(_this, "schema.options.toJSON.virtuals", null)
                  });
                }
              });
              Object.defineProperty(nested, "$__isNested", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: true
              });
              const _isEmptyOptions = Object.freeze({
                minimize: true,
                virtuals: false,
                getters: false,
                transform: false
              });
              Object.defineProperty(nested, "$isEmpty", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: function() {
                  return Object.keys(this.get(path3, null, _isEmptyOptions) || {}).length === 0;
                }
              });
              Object.defineProperty(nested, "$__parent", {
                enumerable: false,
                configurable: true,
                writable: false,
                value: this
              });
              compile(subprops, nested, path3, options);
              this.$__.getters[path3] = nested;
            }
            return this.$__.getters[path3];
          },
          set: function(v) {
            if (v != null && v.$__isNested) {
              v = v.$__get();
            } else if (v instanceof Document6 && !v.$__isNested) {
              v = v.toObject(internalToObjectOptions);
            }
            const doc = this.$__[scopeSymbol] || this;
            doc.$set(path3, v);
          }
        });
      } else {
        Object.defineProperty(prototype, prop, {
          enumerable: true,
          configurable: true,
          get: function() {
            return this[getSymbol].call(this.$__[scopeSymbol] || this, path3);
          },
          set: function(v) {
            this.$set.call(this.$__[scopeSymbol] || this, path3, v);
          }
        });
      }
    }
    function getOwnPropertyDescriptors(object) {
      const result = {};
      Object.getOwnPropertyNames(object).forEach(function(key) {
        const skip = [
          "isNew",
          "$__",
          "errors",
          "_doc",
          "$locals",
          "$op",
          "__parentArray",
          "__index",
          "$isDocumentArrayElement"
        ].indexOf(key) === -1;
        if (skip) {
          return;
        }
        result[key] = Object.getOwnPropertyDescriptor(object, key);
        result[key].enumerable = false;
      });
      return result;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/model/discriminator.js
var require_discriminator = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/model/discriminator.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Mixed = require_mixed();
    var defineKey = require_compile().defineKey;
    var get = require_get();
    var utils = require_utils2();
    var CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {
      toJSON: true,
      toObject: true,
      _id: true,
      id: true
    };
    module2.exports = function discriminator(model, name, schema, tiedValue, applyPlugins) {
      if (!(schema && schema.instanceOfSchema)) {
        throw new Error("You must pass a valid discriminator Schema");
      }
      if (model.schema.discriminatorMapping && !model.schema.discriminatorMapping.isRoot) {
        throw new Error('Discriminator "' + name + '" can only be a discriminator of the root model');
      }
      if (applyPlugins) {
        const applyPluginsToDiscriminators = get(
          model.base,
          "options.applyPluginsToDiscriminators",
          false
        );
        model.base._applyPlugins(schema, {
          skipTopLevel: !applyPluginsToDiscriminators
        });
      }
      const key = model.schema.options.discriminatorKey;
      const existingPath = model.schema.path(key);
      if (existingPath != null) {
        if (!utils.hasUserDefinedProperty(existingPath.options, "select")) {
          existingPath.options.select = true;
        }
        existingPath.options.$skipDiscriminatorCheck = true;
      } else {
        const baseSchemaAddition = {};
        baseSchemaAddition[key] = {
          default: void 0,
          select: true,
          $skipDiscriminatorCheck: true
        };
        baseSchemaAddition[key][model.schema.options.typeKey] = String;
        model.schema.add(baseSchemaAddition);
        defineKey(key, null, model.prototype, null, [key], model.schema.options);
      }
      if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {
        throw new Error('Discriminator "' + name + '" cannot have field with name "' + key + '"');
      }
      let value = name;
      if (typeof tiedValue === "string" && tiedValue.length || tiedValue != null) {
        value = tiedValue;
      }
      function merge2(schema2, baseSchema) {
        schema2._baseSchema = baseSchema;
        if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {
          schema2.remove("_id");
        }
        const baseSchemaPaths = Object.keys(baseSchema.paths);
        const conflictingPaths = [];
        for (const path3 of baseSchemaPaths) {
          if (schema2.nested[path3]) {
            conflictingPaths.push(path3);
            continue;
          }
          if (path3.indexOf(".") === -1) {
            continue;
          }
          const sp = path3.split(".").slice(0, -1);
          let cur = "";
          for (const piece of sp) {
            cur += (cur.length ? "." : "") + piece;
            if (schema2.paths[cur] instanceof Mixed || schema2.singleNestedPaths[cur] instanceof Mixed) {
              conflictingPaths.push(path3);
            }
          }
        }
        utils.merge(schema2, baseSchema, {
          isDiscriminatorSchemaMerge: true,
          omit: { discriminators: true, base: true },
          omitNested: conflictingPaths.reduce((cur, path3) => {
            cur["tree." + path3] = true;
            return cur;
          }, {})
        });
        for (const conflictingPath of conflictingPaths) {
          delete schema2.paths[conflictingPath];
        }
        schema2.childSchemas.forEach((obj3) => {
          obj3.model.prototype.$__setSchema(obj3.schema);
        });
        const obj2 = {};
        obj2[key] = {
          default: value,
          select: true,
          set: function(newName) {
            if (newName === value || Array.isArray(value) && utils.deepEqual(newName, value)) {
              return value;
            }
            throw new Error(`Can't set discriminator key "` + key + '"');
          },
          $skipDiscriminatorCheck: true
        };
        obj2[key][schema2.options.typeKey] = existingPath ? existingPath.options[schema2.options.typeKey] : String;
        schema2.add(obj2);
        schema2.discriminatorMapping = { key, value, isRoot: false };
        if (baseSchema.options.collection) {
          schema2.options.collection = baseSchema.options.collection;
        }
        const toJSON = schema2.options.toJSON;
        const toObject = schema2.options.toObject;
        const _id = schema2.options._id;
        const id = schema2.options.id;
        const keys = Object.keys(schema2.options);
        schema2.options.discriminatorKey = baseSchema.options.discriminatorKey;
        for (const _key of keys) {
          if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {
            if (_key === "pluralization" && schema2.options[_key] == true && baseSchema.options[_key] == null) {
              continue;
            }
            if (!utils.deepEqual(schema2.options[_key], baseSchema.options[_key])) {
              throw new Error("Can't customize discriminator option " + _key + " (can only modify " + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(", ") + ")");
            }
          }
        }
        schema2.options = utils.clone(baseSchema.options);
        if (toJSON)
          schema2.options.toJSON = toJSON;
        if (toObject)
          schema2.options.toObject = toObject;
        if (typeof _id !== "undefined") {
          schema2.options._id = _id;
        }
        schema2.options.id = id;
        schema2.s.hooks = model.schema.s.hooks.merge(schema2.s.hooks);
        schema2.plugins = Array.prototype.slice.call(baseSchema.plugins);
        schema2.callQueue = baseSchema.callQueue.concat(schema2.callQueue);
        delete schema2._requiredpaths;
      }
      merge2(schema, model.schema);
      if (!model.discriminators) {
        model.discriminators = {};
      }
      if (!model.schema.discriminatorMapping) {
        model.schema.discriminatorMapping = { key, value: null, isRoot: true };
      }
      if (!model.schema.discriminators) {
        model.schema.discriminators = {};
      }
      model.schema.discriminators[name] = schema;
      if (model.discriminators[name]) {
        throw new Error('Discriminator with name "' + name + '" already exists');
      }
      return schema;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/handleIdOption.js
var require_handleIdOption = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/handleIdOption.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var addAutoId = require_addAutoId();
    module2.exports = function handleIdOption(schema, options) {
      if (options == null || options._id == null) {
        return schema;
      }
      schema = schema.clone();
      if (!options._id) {
        schema.remove("_id");
        schema.options._id = false;
      } else if (!schema.paths["_id"]) {
        addAutoId(schema);
        schema.options._id = true;
      }
      return schema;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js
var require_getConstructor = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    module2.exports = function getConstructor(Constructor, value) {
      const discriminatorKey = Constructor.schema.options.discriminatorKey;
      if (value != null && Constructor.discriminators && value[discriminatorKey] != null) {
        if (Constructor.discriminators[value[discriminatorKey]]) {
          Constructor = Constructor.discriminators[value[discriminatorKey]];
        } else {
          const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[discriminatorKey]);
          if (constructorByValue) {
            Constructor = constructorByValue;
          }
        }
      }
      return Constructor;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/documentarray.js
var require_documentarray2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/documentarray.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ArrayType = require_array2();
    var CastError = require_cast();
    var EventEmitter = require("events").EventEmitter;
    var SchemaDocumentArrayOptions = require_SchemaDocumentArrayOptions();
    var SchemaType = require_schematype();
    var ValidationError = require_validation();
    var discriminator = require_discriminator();
    var get = require_get();
    var handleIdOption = require_handleIdOption();
    var util2 = require("util");
    var utils = require_utils2();
    var getConstructor = require_getConstructor();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var arrayPathSymbol = require_symbols().arrayPathSymbol;
    var documentArrayParent = require_symbols().documentArrayParent;
    var MongooseDocumentArray;
    var Subdocument;
    function DocumentArrayPath(key, schema, options, schemaOptions) {
      if (schemaOptions != null && schemaOptions._id != null) {
        schema = handleIdOption(schema, schemaOptions);
      } else if (options != null && options._id != null) {
        schema = handleIdOption(schema, options);
      }
      const EmbeddedDocument = _createConstructor(schema, options);
      EmbeddedDocument.prototype.$basePath = key;
      ArrayType.call(this, key, EmbeddedDocument, options);
      this.schema = schema;
      this.schemaOptions = schemaOptions || {};
      this.$isMongooseDocumentArray = true;
      this.Constructor = EmbeddedDocument;
      EmbeddedDocument.base = schema.base;
      const fn = this.defaultValue;
      if (!("defaultValue" in this) || fn !== void 0) {
        this.default(function() {
          let arr = fn.call(this);
          if (!Array.isArray(arr)) {
            arr = [arr];
          }
          return arr;
        });
      }
      const parentSchemaType = this;
      this.$embeddedSchemaType = new SchemaType(key + ".$", {
        required: get(this, "schemaOptions.required", false)
      });
      this.$embeddedSchemaType.cast = function(value, doc, init) {
        return parentSchemaType.cast(value, doc, init)[0];
      };
      this.$embeddedSchemaType.$isMongooseDocumentArrayElement = true;
      this.$embeddedSchemaType.caster = this.Constructor;
      this.$embeddedSchemaType.schema = this.schema;
    }
    DocumentArrayPath.schemaName = "DocumentArray";
    DocumentArrayPath.options = { castNonArrays: true };
    DocumentArrayPath.prototype = Object.create(ArrayType.prototype);
    DocumentArrayPath.prototype.constructor = DocumentArrayPath;
    DocumentArrayPath.prototype.OptionsConstructor = SchemaDocumentArrayOptions;
    function _createConstructor(schema, options, baseClass) {
      Subdocument || (Subdocument = require_embedded());
      function EmbeddedDocument() {
        Subdocument.apply(this, arguments);
        this.$session(this.ownerDocument().$session());
      }
      const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
      EmbeddedDocument.prototype = Object.create(proto);
      EmbeddedDocument.prototype.$__setSchema(schema);
      EmbeddedDocument.schema = schema;
      EmbeddedDocument.prototype.constructor = EmbeddedDocument;
      EmbeddedDocument.$isArraySubdocument = true;
      EmbeddedDocument.events = new EventEmitter();
      for (const i in schema.methods) {
        EmbeddedDocument.prototype[i] = schema.methods[i];
      }
      for (const i in schema.statics) {
        EmbeddedDocument[i] = schema.statics[i];
      }
      for (const i in EventEmitter.prototype) {
        EmbeddedDocument[i] = EventEmitter.prototype[i];
      }
      EmbeddedDocument.options = options;
      return EmbeddedDocument;
    }
    DocumentArrayPath.prototype.discriminator = function(name, schema, tiedValue) {
      if (typeof name === "function") {
        name = utils.getFunctionName(name);
      }
      schema = discriminator(this.casterConstructor, name, schema, tiedValue);
      const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);
      EmbeddedDocument.baseCasterConstructor = this.casterConstructor;
      try {
        Object.defineProperty(EmbeddedDocument, "name", {
          value: name
        });
      } catch (error) {
      }
      this.casterConstructor.discriminators[name] = EmbeddedDocument;
      return this.casterConstructor.discriminators[name];
    };
    DocumentArrayPath.prototype.doValidate = function(array, fn, scope, options) {
      MongooseDocumentArray || (MongooseDocumentArray = require_documentarray());
      const _this = this;
      try {
        SchemaType.prototype.doValidate.call(this, array, cb, scope);
      } catch (err) {
        err.$isArrayValidatorError = true;
        return fn(err);
      }
      function cb(err) {
        if (err) {
          err.$isArrayValidatorError = true;
          return fn(err);
        }
        let count = array && array.length;
        let error;
        if (!count) {
          return fn();
        }
        if (options && options.updateValidator) {
          return fn();
        }
        if (!array.isMongooseDocumentArray) {
          array = new MongooseDocumentArray(array, _this.path, scope);
        }
        function callback(err2) {
          if (err2 != null) {
            error = err2;
            if (!(error instanceof ValidationError)) {
              error.$isArrayValidatorError = true;
            }
          }
          --count || fn(error);
        }
        for (let i = 0, len = count; i < len; ++i) {
          let doc = array[i];
          if (doc == null) {
            --count || fn(error);
            continue;
          }
          if (!(doc instanceof Subdocument)) {
            const Constructor = getConstructor(_this.casterConstructor, array[i]);
            doc = array[i] = new Constructor(doc, array, void 0, void 0, i);
          }
          if (options != null && options.validateModifiedOnly && !doc.isModified()) {
            --count || fn(error);
            continue;
          }
          doc.$__validate(callback);
        }
      }
    };
    DocumentArrayPath.prototype.doValidateSync = function(array, scope, options) {
      const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
      if (schemaTypeError != null) {
        schemaTypeError.$isArrayValidatorError = true;
        return schemaTypeError;
      }
      const count = array && array.length;
      let resultError = null;
      if (!count) {
        return;
      }
      for (let i = 0, len = count; i < len; ++i) {
        let doc = array[i];
        if (!doc) {
          continue;
        }
        if (!(doc instanceof Subdocument)) {
          const Constructor = getConstructor(this.casterConstructor, array[i]);
          doc = array[i] = new Constructor(doc, array, void 0, void 0, i);
        }
        if (options != null && options.validateModifiedOnly && !doc.isModified()) {
          continue;
        }
        const subdocValidateError = doc.validateSync();
        if (subdocValidateError && resultError == null) {
          resultError = subdocValidateError;
        }
      }
      return resultError;
    };
    DocumentArrayPath.prototype.getDefault = function(scope) {
      let ret2 = typeof this.defaultValue === "function" ? this.defaultValue.call(scope) : this.defaultValue;
      if (ret2 == null) {
        return ret2;
      }
      MongooseDocumentArray || (MongooseDocumentArray = require_documentarray());
      if (!Array.isArray(ret2)) {
        ret2 = [ret2];
      }
      ret2 = new MongooseDocumentArray(ret2, this.path, scope);
      for (let i = 0; i < ret2.length; ++i) {
        const Constructor = getConstructor(this.casterConstructor, ret2[i]);
        const _subdoc = new Constructor(
          {},
          ret2,
          void 0,
          void 0,
          i
        );
        _subdoc.init(ret2[i]);
        _subdoc.isNew = true;
        Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);
        _subdoc.$__.activePaths.init = {};
        ret2[i] = _subdoc;
      }
      return ret2;
    };
    DocumentArrayPath.prototype.cast = function(value, doc, init, prev, options) {
      MongooseDocumentArray || (MongooseDocumentArray = require_documentarray());
      if (value != null && value[arrayPathSymbol] != null && value === prev) {
        return value;
      }
      let selected;
      let subdoc;
      const _opts = { transform: false, virtuals: false };
      options = options || {};
      if (!Array.isArray(value)) {
        if (!init && !DocumentArrayPath.options.castNonArrays) {
          throw new CastError("DocumentArray", util2.inspect(value), this.path, null, this);
        }
        if (!!doc && init) {
          doc.markModified(this.path);
        }
        return this.cast([value], doc, init, prev, options);
      }
      if (!(value && value.isMongooseDocumentArray) && !options.skipDocumentArrayCast) {
        value = new MongooseDocumentArray(value, this.path, doc);
      } else if (value && value.isMongooseDocumentArray) {
        value = new MongooseDocumentArray(value, this.path, doc);
      }
      if (prev != null) {
        value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};
      }
      if (options.arrayPathIndex != null) {
        value[arrayPathSymbol] = this.path + "." + options.arrayPathIndex;
      }
      const len = value.length;
      const initDocumentOptions = { skipId: true, willInit: true };
      for (let i = 0; i < len; ++i) {
        if (!value[i]) {
          continue;
        }
        const Constructor = getConstructor(this.casterConstructor, value[i]);
        if (value[i].$__ && (!(value[i] instanceof Constructor) || value[i][documentArrayParent] !== doc)) {
          value[i] = value[i].toObject({
            transform: false,
            // Special case: if different model, but same schema, apply virtuals
            // re: gh-7898
            virtuals: value[i].schema === Constructor.schema
          });
        }
        if (value[i] instanceof Subdocument) {
          if (value[i].__index == null) {
            value[i].$setIndex(i);
          }
        } else if (value[i] != null) {
          if (init) {
            if (doc) {
              selected || (selected = scopePaths(this, doc.$__.selected, init));
            } else {
              selected = true;
            }
            subdoc = new Constructor(null, value, initDocumentOptions, selected, i);
            value[i] = subdoc.init(value[i]);
          } else {
            if (prev && typeof prev.id === "function") {
              subdoc = prev.id(value[i]._id);
            }
            if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), value[i])) {
              subdoc.set(value[i]);
              value[i] = subdoc;
            } else {
              try {
                subdoc = new Constructor(
                  value[i],
                  value,
                  void 0,
                  void 0,
                  i
                );
                value[i] = subdoc;
              } catch (error) {
                const valueInErrorMessage = util2.inspect(value[i]);
                throw new CastError(
                  "embedded",
                  valueInErrorMessage,
                  value[arrayPathSymbol],
                  error,
                  this
                );
              }
            }
          }
        }
      }
      return value;
    };
    DocumentArrayPath.prototype.clone = function() {
      const options = Object.assign({}, this.options);
      const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0) {
        schematype.requiredValidator = this.requiredValidator;
      }
      schematype.Constructor.discriminators = Object.assign(
        {},
        this.Constructor.discriminators
      );
      return schematype;
    };
    DocumentArrayPath.prototype.applyGetters = function(value, scope) {
      return SchemaType.prototype.applyGetters.call(this, value, scope);
    };
    function scopePaths(array, fields, init) {
      if (!(init && fields)) {
        return void 0;
      }
      const path3 = array.path + ".";
      const keys = Object.keys(fields);
      let i = keys.length;
      const selected = {};
      let hasKeys;
      let key;
      let sub;
      while (i--) {
        key = keys[i];
        if (key.startsWith(path3)) {
          sub = key.substring(path3.length);
          if (sub === "$") {
            continue;
          }
          if (sub.startsWith("$.")) {
            sub = sub.substr(2);
          }
          hasKeys || (hasKeys = true);
          selected[sub] = fields[key];
        }
      }
      return hasKeys && selected || void 0;
    }
    DocumentArrayPath.defaultOptions = {};
    DocumentArrayPath.set = SchemaType.set;
    module2.exports = DocumentArrayPath;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaSingleNestedOptions.js
var require_SchemaSingleNestedOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaSingleNestedOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaSingleNestedOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaSingleNestedOptions.prototype, "_id", opts);
    module2.exports = SchemaSingleNestedOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/SingleNestedPath.js
var require_SingleNestedPath = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/SingleNestedPath.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var CastError = require_cast();
    var EventEmitter = require("events").EventEmitter;
    var ObjectExpectedError = require_objectExpected();
    var SchemaSingleNestedOptions = require_SchemaSingleNestedOptions();
    var SchemaType = require_schematype();
    var $exists2 = require_exists();
    var castToNumber = require_helpers().castToNumber;
    var discriminator = require_discriminator();
    var geospatial = require_geospatial();
    var get = require_get();
    var getConstructor = require_getConstructor();
    var handleIdOption = require_handleIdOption();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var Subdocument;
    module2.exports = SingleNestedPath;
    function SingleNestedPath(schema, path3, options) {
      schema = handleIdOption(schema, options);
      this.caster = _createConstructor(schema);
      this.caster.path = path3;
      this.caster.prototype.$basePath = path3;
      this.schema = schema;
      this.$isSingleNested = true;
      SchemaType.call(this, path3, options, "Embedded");
    }
    SingleNestedPath.prototype = Object.create(SchemaType.prototype);
    SingleNestedPath.prototype.constructor = SingleNestedPath;
    SingleNestedPath.prototype.OptionsConstructor = SchemaSingleNestedOptions;
    function _createConstructor(schema, baseClass) {
      Subdocument || (Subdocument = require_subdocument());
      const _embedded = function SingleNested(value, path3, parent) {
        const _this = this;
        this.$__parent = parent;
        Subdocument.apply(this, arguments);
        this.$session(this.ownerDocument().$session());
        if (parent) {
          parent.on("save", function() {
            _this.emit("save", _this);
            _this.constructor.emit("save", _this);
          });
          parent.on("isNew", function(val) {
            _this.isNew = val;
            _this.emit("isNew", val);
            _this.constructor.emit("isNew", val);
          });
        }
      };
      const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
      _embedded.prototype = Object.create(proto);
      _embedded.prototype.$__setSchema(schema);
      _embedded.prototype.constructor = _embedded;
      _embedded.schema = schema;
      _embedded.$isSingleNested = true;
      _embedded.events = new EventEmitter();
      _embedded.prototype.toBSON = function() {
        return this.toObject(internalToObjectOptions);
      };
      for (const i in schema.methods) {
        _embedded.prototype[i] = schema.methods[i];
      }
      for (const i in schema.statics) {
        _embedded[i] = schema.statics[i];
      }
      for (const i in EventEmitter.prototype) {
        _embedded[i] = EventEmitter.prototype[i];
      }
      return _embedded;
    }
    SingleNestedPath.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {
      return { $geometry: this.castForQuery(val.$geometry) };
    };
    SingleNestedPath.prototype.$conditionalHandlers.$near = SingleNestedPath.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;
    SingleNestedPath.prototype.$conditionalHandlers.$within = SingleNestedPath.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;
    SingleNestedPath.prototype.$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;
    SingleNestedPath.prototype.$conditionalHandlers.$minDistance = castToNumber;
    SingleNestedPath.prototype.$conditionalHandlers.$maxDistance = castToNumber;
    SingleNestedPath.prototype.$conditionalHandlers.$exists = $exists2;
    SingleNestedPath.prototype.cast = function(val, doc, init, priorVal, options) {
      if (val && val.$isSingleNested && val.parent === doc) {
        return val;
      }
      if (val != null && (typeof val !== "object" || Array.isArray(val))) {
        throw new ObjectExpectedError(this.path, val);
      }
      const Constructor = getConstructor(this.caster, val);
      let subdoc;
      const parentSelected = get(doc, "$__.selected", {});
      const path3 = this.path;
      const selected = Object.keys(parentSelected).reduce((obj2, key) => {
        if (key.startsWith(path3 + ".")) {
          obj2[key.substr(path3.length + 1)] = parentSelected[key];
        }
        return obj2;
      }, {});
      options = Object.assign({}, options, { priorDoc: priorVal });
      if (init) {
        subdoc = new Constructor(void 0, selected, doc);
        subdoc.init(val);
      } else {
        if (Object.keys(val).length === 0) {
          return new Constructor({}, selected, doc, void 0, options);
        }
        return new Constructor(val, selected, doc, void 0, options);
      }
      return subdoc;
    };
    SingleNestedPath.prototype.castForQuery = function($conditional, val, options) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional);
        }
        return handler.call(this, val);
      }
      val = $conditional;
      if (val == null) {
        return val;
      }
      if (this.options.runSetters) {
        val = this._applySetters(val);
      }
      const Constructor = getConstructor(this.caster, val);
      const overrideStrict = options != null && options.strict != null ? options.strict : void 0;
      try {
        val = new Constructor(val, overrideStrict);
      } catch (error) {
        if (!(error instanceof CastError)) {
          throw new CastError("Embedded", val, this.path, error, this);
        }
        throw error;
      }
      return val;
    };
    SingleNestedPath.prototype.doValidate = function(value, fn, scope, options) {
      const Constructor = getConstructor(this.caster, value);
      if (options && options.skipSchemaValidators) {
        if (!(value instanceof Constructor)) {
          value = new Constructor(value, null, scope);
        }
        return value.validate(fn);
      }
      SchemaType.prototype.doValidate.call(this, value, function(error) {
        if (error) {
          return fn(error);
        }
        if (!value) {
          return fn(null);
        }
        value.validate(fn);
      }, scope, options);
    };
    SingleNestedPath.prototype.doValidateSync = function(value, scope, options) {
      if (!options || !options.skipSchemaValidators) {
        const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);
        if (schemaTypeError) {
          return schemaTypeError;
        }
      }
      if (!value) {
        return;
      }
      return value.validateSync();
    };
    SingleNestedPath.prototype.discriminator = function(name, schema, value) {
      schema = discriminator(this.caster, name, schema, value);
      this.caster.discriminators[name] = _createConstructor(schema, this.caster);
      return this.caster.discriminators[name];
    };
    SingleNestedPath.defaultOptions = {};
    SingleNestedPath.set = SchemaType.set;
    SingleNestedPath.prototype.clone = function() {
      const options = Object.assign({}, this.options);
      const schematype = new this.constructor(this.schema, this.path, options);
      schematype.validators = this.validators.slice();
      if (this.requiredValidator !== void 0) {
        schematype.requiredValidator = this.requiredValidator;
      }
      schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);
      return schematype;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaBufferOptions.js
var require_SchemaBufferOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaBufferOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaBufferOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaBufferOptions.prototype, "subtype", opts);
    module2.exports = SchemaBufferOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/buffer.js
var require_buffer2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/buffer.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseBuffer = require_buffer();
    var SchemaBufferOptions = require_SchemaBufferOptions();
    var SchemaType = require_schematype();
    var handleBitwiseOperator = require_bitwise();
    var utils = require_utils2();
    var Binary = MongooseBuffer.Binary;
    var CastError = SchemaType.CastError;
    function SchemaBuffer(key, options) {
      SchemaType.call(this, key, options, "Buffer");
    }
    SchemaBuffer.schemaName = "Buffer";
    SchemaBuffer.defaultOptions = {};
    SchemaBuffer.prototype = Object.create(SchemaType.prototype);
    SchemaBuffer.prototype.constructor = SchemaBuffer;
    SchemaBuffer.prototype.OptionsConstructor = SchemaBufferOptions;
    SchemaBuffer._checkRequired = (v) => !!(v && v.length);
    SchemaBuffer.set = SchemaType.set;
    SchemaBuffer.checkRequired = SchemaType.checkRequired;
    SchemaBuffer.prototype.checkRequired = function(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      return this.constructor._checkRequired(value);
    };
    SchemaBuffer.prototype.cast = function(value, doc, init) {
      let ret2;
      if (SchemaType._isRef(this, value, doc, init)) {
        if (value && value.isMongooseBuffer) {
          return value;
        }
        if (Buffer.isBuffer(value)) {
          if (!value || !value.isMongooseBuffer) {
            value = new MongooseBuffer(value, [this.path, doc]);
            if (this.options.subtype != null) {
              value._subtype = this.options.subtype;
            }
          }
          return value;
        }
        if (value instanceof Binary) {
          ret2 = new MongooseBuffer(value.value(true), [this.path, doc]);
          if (typeof value.sub_type !== "number") {
            throw new CastError("Buffer", value, this.path, null, this);
          }
          ret2._subtype = value.sub_type;
          return ret2;
        }
        return this._castRef(value, doc, init);
      }
      if (value && value._id) {
        value = value._id;
      }
      if (value && value.isMongooseBuffer) {
        return value;
      }
      if (Buffer.isBuffer(value)) {
        if (!value || !value.isMongooseBuffer) {
          value = new MongooseBuffer(value, [this.path, doc]);
          if (this.options.subtype != null) {
            value._subtype = this.options.subtype;
          }
        }
        return value;
      }
      if (value instanceof Binary) {
        ret2 = new MongooseBuffer(value.value(true), [this.path, doc]);
        if (typeof value.sub_type !== "number") {
          throw new CastError("Buffer", value, this.path, null, this);
        }
        ret2._subtype = value.sub_type;
        return ret2;
      }
      if (value === null) {
        return value;
      }
      const type = typeof value;
      if (type === "string" || type === "number" || Array.isArray(value) || type === "object" && value.type === "Buffer" && Array.isArray(value.data)) {
        if (type === "number") {
          value = [value];
        }
        ret2 = new MongooseBuffer(value, [this.path, doc]);
        if (this.options.subtype != null) {
          ret2._subtype = this.options.subtype;
        }
        return ret2;
      }
      throw new CastError("Buffer", value, this.path, null, this);
    };
    SchemaBuffer.prototype.subtype = function(subtype) {
      this.options.subtype = subtype;
      return this;
    };
    function handleSingle(val) {
      return this.castForQuery(val);
    }
    SchemaBuffer.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
      $bitsAllClear: handleBitwiseOperator,
      $bitsAnyClear: handleBitwiseOperator,
      $bitsAllSet: handleBitwiseOperator,
      $bitsAnySet: handleBitwiseOperator,
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    SchemaBuffer.prototype.castForQuery = function($conditional, val) {
      let handler;
      if (arguments.length === 2) {
        handler = this.$conditionalHandlers[$conditional];
        if (!handler) {
          throw new Error("Can't use " + $conditional + " with Buffer.");
        }
        return handler.call(this, val);
      }
      val = $conditional;
      const casted = this._castForQuery(val);
      return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;
    };
    module2.exports = SchemaBuffer;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaDateOptions.js
var require_SchemaDateOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaDateOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaDateOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaDateOptions.prototype, "min", opts);
    Object.defineProperty(SchemaDateOptions.prototype, "max", opts);
    Object.defineProperty(SchemaDateOptions.prototype, "expires", opts);
    module2.exports = SchemaDateOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast/date.js
var require_date = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast/date.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var assert = require("assert");
    module2.exports = function castDate(value) {
      if (value == null || value === "") {
        return null;
      }
      if (value instanceof Date) {
        assert.ok(!isNaN(value.valueOf()));
        return value;
      }
      let date;
      assert.ok(typeof value !== "boolean");
      if (value instanceof Number || typeof value === "number") {
        date = new Date(value);
      } else if (typeof value === "string" && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {
        date = new Date(Number(value));
      } else if (typeof value.valueOf === "function") {
        date = new Date(value.valueOf());
      } else {
        date = new Date(value);
      }
      if (!isNaN(date.valueOf())) {
        return date;
      }
      assert.ok(false);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/date.js
var require_date2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/date.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var SchemaDateOptions = require_SchemaDateOptions();
    var SchemaType = require_schematype();
    var castDate = require_date();
    var getConstructorName = require_getConstructorName();
    var utils = require_utils2();
    var CastError = SchemaType.CastError;
    function SchemaDate(key, options) {
      SchemaType.call(this, key, options, "Date");
    }
    SchemaDate.schemaName = "Date";
    SchemaDate.defaultOptions = {};
    SchemaDate.prototype = Object.create(SchemaType.prototype);
    SchemaDate.prototype.constructor = SchemaDate;
    SchemaDate.prototype.OptionsConstructor = SchemaDateOptions;
    SchemaDate._cast = castDate;
    SchemaDate.set = SchemaType.set;
    SchemaDate.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    SchemaDate._defaultCaster = (v) => {
      if (v != null && !(v instanceof Date)) {
        throw new Error();
      }
      return v;
    };
    SchemaDate.prototype.expires = function(when) {
      if (getConstructorName(this._index) !== "Object") {
        this._index = {};
      }
      this._index.expires = when;
      utils.expires(this._index);
      return this;
    };
    SchemaDate._checkRequired = (v) => v instanceof Date;
    SchemaDate.checkRequired = SchemaType.checkRequired;
    SchemaDate.prototype.checkRequired = function(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : SchemaDate.checkRequired();
      return _checkRequired(value);
    };
    SchemaDate.prototype.min = function(value, message) {
      if (this.minValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.minValidator;
        }, this);
      }
      if (value) {
        let msg = message || MongooseError.messages.Date.min;
        if (typeof msg === "string") {
          msg = msg.replace(/{MIN}/, value === Date.now ? "Date.now()" : value.toString());
        }
        const _this = this;
        this.validators.push({
          validator: this.minValidator = function(val) {
            let _value = value;
            if (typeof value === "function" && value !== Date.now) {
              _value = _value.call(this);
            }
            const min = _value === Date.now ? _value() : _this.cast(_value);
            return val === null || val.valueOf() >= min.valueOf();
          },
          message: msg,
          type: "min",
          min: value
        });
      }
      return this;
    };
    SchemaDate.prototype.max = function(value, message) {
      if (this.maxValidator) {
        this.validators = this.validators.filter(function(v) {
          return v.validator !== this.maxValidator;
        }, this);
      }
      if (value) {
        let msg = message || MongooseError.messages.Date.max;
        if (typeof msg === "string") {
          msg = msg.replace(/{MAX}/, value === Date.now ? "Date.now()" : value.toString());
        }
        const _this = this;
        this.validators.push({
          validator: this.maxValidator = function(val) {
            let _value = value;
            if (typeof _value === "function" && _value !== Date.now) {
              _value = _value.call(this);
            }
            const max = _value === Date.now ? _value() : _this.cast(_value);
            return val === null || val.valueOf() <= max.valueOf();
          },
          message: msg,
          type: "max",
          max: value
        });
      }
      return this;
    };
    SchemaDate.prototype.cast = function(value) {
      let castDate2;
      if (typeof this._castFunction === "function") {
        castDate2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castDate2 = this.constructor.cast();
      } else {
        castDate2 = SchemaDate.cast();
      }
      try {
        return castDate2(value);
      } catch (error) {
        throw new CastError("date", value, this.path, error, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    SchemaDate.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    SchemaDate.prototype.castForQuery = function($conditional, val) {
      if (arguments.length !== 2) {
        return this._castForQuery($conditional);
      }
      const handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can't use " + $conditional + " with Date.");
      }
      return handler.call(this, val);
    };
    module2.exports = SchemaDate;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaObjectIdOptions.js
var require_SchemaObjectIdOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaObjectIdOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaObjectIdOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaObjectIdOptions.prototype, "auto", opts);
    Object.defineProperty(SchemaObjectIdOptions.prototype, "populate", opts);
    module2.exports = SchemaObjectIdOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/objectid.js
var require_objectid4 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/objectid.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SchemaObjectIdOptions = require_SchemaObjectIdOptions();
    var SchemaType = require_schematype();
    var castObjectId = require_objectid3();
    var getConstructorName = require_getConstructorName();
    var oid = require_objectid2();
    var utils = require_utils2();
    var CastError = SchemaType.CastError;
    var Document6;
    function ObjectId2(key, options) {
      const isKeyHexStr = typeof key === "string" && key.length === 24 && /^[a-f0-9]+$/i.test(key);
      const suppressWarning = options && options.suppressWarning;
      if ((isKeyHexStr || typeof key === "undefined") && !suppressWarning) {
        console.warn("mongoose: To create a new ObjectId please try `Mongoose.Types.ObjectId` instead of using `Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if you're trying to create a hex char path in your schema.");
        console.trace();
      }
      SchemaType.call(this, key, options, "ObjectID");
    }
    ObjectId2.schemaName = "ObjectId";
    ObjectId2.defaultOptions = {};
    ObjectId2.prototype = Object.create(SchemaType.prototype);
    ObjectId2.prototype.constructor = ObjectId2;
    ObjectId2.prototype.OptionsConstructor = SchemaObjectIdOptions;
    ObjectId2.get = SchemaType.get;
    ObjectId2.set = SchemaType.set;
    ObjectId2.prototype.auto = function(turnOn) {
      if (turnOn) {
        this.default(defaultId);
        this.set(resetId);
      }
      return this;
    };
    ObjectId2._checkRequired = (v) => v instanceof oid;
    ObjectId2._cast = castObjectId;
    ObjectId2.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    ObjectId2._defaultCaster = (v) => {
      if (!(v instanceof oid)) {
        throw new Error(v + " is not an instance of ObjectId");
      }
      return v;
    };
    ObjectId2.checkRequired = SchemaType.checkRequired;
    ObjectId2.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : ObjectId2.checkRequired();
      return _checkRequired(value);
    };
    ObjectId2.prototype.cast = function(value, doc, init) {
      if (SchemaType._isRef(this, value, doc, init)) {
        if (value instanceof oid) {
          return value;
        } else if ((getConstructorName(value) || "").toLowerCase() === "objectid") {
          return new oid(value.toHexString());
        }
        return this._castRef(value, doc, init);
      }
      let castObjectId2;
      if (typeof this._castFunction === "function") {
        castObjectId2 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castObjectId2 = this.constructor.cast();
      } else {
        castObjectId2 = ObjectId2.cast();
      }
      try {
        return castObjectId2(value);
      } catch (error) {
        throw new CastError("ObjectId", value, this.path, error, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    ObjectId2.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    function defaultId() {
      return new oid();
    }
    defaultId.$runBeforeSetters = true;
    function resetId(v) {
      Document6 || (Document6 = require_document());
      if (this instanceof Document6) {
        if (v === void 0) {
          const _v = new oid();
          this.$__._id = _v;
          return _v;
        }
        this.$__._id = v;
      }
      return v;
    }
    module2.exports = ObjectId2;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast/decimal128.js
var require_decimal1282 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cast/decimal128.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Decimal128Type = require_decimal128();
    var assert = require("assert");
    module2.exports = function castDecimal128(value) {
      if (value == null) {
        return value;
      }
      if (typeof value === "object" && typeof value.$numberDecimal === "string") {
        return Decimal128Type.fromString(value.$numberDecimal);
      }
      if (value instanceof Decimal128Type) {
        return value;
      }
      if (typeof value === "string") {
        return Decimal128Type.fromString(value);
      }
      if (Buffer.isBuffer(value)) {
        return new Decimal128Type(value);
      }
      if (typeof value === "number") {
        return Decimal128Type.fromString(String(value));
      }
      if (typeof value.valueOf === "function" && typeof value.valueOf() === "string") {
        return Decimal128Type.fromString(value.valueOf());
      }
      assert.ok(false);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/decimal128.js
var require_decimal1283 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/decimal128.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SchemaType = require_schematype();
    var CastError = SchemaType.CastError;
    var Decimal128Type = require_decimal128();
    var castDecimal128 = require_decimal1282();
    var utils = require_utils2();
    function Decimal128(key, options) {
      SchemaType.call(this, key, options, "Decimal128");
    }
    Decimal128.schemaName = "Decimal128";
    Decimal128.defaultOptions = {};
    Decimal128.prototype = Object.create(SchemaType.prototype);
    Decimal128.prototype.constructor = Decimal128;
    Decimal128._cast = castDecimal128;
    Decimal128.set = SchemaType.set;
    Decimal128.cast = function cast(caster) {
      if (arguments.length === 0) {
        return this._cast;
      }
      if (caster === false) {
        caster = this._defaultCaster;
      }
      this._cast = caster;
      return this._cast;
    };
    Decimal128._defaultCaster = (v) => {
      if (v != null && !(v instanceof Decimal128Type)) {
        throw new Error();
      }
      return v;
    };
    Decimal128._checkRequired = (v) => v instanceof Decimal128Type;
    Decimal128.checkRequired = SchemaType.checkRequired;
    Decimal128.prototype.checkRequired = function checkRequired(value, doc) {
      if (SchemaType._isRef(this, value, doc, true)) {
        return !!value;
      }
      const _checkRequired = typeof this.constructor.checkRequired == "function" ? this.constructor.checkRequired() : Decimal128.checkRequired();
      return _checkRequired(value);
    };
    Decimal128.prototype.cast = function(value, doc, init) {
      if (SchemaType._isRef(this, value, doc, init)) {
        if (value instanceof Decimal128Type) {
          return value;
        }
        return this._castRef(value, doc, init);
      }
      let castDecimal1282;
      if (typeof this._castFunction === "function") {
        castDecimal1282 = this._castFunction;
      } else if (typeof this.constructor.cast === "function") {
        castDecimal1282 = this.constructor.cast();
      } else {
        castDecimal1282 = Decimal128.cast();
      }
      try {
        return castDecimal1282(value);
      } catch (error) {
        throw new CastError("Decimal128", value, this.path, error, this);
      }
    };
    function handleSingle(val) {
      return this.cast(val);
    }
    Decimal128.prototype.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {
      $gt: handleSingle,
      $gte: handleSingle,
      $lt: handleSingle,
      $lte: handleSingle
    });
    module2.exports = Decimal128;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaMapOptions.js
var require_SchemaMapOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/SchemaMapOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var SchemaMapOptions = class extends SchemaTypeOptions {
    };
    var opts = require_propertyOptions();
    Object.defineProperty(SchemaMapOptions.prototype, "of", opts);
    module2.exports = SchemaMapOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/map.js
var require_map3 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/map.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseMap = require_map2();
    var SchemaMapOptions = require_SchemaMapOptions();
    var SchemaType = require_schematype();
    var Map2 = class extends SchemaType {
      constructor(key, options) {
        super(key, options, "Map");
        this.$isSchemaMap = true;
      }
      set(option, value) {
        return SchemaType.set(option, value);
      }
      cast(val, doc, init) {
        if (val instanceof MongooseMap) {
          return val;
        }
        const path3 = this.path;
        if (init) {
          const map = new MongooseMap({}, path3, doc, this.$__schemaType);
          if (val instanceof global.Map) {
            for (const key of val.keys()) {
              let _val = val.get(key);
              if (_val == null) {
                _val = map.$__schemaType._castNullish(_val);
              } else {
                _val = map.$__schemaType.cast(_val, doc, true, null, { path: path3 + "." + key });
              }
              map.$init(key, _val);
            }
          } else {
            for (const key of Object.keys(val)) {
              let _val = val[key];
              if (_val == null) {
                _val = map.$__schemaType._castNullish(_val);
              } else {
                _val = map.$__schemaType.cast(_val, doc, true, null, { path: path3 + "." + key });
              }
              map.$init(key, _val);
            }
          }
          return map;
        }
        return new MongooseMap(val, path3, doc, this.$__schemaType);
      }
      clone() {
        const schematype = super.clone();
        if (this.$__schemaType != null) {
          schematype.$__schemaType = this.$__schemaType.clone();
        }
        return schematype;
      }
    };
    Map2.prototype.OptionsConstructor = SchemaMapOptions;
    Map2.defaultOptions = {};
    module2.exports = Map2;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/index.js
var require_schema = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    exports2.String = require_string2();
    exports2.Number = require_number2();
    exports2.Boolean = require_boolean2();
    exports2.DocumentArray = require_documentarray2();
    exports2.Embedded = require_SingleNestedPath();
    exports2.Array = require_array2();
    exports2.Buffer = require_buffer2();
    exports2.Date = require_date2();
    exports2.ObjectId = require_objectid4();
    exports2.Mixed = require_mixed();
    exports2.Decimal128 = exports2.Decimal = require_decimal1283();
    exports2.Map = require_map3();
    exports2.Oid = exports2.ObjectId;
    exports2.Object = exports2.Mixed;
    exports2.Bool = exports2.Boolean;
    exports2.ObjectID = exports2.ObjectId;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema.js
var require_schema2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/schema.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var EventEmitter = require("events").EventEmitter;
    var Kareem = require_kareem();
    var MongooseError = require_mongooseError();
    var SchemaType = require_schematype();
    var SchemaTypeOptions = require_SchemaTypeOptions();
    var VirtualOptions = require_VirtualOptions();
    var VirtualType = require_virtualtype();
    var addAutoId = require_addAutoId();
    var arrayParentSymbol = require_symbols().arrayParentSymbol;
    var get = require_get();
    var getConstructorName = require_getConstructorName();
    var getIndexes = require_getIndexes();
    var merge2 = require_merge();
    var mpath = require_mpath();
    var readPref = require_driver().get().ReadPreference;
    var setupTimestamps = require_setupTimestamps();
    var util2 = require("util");
    var utils = require_utils2();
    var validateRef = require_validateRef();
    var MongooseTypes;
    var queryHooks = require_applyQueryMiddleware().middlewareFunctions;
    var documentHooks = require_applyHooks().middlewareFunctions;
    var hookNames = queryHooks.concat(documentHooks).reduce((s, hook) => s.add(hook), /* @__PURE__ */ new Set());
    var id = 0;
    function Schema6(obj2, options) {
      if (!(this instanceof Schema6)) {
        return new Schema6(obj2, options);
      }
      this.obj = obj2;
      this.paths = {};
      this.aliases = {};
      this.subpaths = {};
      this.virtuals = {};
      this.singleNestedPaths = {};
      this.nested = {};
      this.inherits = {};
      this.callQueue = [];
      this._indexes = [];
      this.methods = {};
      this.methodOptions = {};
      this.statics = {};
      this.tree = {};
      this.query = {};
      this.childSchemas = [];
      this.plugins = [];
      this.$id = ++id;
      this.mapPaths = [];
      this.s = {
        hooks: new Kareem()
      };
      this.options = this.defaultOptions(options);
      if (Array.isArray(obj2)) {
        for (const definition of obj2) {
          this.add(definition);
        }
      } else if (obj2) {
        this.add(obj2);
      }
      const _idSubDoc = obj2 && obj2._id && utils.isObject(obj2._id);
      const auto_id = !this.paths["_id"] && (!this.options.noId && this.options._id) && !_idSubDoc;
      if (auto_id) {
        addAutoId(this);
      }
      this.setupTimestamp(this.options.timestamps);
    }
    function aliasFields(schema, paths) {
      paths = paths || Object.keys(schema.paths);
      for (const path3 of paths) {
        const options = get(schema.paths[path3], "options");
        if (options == null) {
          continue;
        }
        const prop = schema.paths[path3].path;
        const alias = options.alias;
        if (!alias) {
          continue;
        }
        if (typeof alias !== "string") {
          throw new Error("Invalid value for alias option on " + prop + ", got " + alias);
        }
        schema.aliases[alias] = prop;
        schema.virtual(alias).get(function(p) {
          return function() {
            if (typeof this.get === "function") {
              return this.get(p);
            }
            return this[p];
          };
        }(prop)).set(function(p) {
          return function(v) {
            return this.$set(p, v);
          };
        }(prop));
      }
    }
    Schema6.prototype = Object.create(EventEmitter.prototype);
    Schema6.prototype.constructor = Schema6;
    Schema6.prototype.instanceOfSchema = true;
    Object.defineProperty(Schema6.prototype, "$schemaType", {
      configurable: false,
      enumerable: false,
      writable: true
    });
    Object.defineProperty(Schema6.prototype, "childSchemas", {
      configurable: false,
      enumerable: true,
      writable: true
    });
    Schema6.prototype.obj;
    Schema6.prototype.paths;
    Schema6.prototype.tree;
    Schema6.prototype.clone = function() {
      const Constructor = this.base == null ? Schema6 : this.base.Schema;
      const s = new Constructor({}, this._userProvidedOptions);
      s.base = this.base;
      s.obj = this.obj;
      s.options = utils.clone(this.options);
      s.callQueue = this.callQueue.map(function(f) {
        return f;
      });
      s.methods = utils.clone(this.methods);
      s.methodOptions = utils.clone(this.methodOptions);
      s.statics = utils.clone(this.statics);
      s.query = utils.clone(this.query);
      s.plugins = Array.prototype.slice.call(this.plugins);
      s._indexes = utils.clone(this._indexes);
      s.s.hooks = this.s.hooks.clone();
      s.tree = utils.clone(this.tree);
      s.paths = utils.clone(this.paths);
      s.nested = utils.clone(this.nested);
      s.subpaths = utils.clone(this.subpaths);
      s.singleNestedPaths = utils.clone(this.singleNestedPaths);
      s.childSchemas = gatherChildSchemas(s);
      s.virtuals = utils.clone(this.virtuals);
      s.$globalPluginsApplied = this.$globalPluginsApplied;
      s.$isRootDiscriminator = this.$isRootDiscriminator;
      s.$implicitlyCreated = this.$implicitlyCreated;
      s.mapPaths = [].concat(this.mapPaths);
      if (this.discriminatorMapping != null) {
        s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);
      }
      if (this.discriminators != null) {
        s.discriminators = Object.assign({}, this.discriminators);
      }
      s.aliases = Object.assign({}, this.aliases);
      s.on("init", (v) => this.emit("init", v));
      return s;
    };
    Schema6.prototype.pick = function(paths, options) {
      const newSchema = new Schema6({}, options || this.options);
      if (!Array.isArray(paths)) {
        throw new MongooseError('Schema#pick() only accepts an array argument, got "' + typeof paths + '"');
      }
      for (const path3 of paths) {
        if (this.nested[path3]) {
          newSchema.add({ [path3]: get(this.tree, path3) });
        } else {
          const schematype = this.path(path3);
          if (schematype == null) {
            throw new MongooseError("Path `" + path3 + "` is not in the schema");
          }
          newSchema.add({ [path3]: schematype });
        }
      }
      return newSchema;
    };
    Schema6.prototype.defaultOptions = function(options) {
      if (options && options.safe === false) {
        options.safe = { w: 0 };
      }
      if (options && options.safe && options.safe.w === 0) {
        options.versionKey = false;
      }
      this._userProvidedOptions = options == null ? {} : utils.clone(options);
      const baseOptions = get(this, "base.options", {});
      options = utils.options({
        strict: "strict" in baseOptions ? baseOptions.strict : true,
        strictQuery: "strictQuery" in baseOptions ? baseOptions.strictQuery : false,
        bufferCommands: true,
        capped: false,
        // { size, max, autoIndexId }
        versionKey: "__v",
        optimisticConcurrency: false,
        discriminatorKey: "__t",
        minimize: true,
        autoIndex: null,
        shardKey: null,
        read: null,
        validateBeforeSave: true,
        // the following are only applied at construction time
        noId: false,
        // deprecated, use { _id: false }
        _id: true,
        noVirtualId: false,
        // deprecated, use { id: false }
        id: true,
        typeKey: "type",
        typePojoToMixed: "typePojoToMixed" in baseOptions ? baseOptions.typePojoToMixed : true
      }, utils.clone(options));
      if (options.read) {
        options.read = readPref(options.read);
      }
      if (options.optimisticConcurrency && !options.versionKey) {
        throw new MongooseError("Must set `versionKey` if using `optimisticConcurrency`");
      }
      return options;
    };
    Schema6.prototype.add = function add(obj2, prefix) {
      if (obj2 instanceof Schema6 || obj2 != null && obj2.instanceOfSchema) {
        merge2(this, obj2);
        return this;
      }
      if (obj2._id === false && prefix == null) {
        this.options._id = false;
      }
      prefix = prefix || "";
      if (prefix === "__proto__." || prefix === "constructor." || prefix === "prototype.") {
        return this;
      }
      const keys = Object.keys(obj2);
      for (const key of keys) {
        if (utils.specialProperties.has(key)) {
          continue;
        }
        const fullPath = prefix + key;
        if (obj2[key] == null) {
          throw new TypeError("Invalid value for schema path `" + fullPath + '`, got value "' + obj2[key] + '"');
        }
        if (key === "_id" && obj2[key] === false) {
          continue;
        }
        if (obj2[key] instanceof VirtualType || get(obj2[key], "constructor.name", null) === "VirtualType") {
          this.virtual(obj2[key]);
          continue;
        }
        if (Array.isArray(obj2[key]) && obj2[key].length === 1 && obj2[key][0] == null) {
          throw new TypeError("Invalid value for schema Array path `" + fullPath + '`, got value "' + obj2[key][0] + '"');
        }
        if (!(utils.isPOJO(obj2[key]) || obj2[key] instanceof SchemaTypeOptions)) {
          if (prefix) {
            this.nested[prefix.substr(0, prefix.length - 1)] = true;
          }
          this.path(prefix + key, obj2[key]);
        } else if (Object.keys(obj2[key]).length < 1) {
          if (prefix) {
            this.nested[prefix.substr(0, prefix.length - 1)] = true;
          }
          this.path(fullPath, obj2[key]);
        } else if (!obj2[key][this.options.typeKey] || this.options.typeKey === "type" && obj2[key].type.type) {
          this.nested[fullPath] = true;
          this.add(obj2[key], fullPath + ".");
        } else {
          if (!this.options.typePojoToMixed && utils.isPOJO(obj2[key][this.options.typeKey])) {
            if (prefix) {
              this.nested[prefix.substr(0, prefix.length - 1)] = true;
            }
            const opts = { typePojoToMixed: false };
            const _schema = new Schema6(obj2[key][this.options.typeKey], opts);
            const schemaWrappedPath = Object.assign({}, obj2[key], { [this.options.typeKey]: _schema });
            this.path(prefix + key, schemaWrappedPath);
          } else {
            if (prefix) {
              this.nested[prefix.substr(0, prefix.length - 1)] = true;
            }
            this.path(prefix + key, obj2[key]);
          }
        }
      }
      const addedKeys = Object.keys(obj2).map((key) => prefix ? prefix + key : key);
      aliasFields(this, addedKeys);
      return this;
    };
    Schema6.reserved = /* @__PURE__ */ Object.create(null);
    Schema6.prototype.reserved = Schema6.reserved;
    var reserved = Schema6.reserved;
    reserved["prototype"] = // EventEmitter
    reserved.emit = reserved.listeners = reserved.on = reserved.removeListener = // document properties and functions
    reserved.collection = reserved.errors = reserved.get = reserved.init = reserved.isModified = reserved.isNew = reserved.populated = reserved.remove = reserved.save = reserved.toObject = reserved.validate = 1;
    Schema6.prototype.path = function(path3, obj2) {
      const cleanPath = _pathToPositionalSyntax(path3);
      if (obj2 === void 0) {
        let schematype = _getPath(this, path3, cleanPath);
        if (schematype != null) {
          return schematype;
        }
        const mapPath = getMapPath(this, path3);
        if (mapPath != null) {
          return mapPath;
        }
        schematype = this.hasMixedParent(cleanPath);
        if (schematype != null) {
          return schematype;
        }
        return /\.\d+\.?.*$/.test(path3) ? getPositionalPath(this, path3) : void 0;
      }
      const firstPieceOfPath = path3.split(".")[0];
      if (reserved[firstPieceOfPath]) {
        throw new Error("`" + firstPieceOfPath + "` may not be used as a schema pathname");
      }
      if (typeof obj2 === "object" && utils.hasUserDefinedProperty(obj2, "ref")) {
        validateRef(obj2.ref, path3);
      }
      const subpaths = path3.split(/\./);
      const last = subpaths.pop();
      let branch = this.tree;
      let fullPath = "";
      for (const sub of subpaths) {
        if (utils.specialProperties.has(sub)) {
          throw new Error("Cannot set special property `" + sub + "` on a schema");
        }
        fullPath = fullPath += (fullPath.length > 0 ? "." : "") + sub;
        if (!branch[sub]) {
          this.nested[fullPath] = true;
          branch[sub] = {};
        }
        if (typeof branch[sub] !== "object") {
          const msg = "Cannot set nested path `" + path3 + "`. Parent path `" + fullPath + "` already set to type " + branch[sub].name + ".";
          throw new Error(msg);
        }
        branch = branch[sub];
      }
      branch[last] = utils.clone(obj2);
      this.paths[path3] = this.interpretAsType(path3, obj2, this.options);
      const schemaType = this.paths[path3];
      if (schemaType.$isSchemaMap) {
        const mapPath = path3 + ".$*";
        let _mapType = { type: {} };
        if (utils.hasUserDefinedProperty(obj2, "of")) {
          const isInlineSchema = utils.isPOJO(obj2.of) && Object.keys(obj2.of).length > 0 && !utils.hasUserDefinedProperty(obj2.of, this.options.typeKey);
          _mapType = isInlineSchema ? new Schema6(obj2.of) : obj2.of;
        }
        if (utils.hasUserDefinedProperty(obj2, "ref")) {
          _mapType = { type: _mapType, ref: obj2.ref };
        }
        this.paths[mapPath] = this.interpretAsType(
          mapPath,
          _mapType,
          this.options
        );
        this.mapPaths.push(this.paths[mapPath]);
        schemaType.$__schemaType = this.paths[mapPath];
      }
      if (schemaType.$isSingleNested) {
        for (const key of Object.keys(schemaType.schema.paths)) {
          this.singleNestedPaths[path3 + "." + key] = schemaType.schema.paths[key];
        }
        for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
          this.singleNestedPaths[path3 + "." + key] = schemaType.schema.singleNestedPaths[key];
        }
        for (const key of Object.keys(schemaType.schema.subpaths)) {
          this.singleNestedPaths[path3 + "." + key] = schemaType.schema.subpaths[key];
        }
        for (const key of Object.keys(schemaType.schema.nested)) {
          this.singleNestedPaths[path3 + "." + key] = "nested";
        }
        Object.defineProperty(schemaType.schema, "base", {
          configurable: true,
          enumerable: false,
          writable: false,
          value: this.base
        });
        schemaType.caster.base = this.base;
        this.childSchemas.push({
          schema: schemaType.schema,
          model: schemaType.caster
        });
      } else if (schemaType.$isMongooseDocumentArray) {
        Object.defineProperty(schemaType.schema, "base", {
          configurable: true,
          enumerable: false,
          writable: false,
          value: this.base
        });
        schemaType.casterConstructor.base = this.base;
        this.childSchemas.push({
          schema: schemaType.schema,
          model: schemaType.casterConstructor
        });
      }
      if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {
        let arrayPath = path3;
        let _schemaType = schemaType;
        const toAdd = [];
        while (_schemaType.$isMongooseArray) {
          arrayPath = arrayPath + ".$";
          if (_schemaType.$isMongooseDocumentArray) {
            _schemaType.$embeddedSchemaType._arrayPath = arrayPath;
            _schemaType.$embeddedSchemaType._arrayParentPath = path3;
            _schemaType = _schemaType.$embeddedSchemaType.clone();
          } else {
            _schemaType.caster._arrayPath = arrayPath;
            _schemaType.caster._arrayParentPath = path3;
            _schemaType = _schemaType.caster.clone();
          }
          _schemaType.path = arrayPath;
          toAdd.push(_schemaType);
        }
        for (const _schemaType2 of toAdd) {
          this.subpaths[_schemaType2.path] = _schemaType2;
        }
      }
      if (schemaType.$isMongooseDocumentArray) {
        for (const key of Object.keys(schemaType.schema.paths)) {
          const _schemaType = schemaType.schema.paths[key];
          this.subpaths[path3 + "." + key] = _schemaType;
          if (typeof _schemaType === "object" && _schemaType != null) {
            _schemaType.$isUnderneathDocArray = true;
          }
        }
        for (const key of Object.keys(schemaType.schema.subpaths)) {
          const _schemaType = schemaType.schema.subpaths[key];
          this.subpaths[path3 + "." + key] = _schemaType;
          if (typeof _schemaType === "object" && _schemaType != null) {
            _schemaType.$isUnderneathDocArray = true;
          }
        }
        for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
          const _schemaType = schemaType.schema.singleNestedPaths[key];
          this.subpaths[path3 + "." + key] = _schemaType;
          if (typeof _schemaType === "object" && _schemaType != null) {
            _schemaType.$isUnderneathDocArray = true;
          }
        }
      }
      return this;
    };
    function gatherChildSchemas(schema) {
      const childSchemas = [];
      for (const path3 of Object.keys(schema.paths)) {
        const schematype = schema.paths[path3];
        if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {
          childSchemas.push({ schema: schematype.schema, model: schematype.caster });
        }
      }
      return childSchemas;
    }
    function _getPath(schema, path3, cleanPath) {
      if (schema.paths.hasOwnProperty(path3)) {
        return schema.paths[path3];
      }
      if (schema.subpaths.hasOwnProperty(cleanPath)) {
        return schema.subpaths[cleanPath];
      }
      if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === "object") {
        return schema.singleNestedPaths[cleanPath];
      }
      return null;
    }
    function _pathToPositionalSyntax(path3) {
      if (!/\.\d+/.test(path3)) {
        return path3;
      }
      return path3.replace(/\.\d+\./g, ".$.").replace(/\.\d+$/, ".$");
    }
    function getMapPath(schema, path3) {
      if (schema.mapPaths.length === 0) {
        return null;
      }
      for (const val of schema.mapPaths) {
        const _path = val.path;
        const re = new RegExp("^" + _path.replace(/\.\$\*/g, "\\.[^.]+") + "$");
        if (re.test(path3)) {
          return schema.paths[_path];
        }
      }
      return null;
    }
    Object.defineProperty(Schema6.prototype, "base", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: null
    });
    Schema6.prototype.interpretAsType = function(path3, obj2, options) {
      if (obj2 instanceof SchemaType) {
        if (obj2.path === path3) {
          return obj2;
        }
        const clone = obj2.clone();
        clone.path = path3;
        return clone;
      }
      const MongooseTypes2 = this.base != null ? this.base.Schema.Types : Schema6.Types;
      if (!utils.isPOJO(obj2) && !(obj2 instanceof SchemaTypeOptions)) {
        const constructorName = utils.getFunctionName(obj2.constructor);
        if (constructorName !== "Object") {
          const oldObj = obj2;
          obj2 = {};
          obj2[options.typeKey] = oldObj;
        }
      }
      let type = obj2[options.typeKey] && (options.typeKey !== "type" || !obj2.type.type) ? obj2[options.typeKey] : {};
      let name;
      if (utils.isPOJO(type) || type === "mixed") {
        return new MongooseTypes2.Mixed(path3, obj2);
      }
      if (Array.isArray(type) || type === Array || type === "array" || type === MongooseTypes2.Array) {
        let cast = type === Array || type === "array" ? obj2.cast || obj2.of : type[0];
        if (cast && cast.instanceOfSchema) {
          if (!(cast instanceof Schema6)) {
            throw new TypeError("Schema for array path `" + path3 + "` is from a different copy of the Mongoose module. Please make sure you're using the same version of Mongoose everywhere with `npm list mongoose`.");
          }
          return new MongooseTypes2.DocumentArray(path3, cast, obj2);
        }
        if (cast && cast[options.typeKey] && cast[options.typeKey].instanceOfSchema) {
          if (!(cast[options.typeKey] instanceof Schema6)) {
            throw new TypeError("Schema for array path `" + path3 + "` is from a different copy of the Mongoose module. Please make sure you're using the same version of Mongoose everywhere with `npm list mongoose`.");
          }
          return new MongooseTypes2.DocumentArray(path3, cast[options.typeKey], obj2, cast);
        }
        if (Array.isArray(cast)) {
          return new MongooseTypes2.Array(path3, this.interpretAsType(path3, cast, options), obj2);
        }
        if (typeof cast === "string") {
          cast = MongooseTypes2[cast.charAt(0).toUpperCase() + cast.substring(1)];
        } else if (cast && (!cast[options.typeKey] || options.typeKey === "type" && cast.type.type) && utils.isPOJO(cast)) {
          if (Object.keys(cast).length) {
            const childSchemaOptions = { minimize: options.minimize };
            if (options.typeKey) {
              childSchemaOptions.typeKey = options.typeKey;
            }
            if (options.hasOwnProperty("strict")) {
              childSchemaOptions.strict = options.strict;
            }
            if (options.hasOwnProperty("typePojoToMixed")) {
              childSchemaOptions.typePojoToMixed = options.typePojoToMixed;
            }
            if (this._userProvidedOptions.hasOwnProperty("_id")) {
              childSchemaOptions._id = this._userProvidedOptions._id;
            } else if (Schema6.Types.DocumentArray.defaultOptions && Schema6.Types.DocumentArray.defaultOptions._id != null) {
              childSchemaOptions._id = Schema6.Types.DocumentArray.defaultOptions._id;
            }
            const childSchema = new Schema6(cast, childSchemaOptions);
            childSchema.$implicitlyCreated = true;
            return new MongooseTypes2.DocumentArray(path3, childSchema, obj2);
          } else {
            return new MongooseTypes2.Array(path3, MongooseTypes2.Mixed, obj2);
          }
        }
        if (cast) {
          type = cast[options.typeKey] && (options.typeKey !== "type" || !cast.type.type) ? cast[options.typeKey] : cast;
          name = typeof type === "string" ? type : type.schemaName || utils.getFunctionName(type);
          if (name === "ClockDate") {
            name = "Date";
          }
          if (!MongooseTypes2.hasOwnProperty(name)) {
            throw new TypeError(`Invalid schema configuration: \`${name}\` is not a valid type within the array \`${path3}\`.See http://bit.ly/mongoose-schematypes for a list of valid schema types.`);
          }
        }
        return new MongooseTypes2.Array(path3, cast || MongooseTypes2.Mixed, obj2, options);
      }
      if (type && type.instanceOfSchema) {
        return new MongooseTypes2.Embedded(type, path3, obj2);
      }
      if (Buffer.isBuffer(type)) {
        name = "Buffer";
      } else if (typeof type === "function" || typeof type === "object") {
        name = type.schemaName || utils.getFunctionName(type);
      } else {
        name = type == null ? "" + type : type.toString();
      }
      if (name) {
        name = name.charAt(0).toUpperCase() + name.substring(1);
      }
      if (name === "ObjectID") {
        name = "ObjectId";
      }
      if (name === "ClockDate") {
        name = "Date";
      }
      if (MongooseTypes2[name] == null) {
        throw new TypeError(`Invalid schema configuration: \`${name}\` is not a valid type at path \`${path3}\`. See http://bit.ly/mongoose-schematypes for a list of valid schema types.`);
      }
      return new MongooseTypes2[name](path3, obj2);
    };
    Schema6.prototype.eachPath = function(fn) {
      const keys = Object.keys(this.paths);
      const len = keys.length;
      for (let i = 0; i < len; ++i) {
        fn(keys[i], this.paths[keys[i]]);
      }
      return this;
    };
    Schema6.prototype.requiredPaths = function requiredPaths(invalidate) {
      if (this._requiredpaths && !invalidate) {
        return this._requiredpaths;
      }
      const paths = Object.keys(this.paths);
      let i = paths.length;
      const ret2 = [];
      while (i--) {
        const path3 = paths[i];
        if (this.paths[path3].isRequired) {
          ret2.push(path3);
        }
      }
      this._requiredpaths = ret2;
      return this._requiredpaths;
    };
    Schema6.prototype.indexedPaths = function indexedPaths() {
      if (this._indexedpaths) {
        return this._indexedpaths;
      }
      this._indexedpaths = this.indexes();
      return this._indexedpaths;
    };
    Schema6.prototype.pathType = function(path3) {
      const cleanPath = _pathToPositionalSyntax(path3);
      if (this.paths.hasOwnProperty(path3)) {
        return "real";
      }
      if (this.virtuals.hasOwnProperty(path3)) {
        return "virtual";
      }
      if (this.nested.hasOwnProperty(path3)) {
        return "nested";
      }
      if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path3)) {
        return "real";
      }
      const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path3);
      if (singleNestedPath) {
        return singleNestedPath === "nested" ? "nested" : "real";
      }
      const mapPath = getMapPath(this, path3);
      if (mapPath != null) {
        return "real";
      }
      if (/\.\d+\.|\.\d+$/.test(path3)) {
        return getPositionalPathType(this, path3);
      }
      return "adhocOrUndefined";
    };
    Schema6.prototype.hasMixedParent = function(path3) {
      const subpaths = path3.split(/\./g);
      path3 = "";
      for (let i = 0; i < subpaths.length; ++i) {
        path3 = i > 0 ? path3 + "." + subpaths[i] : subpaths[i];
        if (this.paths.hasOwnProperty(path3) && this.paths[path3] instanceof MongooseTypes.Mixed) {
          return this.paths[path3];
        }
      }
      return null;
    };
    Schema6.prototype.setupTimestamp = function(timestamps) {
      return setupTimestamps(this, timestamps);
    };
    function getPositionalPathType(self2, path3) {
      const subpaths = path3.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
      if (subpaths.length < 2) {
        return self2.paths.hasOwnProperty(subpaths[0]) ? self2.paths[subpaths[0]] : "adhocOrUndefined";
      }
      let val = self2.path(subpaths[0]);
      let isNested = false;
      if (!val) {
        return "adhocOrUndefined";
      }
      const last = subpaths.length - 1;
      for (let i = 1; i < subpaths.length; ++i) {
        isNested = false;
        const subpath = subpaths[i];
        if (i === last && val && !/\D/.test(subpath)) {
          if (val.$isMongooseDocumentArray) {
            val = val.$embeddedSchemaType;
          } else if (val instanceof MongooseTypes.Array) {
            val = val.caster;
          } else {
            val = void 0;
          }
          break;
        }
        if (!/\D/.test(subpath)) {
          if (val instanceof MongooseTypes.Array && i !== last) {
            val = val.caster;
          }
          continue;
        }
        if (!(val && val.schema)) {
          val = void 0;
          break;
        }
        const type = val.schema.pathType(subpath);
        isNested = type === "nested";
        val = val.schema.path(subpath);
      }
      self2.subpaths[path3] = val;
      if (val) {
        return "real";
      }
      if (isNested) {
        return "nested";
      }
      return "adhocOrUndefined";
    }
    function getPositionalPath(self2, path3) {
      getPositionalPathType(self2, path3);
      return self2.subpaths[path3];
    }
    Schema6.prototype.queue = function(name, args) {
      this.callQueue.push([name, args]);
      return this;
    };
    Schema6.prototype.pre = function(name) {
      if (name instanceof RegExp) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const fn of hookNames) {
          if (name.test(fn)) {
            this.pre.apply(this, [fn].concat(remainingArgs));
          }
        }
        return this;
      }
      if (Array.isArray(name)) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const el of name) {
          this.pre.apply(this, [el].concat(remainingArgs));
        }
        return this;
      }
      this.s.hooks.pre.apply(this.s.hooks, arguments);
      return this;
    };
    Schema6.prototype.post = function(name) {
      if (name instanceof RegExp) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const fn of hookNames) {
          if (name.test(fn)) {
            this.post.apply(this, [fn].concat(remainingArgs));
          }
        }
        return this;
      }
      if (Array.isArray(name)) {
        const remainingArgs = Array.prototype.slice.call(arguments, 1);
        for (const el of name) {
          this.post.apply(this, [el].concat(remainingArgs));
        }
        return this;
      }
      this.s.hooks.post.apply(this.s.hooks, arguments);
      return this;
    };
    Schema6.prototype.plugin = function(fn, opts) {
      if (typeof fn !== "function") {
        throw new Error('First param to `schema.plugin()` must be a function, got "' + typeof fn + '"');
      }
      if (opts && opts.deduplicate) {
        for (const plugin of this.plugins) {
          if (plugin.fn === fn) {
            return this;
          }
        }
      }
      this.plugins.push({ fn, opts });
      fn(this, opts);
      return this;
    };
    Schema6.prototype.method = function(name, fn, options) {
      if (typeof name !== "string") {
        for (const i in name) {
          this.methods[i] = name[i];
          this.methodOptions[i] = utils.clone(options);
        }
      } else {
        this.methods[name] = fn;
        this.methodOptions[name] = utils.clone(options);
      }
      return this;
    };
    Schema6.prototype.static = function(name, fn) {
      if (typeof name !== "string") {
        for (const i in name) {
          this.statics[i] = name[i];
        }
      } else {
        this.statics[name] = fn;
      }
      return this;
    };
    Schema6.prototype.index = function(fields, options) {
      fields || (fields = {});
      options || (options = {});
      if (options.expires) {
        utils.expires(options);
      }
      this._indexes.push([fields, options]);
      return this;
    };
    Schema6.prototype.set = function(key, value, _tags) {
      if (arguments.length === 1) {
        return this.options[key];
      }
      switch (key) {
        case "read":
          this.options[key] = readPref(value, _tags);
          this._userProvidedOptions[key] = this.options[key];
          break;
        case "safe":
          setSafe(this.options, value);
          this._userProvidedOptions[key] = this.options[key];
          break;
        case "timestamps":
          this.setupTimestamp(value);
          this.options[key] = value;
          this._userProvidedOptions[key] = this.options[key];
          break;
        case "_id":
          this.options[key] = value;
          this._userProvidedOptions[key] = this.options[key];
          if (value && !this.paths["_id"]) {
            addAutoId(this);
          } else if (!value && this.paths["_id"] != null && this.paths["_id"].auto) {
            this.remove("_id");
          }
          break;
        default:
          this.options[key] = value;
          this._userProvidedOptions[key] = this.options[key];
          break;
      }
      return this;
    };
    var safeDeprecationWarning = "Mongoose: The `safe` option for schemas is deprecated. Use the `writeConcern` option instead: http://bit.ly/mongoose-write-concern";
    var setSafe = util2.deprecate(function setSafe2(options, value) {
      options.safe = value === false ? { w: 0 } : value;
    }, safeDeprecationWarning);
    Schema6.prototype.get = function(key) {
      return this.options[key];
    };
    var indexTypes = "2d 2dsphere hashed text".split(" ");
    Object.defineProperty(Schema6, "indexTypes", {
      get: function() {
        return indexTypes;
      },
      set: function() {
        throw new Error("Cannot overwrite Schema.indexTypes");
      }
    });
    Schema6.prototype.indexes = function() {
      return getIndexes(this);
    };
    Schema6.prototype.virtual = function(name, options) {
      if (name instanceof VirtualType || getConstructorName(name) === "VirtualType") {
        return this.virtual(name.path, name.options);
      }
      options = new VirtualOptions(options);
      if (utils.hasUserDefinedProperty(options, ["ref", "refPath"])) {
        if (options.localField == null) {
          throw new Error("Reference virtuals require `localField` option");
        }
        if (options.foreignField == null) {
          throw new Error("Reference virtuals require `foreignField` option");
        }
        this.pre("init", function(obj2) {
          if (mpath.has(name, obj2)) {
            const _v = mpath.get(name, obj2);
            if (!this.$$populatedVirtuals) {
              this.$$populatedVirtuals = {};
            }
            if (options.justOne || options.count) {
              this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
            } else {
              this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];
            }
            mpath.unset(name, obj2);
          }
        });
        const virtual = this.virtual(name);
        virtual.options = options;
        virtual.set(function(_v) {
          if (!this.$$populatedVirtuals) {
            this.$$populatedVirtuals = {};
          }
          if (options.justOne || options.count) {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
            if (typeof this.$$populatedVirtuals[name] !== "object") {
              this.$$populatedVirtuals[name] = options.count ? _v : null;
            }
          } else {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];
            this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {
              return doc && typeof doc === "object";
            });
          }
        });
        if (typeof options.get === "function") {
          virtual.get(options.get);
        }
        return virtual;
      }
      const virtuals = this.virtuals;
      const parts = name.split(".");
      if (this.pathType(name) === "real") {
        throw new Error('Virtual path "' + name + '" conflicts with a real path in the schema');
      }
      virtuals[name] = parts.reduce(function(mem, part, i) {
        mem[part] || (mem[part] = i === parts.length - 1 ? new VirtualType(options, name) : {});
        return mem[part];
      }, this.tree);
      let cur = parts[0];
      for (let i = 0; i < parts.length - 1; ++i) {
        if (this.paths[cur] != null && this.paths[cur].$isMongooseDocumentArray) {
          const remnant = parts.slice(i + 1).join(".");
          const v = this.paths[cur].schema.virtual(remnant);
          v.get((v4, virtual, doc) => {
            const parent = doc.__parentArray[arrayParentSymbol];
            const path3 = cur + "." + doc.__index + "." + remnant;
            return parent.get(path3);
          });
          break;
        }
        cur += "." + parts[i + 1];
      }
      return virtuals[name];
    };
    Schema6.prototype.virtualpath = function(name) {
      return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;
    };
    Schema6.prototype.remove = function(path3) {
      if (typeof path3 === "string") {
        path3 = [path3];
      }
      if (Array.isArray(path3)) {
        path3.forEach(function(name) {
          if (this.path(name) == null && !this.nested[name]) {
            return;
          }
          if (this.nested[name]) {
            const allKeys = Object.keys(this.paths).concat(Object.keys(this.nested));
            for (const path4 of allKeys) {
              if (path4.startsWith(name + ".")) {
                delete this.paths[path4];
                delete this.nested[path4];
                _deletePath(this, path4);
              }
            }
            delete this.nested[name];
            _deletePath(this, name);
            return;
          }
          delete this.paths[name];
          _deletePath(this, name);
        }, this);
      }
      return this;
    };
    function _deletePath(schema, name) {
      const pieces = name.split(".");
      const last = pieces.pop();
      let branch = schema.tree;
      for (const piece of pieces) {
        branch = branch[piece];
      }
      delete branch[last];
    }
    Schema6.prototype.loadClass = function(model, virtualsOnly) {
      if (model === Object.prototype || model === Function.prototype || model.prototype.hasOwnProperty("$isMongooseModelPrototype")) {
        return this;
      }
      this.loadClass(Object.getPrototypeOf(model), virtualsOnly);
      if (!virtualsOnly) {
        Object.getOwnPropertyNames(model).forEach(function(name) {
          if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {
            return;
          }
          const prop = Object.getOwnPropertyDescriptor(model, name);
          if (prop.hasOwnProperty("value")) {
            this.static(name, prop.value);
          }
        }, this);
      }
      Object.getOwnPropertyNames(model.prototype).forEach(function(name) {
        if (name.match(/^(constructor)$/)) {
          return;
        }
        const method = Object.getOwnPropertyDescriptor(model.prototype, name);
        if (!virtualsOnly) {
          if (typeof method.value === "function") {
            this.method(name, method.value);
          }
        }
        if (typeof method.get === "function") {
          if (this.virtuals[name]) {
            this.virtuals[name].getters = [];
          }
          this.virtual(name).get(method.get);
        }
        if (typeof method.set === "function") {
          if (this.virtuals[name]) {
            this.virtuals[name].setters = [];
          }
          this.virtual(name).set(method.set);
        }
      }, this);
      return this;
    };
    Schema6.prototype._getSchema = function(path3) {
      const _this = this;
      const pathschema = _this.path(path3);
      const resultPath = [];
      if (pathschema) {
        pathschema.$fullPath = path3;
        return pathschema;
      }
      function search(parts2, schema) {
        let p = parts2.length + 1;
        let foundschema;
        let trypath;
        while (p--) {
          trypath = parts2.slice(0, p).join(".");
          foundschema = schema.path(trypath);
          if (foundschema) {
            resultPath.push(trypath);
            if (foundschema.caster) {
              if (foundschema.caster instanceof MongooseTypes.Mixed) {
                foundschema.caster.$fullPath = resultPath.join(".");
                return foundschema.caster;
              }
              if (p !== parts2.length) {
                if (foundschema.schema) {
                  let ret2;
                  if (parts2[p] === "$" || isArrayFilter(parts2[p])) {
                    if (p + 1 === parts2.length) {
                      return foundschema;
                    }
                    ret2 = search(parts2.slice(p + 1), foundschema.schema);
                    if (ret2) {
                      ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                    }
                    return ret2;
                  }
                  ret2 = search(parts2.slice(p), foundschema.schema);
                  if (ret2) {
                    ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                  }
                  return ret2;
                }
              }
            } else if (foundschema.$isSchemaMap) {
              if (p + 1 >= parts2.length) {
                return foundschema;
              }
              const ret2 = search(parts2.slice(p + 1), foundschema.$__schemaType.schema);
              return ret2;
            }
            foundschema.$fullPath = resultPath.join(".");
            return foundschema;
          }
        }
      }
      const parts = path3.split(".");
      for (let i = 0; i < parts.length; ++i) {
        if (parts[i] === "$" || isArrayFilter(parts[i])) {
          parts[i] = "0";
        }
      }
      return search(parts, _this);
    };
    Schema6.prototype._getPathType = function(path3) {
      const _this = this;
      const pathschema = _this.path(path3);
      if (pathschema) {
        return "real";
      }
      function search(parts, schema) {
        let p = parts.length + 1, foundschema, trypath;
        while (p--) {
          trypath = parts.slice(0, p).join(".");
          foundschema = schema.path(trypath);
          if (foundschema) {
            if (foundschema.caster) {
              if (foundschema.caster instanceof MongooseTypes.Mixed) {
                return { schema: foundschema, pathType: "mixed" };
              }
              if (p !== parts.length && foundschema.schema) {
                if (parts[p] === "$" || isArrayFilter(parts[p])) {
                  if (p === parts.length - 1) {
                    return { schema: foundschema, pathType: "nested" };
                  }
                  return search(parts.slice(p + 1), foundschema.schema);
                }
                return search(parts.slice(p), foundschema.schema);
              }
              return {
                schema: foundschema,
                pathType: foundschema.$isSingleNested ? "nested" : "array"
              };
            }
            return { schema: foundschema, pathType: "real" };
          } else if (p === parts.length && schema.nested[trypath]) {
            return { schema, pathType: "nested" };
          }
        }
        return { schema: foundschema || schema, pathType: "undefined" };
      }
      return search(path3.split("."), _this);
    };
    function isArrayFilter(piece) {
      return piece.startsWith("$[") && piece.endsWith("]");
    }
    module2.exports = exports2 = Schema6;
    Schema6.Types = MongooseTypes = require_schema();
    exports2.ObjectId = MongooseTypes.ObjectId;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/common.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var Binary = require_driver().get().Binary;
    var Decimal128 = require_decimal128();
    var ObjectId2 = require_objectid2();
    var isMongooseObject = require_isMongooseObject();
    exports2.flatten = flatten;
    exports2.modifiedPaths = modifiedPaths;
    function flatten(update, path3, options, schema) {
      let keys;
      if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {
        keys = Object.keys(update.toObject({ transform: false, virtuals: false }));
      } else {
        keys = Object.keys(update || {});
      }
      const numKeys = keys.length;
      const result = {};
      path3 = path3 ? path3 + "." : "";
      for (let i = 0; i < numKeys; ++i) {
        const key = keys[i];
        const val = update[key];
        result[path3 + key] = val;
        const keySchema = schema && schema.path && schema.path(path3 + key);
        const isNested = schema && schema.nested && schema.nested[path3 + key];
        if (keySchema && keySchema.instance === "Mixed")
          continue;
        if (shouldFlatten(val)) {
          if (options && options.skipArrays && Array.isArray(val)) {
            continue;
          }
          const flat = flatten(val, path3 + key, options, schema);
          for (const k in flat) {
            result[k] = flat[k];
          }
          if (Array.isArray(val)) {
            result[path3 + key] = val;
          }
        }
        if (isNested) {
          const paths = Object.keys(schema.paths);
          for (const p of paths) {
            if (p.startsWith(path3 + key + ".") && !result.hasOwnProperty(p)) {
              result[p] = void 0;
            }
          }
        }
      }
      return result;
    }
    function modifiedPaths(update, path3, result) {
      const keys = Object.keys(update || {});
      const numKeys = keys.length;
      result = result || {};
      path3 = path3 ? path3 + "." : "";
      for (let i = 0; i < numKeys; ++i) {
        const key = keys[i];
        let val = update[key];
        result[path3 + key] = true;
        if (isMongooseObject(val) && !Buffer.isBuffer(val)) {
          val = val.toObject({ transform: false, virtuals: false });
        }
        if (shouldFlatten(val)) {
          modifiedPaths(val, path3 + key, result);
        }
      }
      return result;
    }
    function shouldFlatten(val) {
      return val && typeof val === "object" && !(val instanceof Date) && !(val instanceof ObjectId2) && (!Array.isArray(val) || val.length > 0) && !(val instanceof Buffer) && !(val instanceof Decimal128) && !(val instanceof Binary);
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var get = require_get();
    module2.exports = function getEmbeddedDiscriminatorPath(doc, path3, options) {
      options = options || {};
      const typeOnly = options.typeOnly;
      const parts = path3.split(".");
      let schema = null;
      let type = "adhocOrUndefined";
      for (let i = 0; i < parts.length; ++i) {
        const subpath = parts.slice(0, i + 1).join(".");
        schema = doc.schema.path(subpath);
        if (schema == null) {
          type = "adhocOrUndefined";
          continue;
        }
        if (schema.instance === "Mixed") {
          return typeOnly ? "real" : schema;
        }
        type = doc.schema.pathType(subpath);
        if ((schema.$isSingleNested || schema.$isMongooseDocumentArrayElement) && schema.schema.discriminators != null) {
          const discriminators = schema.schema.discriminators;
          const discriminatorKey = doc.get(subpath + "." + get(schema, "schema.options.discriminatorKey"));
          if (discriminatorKey == null || discriminators[discriminatorKey] == null) {
            continue;
          }
          const rest = parts.slice(i + 1).join(".");
          return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);
        }
      }
      return typeOnly ? type : schema;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/plugins/idGetter.js
var require_idGetter = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/plugins/idGetter.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(schema) {
      const autoIdGetter = !schema.paths["id"] && (!schema.options.noVirtualId && schema.options.id);
      if (!autoIdGetter) {
        return;
      }
      schema.virtual("id").get(idGetter);
    };
    function idGetter() {
      if (this._id != null) {
        return String(this._id);
      }
      return null;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js
var require_isDefiningProjection = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function isDefiningProjection(val) {
      if (val == null) {
        return true;
      }
      if (typeof val === "object") {
        return !("$meta" in val) && !("$slice" in val);
      }
      return true;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/projection/isExclusive.js
var require_isExclusive = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/projection/isExclusive.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var isDefiningProjection = require_isDefiningProjection();
    module2.exports = function isExclusive(projection) {
      if (projection == null) {
        return null;
      }
      const keys = Object.keys(projection);
      let ki = keys.length;
      let exclude = null;
      if (ki === 1 && keys[0] === "_id") {
        exclude = !!projection[keys[ki]];
      } else {
        while (ki--) {
          if (keys[ki] !== "_id" && isDefiningProjection(projection[keys[ki]])) {
            exclude = !projection[keys[ki]];
            break;
          }
        }
      }
      return exclude;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js
var require_checkEmbeddedDiscriminatorKeyProjection = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function checkEmbeddedDiscriminatorKeyProjection(userProjection, path3, schema, selected, addedPaths) {
      const userProjectedInPath = Object.keys(userProjection).reduce((cur, key) => cur || key.startsWith(path3 + "."), false);
      const _discriminatorKey = path3 + "." + schema.options.discriminatorKey;
      if (!userProjectedInPath && addedPaths.length === 1 && addedPaths[0] === _discriminatorKey) {
        selected.splice(selected.indexOf(_discriminatorKey), 1);
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/queryhelpers.js
var require_queryhelpers = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/queryhelpers.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var checkEmbeddedDiscriminatorKeyProjection = require_checkEmbeddedDiscriminatorKeyProjection();
    var get = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var isDefiningProjection = require_isDefiningProjection();
    var clone = require_clone();
    exports2.preparePopulationOptions = function preparePopulationOptions(query, options) {
      const _populate = query.options.populate;
      const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);
      if (options.lean != null) {
        pop.filter((p) => get(p, "options.lean") == null).forEach(makeLean(options.lean));
      }
      pop.forEach((opts) => {
        opts._localModel = query.model;
      });
      return pop;
    };
    exports2.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {
      const _populate = query._mongooseOptions.populate;
      const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);
      if (options.lean != null) {
        pop.filter((p) => get(p, "options.lean") == null).forEach(makeLean(options.lean));
      }
      const session = get(query, "options.session", null);
      if (session != null) {
        pop.forEach((path3) => {
          if (path3.options == null) {
            path3.options = { session };
            return;
          }
          if (!("session" in path3.options)) {
            path3.options.session = session;
          }
        });
      }
      const projection = query._fieldsForExec();
      pop.forEach((p) => {
        p._queryProjection = projection;
      });
      pop.forEach((opts) => {
        opts._localModel = query.model;
      });
      return pop;
    };
    exports2.createModel = function createModel(model, doc, fields, userProvidedFields, options) {
      model.hooks.execPreSync("createModel", doc);
      const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;
      const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;
      const value = doc[key];
      if (key && value && model.discriminators) {
        const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);
        if (discriminator) {
          const _fields = clone(userProvidedFields);
          exports2.applyPaths(_fields, discriminator.schema);
          return new discriminator(void 0, _fields, true);
        }
      }
      if (typeof options === "undefined") {
        options = {};
        options.defaults = true;
      }
      return new model(void 0, fields, {
        skipId: true,
        isNew: false,
        willInit: true,
        defaults: options.defaults
      });
    };
    exports2.applyPaths = function applyPaths(fields, schema) {
      let exclude;
      let keys;
      let keyIndex;
      if (fields) {
        keys = Object.keys(fields);
        keyIndex = keys.length;
        while (keyIndex--) {
          if (keys[keyIndex][0] === "+") {
            continue;
          }
          const field = fields[keys[keyIndex]];
          if (!isDefiningProjection(field)) {
            continue;
          }
          exclude = !field;
          break;
        }
      }
      const selected = [];
      const excluded = [];
      const stack = [];
      analyzeSchema(schema);
      switch (exclude) {
        case true:
          for (const fieldName of excluded) {
            fields[fieldName] = 0;
          }
          break;
        case false:
          if (schema && schema.paths["_id"] && schema.paths["_id"].options && schema.paths["_id"].options.select === false) {
            fields._id = 0;
          }
          for (const fieldName of selected) {
            fields[fieldName] = fields[fieldName] || 1;
          }
          break;
        case void 0:
          if (fields == null) {
            break;
          }
          for (const key of Object.keys(fields || {})) {
            if (key.startsWith("+")) {
              delete fields[key];
            }
          }
          for (const fieldName of excluded) {
            fields[fieldName] = 0;
          }
          break;
      }
      function analyzeSchema(schema2, prefix) {
        prefix || (prefix = "");
        if (stack.indexOf(schema2) !== -1) {
          return [];
        }
        stack.push(schema2);
        const addedPaths = [];
        schema2.eachPath(function(path3, type) {
          if (prefix)
            path3 = prefix + "." + path3;
          let addedPath = analyzePath(path3, type);
          if (addedPath == null && type.$isMongooseArray && !type.$isMongooseDocumentArray) {
            addedPath = analyzePath(path3, type.caster);
          }
          if (addedPath != null) {
            addedPaths.push(addedPath);
          }
          if (type.schema) {
            const _addedPaths = analyzeSchema(type.schema, path3);
            if (exclude === false) {
              checkEmbeddedDiscriminatorKeyProjection(
                fields,
                path3,
                type.schema,
                selected,
                _addedPaths
              );
            }
          }
        });
        stack.pop();
        return addedPaths;
      }
      function analyzePath(path3, type) {
        const plusPath = "+" + path3;
        const hasPlusPath = fields && plusPath in fields;
        if (hasPlusPath) {
          delete fields[plusPath];
        }
        if (typeof type.selected !== "boolean")
          return;
        if (hasPlusPath) {
          delete fields[plusPath];
          if (exclude === false && keys.length > 1 && !~keys.indexOf(path3)) {
            fields[path3] = 1;
          }
          return;
        }
        const pieces = path3.split(".");
        let cur = "";
        for (let i = 0; i < pieces.length; ++i) {
          cur += cur.length ? "." + pieces[i] : pieces[i];
          if (excluded.indexOf(cur) !== -1) {
            return;
          }
        }
        if (!exclude && get(type, "options.$skipDiscriminatorCheck", false)) {
          let cur2 = "";
          for (let i = 0; i < pieces.length; ++i) {
            cur2 += (cur2.length === 0 ? "" : ".") + pieces[i];
            const projection = get(fields, cur2, false) || get(fields, cur2 + ".$", false);
            if (projection && typeof projection !== "object") {
              return;
            }
          }
        }
        (type.selected ? selected : excluded).push(path3);
        return path3;
      }
    };
    function makeLean(val) {
      return function(option) {
        option.options || (option.options = {});
        if (val != null && Array.isArray(val.virtuals)) {
          val = Object.assign({}, val);
          val.virtuals = val.virtuals.filter((path3) => typeof path3 === "string" && path3.startsWith(option.path + ".")).map((path3) => path3.slice(option.path.length + 1));
        }
        option.options.lean = val;
      };
    }
    exports2.handleDeleteWriteOpResult = function handleDeleteWriteOpResult(callback) {
      return function _handleDeleteWriteOpResult(error, res) {
        if (error) {
          return callback(error);
        }
        const mongooseResult = Object.assign({}, res.result);
        if (get(res, "result.n", null) != null) {
          mongooseResult.deletedCount = res.result.n;
        }
        if (res.deletedCount != null) {
          mongooseResult.deletedCount = res.deletedCount;
        }
        return callback(null, mongooseResult);
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/isPromise.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    function isPromise(val) {
      return !!val && (typeof val === "object" || typeof val === "function") && typeof val.then === "function";
    }
    module2.exports = isPromise;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/document.js
var require_document = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/document.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var EventEmitter = require("events").EventEmitter;
    var InternalCache = require_internal();
    var MongooseError = require_error();
    var MixedSchema = require_mixed();
    var ObjectExpectedError = require_objectExpected();
    var ObjectParameterError = require_objectParameter();
    var ParallelValidateError = require_parallelValidate();
    var Schema6 = require_schema2();
    var StrictModeError = require_strict();
    var ValidationError = require_validation();
    var ValidatorError = require_validator();
    var VirtualType = require_virtualtype();
    var promiseOrCallback = require_promiseOrCallback();
    var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
    var compile = require_compile().compile;
    var defineKey = require_compile().defineKey;
    var flatten = require_common().flatten;
    var get = require_get();
    var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath();
    var handleSpreadDoc = require_handleSpreadDoc();
    var idGetter = require_idGetter();
    var immediate = require_immediate();
    var isDefiningProjection = require_isDefiningProjection();
    var isExclusive = require_isExclusive();
    var inspect = require("util").inspect;
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var mpath = require_mpath();
    var queryhelpers = require_queryhelpers();
    var utils = require_utils2();
    var isPromise = require_isPromise();
    var clone = utils.clone;
    var deepEqual = utils.deepEqual;
    var isMongooseObject = utils.isMongooseObject;
    var arrayAtomicsBackupSymbol = Symbol("mongoose.Array#atomicsBackup");
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var documentArrayParent = require_symbols().documentArrayParent;
    var documentIsModified = require_symbols().documentIsModified;
    var documentModifiedPaths = require_symbols().documentModifiedPaths;
    var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
    var getSymbol = require_symbols().getSymbol;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var scopeSymbol = require_symbols().scopeSymbol;
    var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
    var DocumentArray;
    var MongooseArray;
    var Embedded;
    var specialProperties = utils.specialProperties;
    function Document6(obj2, fields, skipId, options) {
      if (typeof skipId === "object" && skipId != null) {
        options = skipId;
        skipId = options.skipId;
      }
      options = Object.assign({}, options);
      const defaults = get(options, "defaults", true);
      options.defaults = defaults;
      if (this.$__schema == null) {
        const _schema = utils.isObject(fields) && !fields.instanceOfSchema ? new Schema6(fields) : fields;
        this.$__setSchema(_schema);
        fields = skipId;
        skipId = options;
        options = arguments[4] || {};
      }
      this.$__ = new InternalCache();
      this.$__.emitter = new EventEmitter();
      this.isNew = "isNew" in options ? options.isNew : true;
      this.errors = void 0;
      this.$__.$options = options || {};
      this.$locals = {};
      this.$op = null;
      if (obj2 != null && typeof obj2 !== "object") {
        throw new ObjectParameterError(obj2, "obj", "Document");
      }
      const schema = this.$__schema;
      if (typeof fields === "boolean" || fields === "throw") {
        this.$__.strictMode = fields;
        fields = void 0;
      } else {
        this.$__.strictMode = schema.options.strict;
        this.$__.selected = fields;
      }
      const requiredPaths = schema.requiredPaths(true);
      for (const path3 of requiredPaths) {
        this.$__.activePaths.require(path3);
      }
      this.$__.emitter.setMaxListeners(0);
      let exclude = null;
      if (utils.isPOJO(fields)) {
        exclude = isExclusive(fields);
      }
      const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : {};
      if (this._doc == null) {
        this.$__buildDoc(obj2, fields, skipId, exclude, hasIncludedChildren, false);
        if (defaults) {
          $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {
            isNew: this.isNew
          });
        }
      }
      if (obj2) {
        if (this.$__original_set) {
          this.$__original_set(obj2, void 0, true);
        } else {
          this.$set(obj2, void 0, true);
        }
        if (obj2 instanceof Document6) {
          this.isNew = obj2.isNew;
        }
      }
      if (options.willInit && defaults) {
        EventEmitter.prototype.once.call(this, "init", () => {
          $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {
            isNew: this.isNew
          });
        });
      } else if (defaults) {
        $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {
          isNew: this.isNew
        });
      }
      this.$__._id = this._id;
      if (!this.$__.strictMode && obj2) {
        const _this = this;
        const keys = Object.keys(this._doc);
        keys.forEach(function(key) {
          if (!(key in schema.tree)) {
            defineKey(key, null, _this);
          }
        });
      }
      applyQueue(this);
    }
    utils.each(
      [
        "on",
        "once",
        "emit",
        "listeners",
        "removeListener",
        "setMaxListeners",
        "removeAllListeners",
        "addListener"
      ],
      function(emitterFn) {
        Document6.prototype[emitterFn] = function() {
          return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
        };
      }
    );
    Document6.prototype.constructor = Document6;
    for (const i in EventEmitter.prototype) {
      Document6[i] = EventEmitter.prototype[i];
    }
    Document6.prototype.$__schema;
    Document6.prototype.schema;
    Object.defineProperty(Document6.prototype, "$locals", {
      configurable: false,
      enumerable: false,
      writable: true
    });
    Document6.prototype.isNew;
    Object.defineProperty(Document6.prototype, "$where", {
      configurable: false,
      enumerable: false,
      writable: true
    });
    Document6.prototype.id;
    Document6.prototype.errors;
    Document6.prototype.$op;
    function $__hasIncludedChildren(fields) {
      const hasIncludedChildren = {};
      const keys = Object.keys(fields);
      for (const key of keys) {
        const parts = key.split(".");
        const c = [];
        for (const part of parts) {
          c.push(part);
          hasIncludedChildren[c.join(".")] = 1;
        }
      }
      return hasIncludedChildren;
    }
    function $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {
      const paths = Object.keys(doc.$__schema.paths);
      const plen = paths.length;
      for (let i = 0; i < plen; ++i) {
        let def;
        let curPath = "";
        const p = paths[i];
        if (p === "_id" && skipId) {
          continue;
        }
        const type = doc.$__schema.paths[p];
        const path3 = type.splitPath();
        const len = path3.length;
        let included = false;
        let doc_ = doc._doc;
        for (let j = 0; j < len; ++j) {
          if (doc_ == null) {
            break;
          }
          const piece = path3[j];
          curPath += (!curPath.length ? "" : ".") + piece;
          if (exclude === true) {
            if (curPath in fields) {
              break;
            }
          } else if (exclude === false && fields && !included) {
            if (curPath in fields) {
              included = true;
            } else if (!hasIncludedChildren[curPath]) {
              break;
            }
          }
          if (j === len - 1) {
            if (doc_[piece] !== void 0) {
              break;
            }
            if (typeof type.defaultValue === "function") {
              if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {
                break;
              }
              if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {
                break;
              }
            } else if (!isBeforeSetters) {
              continue;
            }
            if (pathsToSkip && pathsToSkip[curPath]) {
              break;
            }
            if (fields && exclude !== null) {
              if (exclude === true) {
                if (p in fields) {
                  continue;
                }
                try {
                  def = type.getDefault(doc, false);
                } catch (err) {
                  doc.invalidate(p, err);
                  break;
                }
                if (typeof def !== "undefined") {
                  doc_[piece] = def;
                  doc.$__.activePaths.default(p);
                }
              } else if (included) {
                try {
                  def = type.getDefault(doc, false);
                } catch (err) {
                  doc.invalidate(p, err);
                  break;
                }
                if (typeof def !== "undefined") {
                  doc_[piece] = def;
                  doc.$__.activePaths.default(p);
                }
              }
            } else {
              try {
                def = type.getDefault(doc, false);
              } catch (err) {
                doc.invalidate(p, err);
                break;
              }
              if (typeof def !== "undefined") {
                doc_[piece] = def;
                doc.$__.activePaths.default(p);
              }
            }
          } else {
            doc_ = doc_[piece];
          }
        }
      }
    }
    Document6.prototype.$__buildDoc = function(obj2, fields, skipId, exclude, hasIncludedChildren) {
      const doc = {};
      const paths = Object.keys(this.$__schema.paths).filter((p) => !p.includes("$*"));
      const plen = paths.length;
      let ii = 0;
      for (; ii < plen; ++ii) {
        const p = paths[ii];
        if (p === "_id") {
          if (skipId) {
            continue;
          }
          if (obj2 && "_id" in obj2) {
            continue;
          }
        }
        const path3 = this.$__schema.paths[p].splitPath();
        const len = path3.length;
        const last = len - 1;
        let curPath = "";
        let doc_ = doc;
        let included = false;
        for (let i = 0; i < len; ++i) {
          const piece = path3[i];
          curPath += (!curPath.length ? "" : ".") + piece;
          if (exclude === true) {
            if (curPath in fields) {
              break;
            }
          } else if (exclude === false && fields && !included) {
            if (curPath in fields) {
              included = true;
            } else if (!hasIncludedChildren[curPath]) {
              break;
            }
          }
          if (i < last) {
            doc_ = doc_[piece] || (doc_[piece] = {});
          }
        }
      }
      this._doc = doc;
    };
    Document6.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    Document6.prototype.init = function(doc, opts, fn) {
      if (typeof opts === "function") {
        fn = opts;
        opts = null;
      }
      this.$__init(doc, opts);
      if (fn) {
        fn(null, this);
      }
      return this;
    };
    Document6.prototype.$__init = function(doc, opts) {
      this.isNew = false;
      this.$init = true;
      opts = opts || {};
      if (doc._id != null && opts.populated && opts.populated.length) {
        const id = String(doc._id);
        for (const item of opts.populated) {
          if (item.isVirtual) {
            this.populated(item.path, utils.getValue(item.path, doc), item);
          } else {
            this.populated(item.path, item._docs[id], item);
          }
          if (item._childDocs == null) {
            continue;
          }
          for (const child of item._childDocs) {
            if (child == null || child.$__ == null) {
              continue;
            }
            child.$__.parent = this;
          }
          item._childDocs = [];
        }
      }
      init(this, doc, this._doc, opts);
      markArraySubdocsPopulated(this, opts.populated);
      this.emit("init", this);
      this.constructor.emit("init", this);
      this.$__._id = this._id;
      return this;
    };
    function markArraySubdocsPopulated(doc, populated) {
      if (doc._id == null || populated == null || populated.length === 0) {
        return;
      }
      const id = String(doc._id);
      for (const item of populated) {
        if (item.isVirtual) {
          continue;
        }
        const path3 = item.path;
        const pieces = path3.split(".");
        for (let i = 0; i < pieces.length - 1; ++i) {
          const subpath = pieces.slice(0, i + 1).join(".");
          const rest = pieces.slice(i + 1).join(".");
          const val = doc.get(subpath);
          if (val == null) {
            continue;
          }
          if (val.isMongooseDocumentArray) {
            for (let j = 0; j < val.length; ++j) {
              val[j].populated(rest, item._docs[id] == null ? [] : item._docs[id][j], item);
            }
            break;
          }
        }
      }
    }
    function init(self2, obj2, doc, opts, prefix) {
      prefix = prefix || "";
      const keys = Object.keys(obj2);
      const len = keys.length;
      let schema;
      let path3;
      let i;
      let index = 0;
      while (index < len) {
        _init(index++);
      }
      function _init(index2) {
        i = keys[index2];
        path3 = prefix + i;
        schema = self2.$__schema.path(path3);
        if (self2.$__schema.$isRootDiscriminator && !self2.$__isSelected(path3)) {
          return;
        }
        if (!schema && utils.isPOJO(obj2[i])) {
          if (!doc[i]) {
            doc[i] = {};
          }
          init(self2, obj2[i], doc[i], opts, path3 + ".");
        } else if (!schema) {
          doc[i] = obj2[i];
        } else {
          if (obj2[i] === null) {
            doc[i] = schema._castNullish(null);
          } else if (obj2[i] !== void 0) {
            const intCache = obj2[i].$__ || {};
            const wasPopulated = intCache.wasPopulated || null;
            if (schema && !wasPopulated) {
              try {
                doc[i] = schema.cast(obj2[i], self2, true);
              } catch (e) {
                self2.invalidate(e.path, new ValidatorError({
                  path: e.path,
                  message: e.message,
                  type: "cast",
                  value: e.value,
                  reason: e
                }));
              }
            } else {
              doc[i] = obj2[i];
            }
          }
          if (!self2.isModified(path3)) {
            self2.$__.activePaths.init(path3);
          }
        }
      }
    }
    Document6.prototype.update = function update() {
      const args = utils.args(arguments);
      args.unshift({ _id: this._id });
      const query = this.constructor.update.apply(this.constructor, args);
      if (this.$session() != null) {
        if (!("session" in query.options)) {
          query.options.session = this.$session();
        }
      }
      return query;
    };
    Document6.prototype.updateOne = function updateOne(doc, options, callback) {
      const query = this.constructor.updateOne({ _id: this._id }, doc, options);
      query.pre((cb) => {
        this.constructor._middleware.execPre("updateOne", this, [this], cb);
      });
      query.post((cb) => {
        this.constructor._middleware.execPost("updateOne", this, [this], {}, cb);
      });
      if (this.$session() != null) {
        if (!("session" in query.options)) {
          query.options.session = this.$session();
        }
      }
      if (callback != null) {
        return query.exec(callback);
      }
      return query;
    };
    Document6.prototype.replaceOne = function replaceOne() {
      const args = utils.args(arguments);
      args.unshift({ _id: this._id });
      return this.constructor.replaceOne.apply(this.constructor, args);
    };
    Document6.prototype.$session = function $session(session) {
      if (arguments.length === 0) {
        if (this.$__.session != null && this.$__.session.hasEnded) {
          this.$__.session = null;
          return null;
        }
        return this.$__.session;
      }
      if (session != null && session.hasEnded) {
        throw new MongooseError("Cannot set a document's session to a session that has ended. Make sure you haven't called `endSession()` on the session you are passing to `$session()`.");
      }
      this.$__.session = session;
      if (!this.ownerDocument) {
        const subdocs = this.$getAllSubdocs();
        for (const child of subdocs) {
          child.$session(session);
        }
      }
      return session;
    };
    Document6.prototype.overwrite = function overwrite(obj2) {
      const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj2))));
      for (const key of keys) {
        if (key === "_id") {
          continue;
        }
        if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {
          continue;
        }
        if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {
          continue;
        }
        this.$set(key, obj2[key]);
      }
      return this;
    };
    Document6.prototype.$set = function $set(path3, val, type, options) {
      if (utils.isPOJO(type)) {
        options = type;
        type = void 0;
      }
      options = options || {};
      const merge2 = options.merge;
      const adhoc = type && type !== true;
      const constructing = type === true;
      const typeKey = this.$__schema.options.typeKey;
      let adhocs;
      let keys;
      let i = 0;
      let pathtype;
      let key;
      let prefix;
      const strict = "strict" in options ? options.strict : this.$__.strictMode;
      if (adhoc) {
        adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
        adhocs[path3] = this.$__schema.interpretAsType(path3, type, this.$__schema.options);
      }
      if (path3 == null) {
        const _ = path3;
        path3 = val;
        val = _;
      } else if (typeof path3 !== "string") {
        if (path3 instanceof Document6) {
          if (path3.$__isNested) {
            path3 = path3.toObject();
          } else {
            path3 = path3._doc;
          }
        }
        if (path3 == null) {
          const _ = path3;
          path3 = val;
          val = _;
        }
        prefix = val ? val + "." : "";
        keys = Object.keys(path3);
        const len = keys.length;
        const _skipMinimizeTopLevel = get(options, "_skipMinimizeTopLevel", false);
        if (len === 0 && _skipMinimizeTopLevel) {
          delete options._skipMinimizeTopLevel;
          if (val) {
            this.$set(val, {});
          }
          return this;
        }
        for (let i2 = 0; i2 < len; ++i2) {
          key = keys[i2];
          const pathName = prefix + key;
          pathtype = this.$__schema.pathType(pathName);
          if (type === true && !prefix && path3[key] != null && pathtype === "nested" && this._doc[key] != null && Object.keys(this._doc[key]).length === 0) {
            delete this._doc[key];
            options = Object.assign({}, options, { _skipMinimizeTopLevel: true });
          } else {
            options = Object.assign({}, options, { _skipMinimizeTopLevel: false });
          }
          const someCondition = typeof path3[key] === "object" && !utils.isNativeObject(path3[key]) && !utils.isMongooseType(path3[key]) && path3[key] != null && pathtype !== "virtual" && pathtype !== "real" && pathtype !== "adhocOrUndefined" && !(this.$__path(pathName) instanceof MixedSchema) && !(this.$__schema.paths[pathName] && this.$__schema.paths[pathName].options && this.$__schema.paths[pathName].options.ref);
          if (someCondition) {
            this.$__.$setCalled.add(prefix + key);
            this.$set(path3[key], prefix + key, constructing, options);
          } else if (strict) {
            if (constructing && path3[key] === void 0 && this.get(pathName) !== void 0) {
              continue;
            }
            if (pathtype === "adhocOrUndefined") {
              pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
            }
            if (pathtype === "real" || pathtype === "virtual") {
              let p = path3[key];
              if (this.$__schema.paths[pathName] && this.$__schema.paths[pathName].$isSingleNested && path3[key] instanceof Document6) {
                p = p.toObject({ virtuals: false, transform: false });
              }
              this.$set(prefix + key, p, constructing, options);
            } else if (pathtype === "nested" && path3[key] instanceof Document6) {
              this.$set(
                prefix + key,
                path3[key].toObject({ transform: false }),
                constructing,
                options
              );
            } else if (strict === "throw") {
              if (pathtype === "nested") {
                throw new ObjectExpectedError(key, path3[key]);
              } else {
                throw new StrictModeError(key);
              }
            }
          } else if (path3[key] !== void 0) {
            this.$set(prefix + key, path3[key], constructing, options);
          }
        }
        return this;
      } else {
        this.$__.$setCalled.add(path3);
      }
      let pathType = this.$__schema.pathType(path3);
      if (pathType === "adhocOrUndefined") {
        pathType = getEmbeddedDiscriminatorPath(this, path3, { typeOnly: true });
      }
      val = handleSpreadDoc(val);
      if (pathType === "nested" && val) {
        if (typeof val === "object" && val != null) {
          const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path3);
          if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path3)) {
            const priorVal2 = this.$__getValue(path3);
            this.$__.savedState[path3] = priorVal2;
            const keys3 = Object.keys(priorVal2 || {});
            for (const key2 of keys3) {
              this.$__.savedState[path3 + "." + key2] = priorVal2[key2];
            }
          }
          if (!merge2) {
            this.$__setValue(path3, null);
            cleanModifiedSubpaths(this, path3);
          } else {
            return this.$set(val, path3, constructing);
          }
          const keys2 = Object.keys(val);
          this.$__setValue(path3, {});
          for (const key2 of keys2) {
            this.$set(path3 + "." + key2, val[key2], constructing);
          }
          if (hasPriorVal && utils.deepEqual(this.$__.savedState[path3], val)) {
            this.unmarkModified(path3);
          } else {
            this.markModified(path3);
          }
          cleanModifiedSubpaths(this, path3, { skipDocArrays: true });
          return this;
        }
        this.invalidate(path3, new MongooseError.CastError("Object", val, path3));
        return this;
      }
      let schema;
      const parts = path3.indexOf(".") === -1 ? [path3] : path3.split(".");
      if (typeof this.$__schema.aliases[parts[0]] == "string") {
        parts[0] = this.$__schema.aliases[parts[0]];
      }
      if (pathType === "adhocOrUndefined" && strict) {
        let mixed;
        for (i = 0; i < parts.length; ++i) {
          const subpath = parts.slice(0, i + 1).join(".");
          if (i + 1 < parts.length && this.$__schema.pathType(subpath) === "virtual") {
            mpath.set(path3, val, this);
            return this;
          }
          schema = this.$__schema.path(subpath);
          if (schema == null) {
            continue;
          }
          if (schema instanceof MixedSchema) {
            mixed = true;
            break;
          }
        }
        if (schema == null) {
          schema = getEmbeddedDiscriminatorPath(this, path3);
        }
        if (!mixed && !schema) {
          if (strict === "throw") {
            throw new StrictModeError(path3);
          }
          return this;
        }
      } else if (pathType === "virtual") {
        schema = this.$__schema.virtualpath(path3);
        schema.applySetters(val, this);
        return this;
      } else {
        schema = this.$__path(path3);
      }
      let cur = this._doc;
      let curPath = "";
      for (i = 0; i < parts.length - 1; ++i) {
        cur = cur[parts[i]];
        curPath += (curPath.length > 0 ? "." : "") + parts[i];
        if (!cur) {
          this.$set(curPath, {});
          if (!this.$__isSelected(curPath)) {
            this.unmarkModified(curPath);
          }
          cur = this.$__getValue(curPath);
        }
      }
      let pathToMark;
      if (parts.length <= 1) {
        pathToMark = path3;
      } else {
        for (i = 0; i < parts.length; ++i) {
          const subpath = parts.slice(0, i + 1).join(".");
          if (this.get(subpath, null, { getters: false }) === null) {
            pathToMark = subpath;
            break;
          }
        }
        if (!pathToMark) {
          pathToMark = path3;
        }
      }
      const priorVal = (() => {
        if (this.$__.$options.priorDoc != null) {
          return this.$__.$options.priorDoc.$__getValue(path3);
        }
        if (constructing) {
          return void 0;
        }
        return this.$__getValue(path3);
      })();
      if (!schema) {
        this.$__set(pathToMark, path3, constructing, parts, schema, val, priorVal);
        return this;
      }
      if (schema.$isSingleNested || schema.$isMongooseArray) {
        _markValidSubpaths(this, path3);
      }
      if (schema.$isSingleNested && val != null && merge2) {
        if (val instanceof Document6) {
          val = val.toObject({ virtuals: false, transform: false });
        }
        const keys2 = Object.keys(val);
        for (const key2 of keys2) {
          this.$set(path3 + "." + key2, val[key2], constructing, options);
        }
        return this;
      }
      let shouldSet = true;
      try {
        const refMatches = (() => {
          if (schema.options == null) {
            return false;
          }
          if (!(val instanceof Document6)) {
            return false;
          }
          const model = val.constructor;
          const ref = schema.options.ref;
          if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
            return true;
          }
          const refPath = schema.options.refPath;
          if (refPath == null) {
            return false;
          }
          const modelName = val.get(refPath);
          return modelName === model.modelName || modelName === model.baseModelName;
        })();
        let didPopulate = false;
        if (refMatches && val instanceof Document6) {
          this.populated(path3, val._id, { [populateModelSymbol]: val.constructor });
          val.$__.wasPopulated = true;
          didPopulate = true;
        }
        let popOpts;
        if (schema.options && Array.isArray(schema.options[typeKey]) && schema.options[typeKey].length && schema.options[typeKey][0].ref && _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {
          popOpts = { [populateModelSymbol]: val[0].constructor };
          this.populated(path3, val.map(function(v) {
            return v._id;
          }), popOpts);
          for (const doc of val) {
            doc.$__.wasPopulated = true;
          }
          didPopulate = true;
        }
        if (this.$__schema.singleNestedPaths[path3] == null) {
          val = schema.applySetters(val, this, false, priorVal);
        }
        if (schema.$isMongooseDocumentArray && Array.isArray(val) && val.length > 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {
          const populatedPaths = Object.keys(val[0].$__.populated);
          for (const populatedPath of populatedPaths) {
            this.populated(
              path3 + "." + populatedPath,
              val.map((v) => v.populated(populatedPath)),
              val[0].$__.populated[populatedPath].options
            );
          }
          didPopulate = true;
        }
        if (!didPopulate && this.$__.populated) {
          if (Array.isArray(val) && this.$__.populated[path3]) {
            for (let i2 = 0; i2 < val.length; ++i2) {
              if (val[i2] instanceof Document6) {
                val[i2] = val[i2]._id;
              }
            }
          }
          delete this.$__.populated[path3];
        }
        if (schema.$isSingleNested && val != null) {
          _checkImmutableSubpaths(val, schema, priorVal);
        }
        this.$markValid(path3);
      } catch (e) {
        if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
          this.invalidate(path3, e);
        } else if (e instanceof MongooseError.CastError) {
          this.invalidate(e.path, e);
          if (e.$originalErrorPath) {
            this.invalidate(
              path3,
              new MongooseError.CastError(schema.instance, val, path3, e.$originalErrorPath)
            );
          }
        } else {
          this.invalidate(
            path3,
            new MongooseError.CastError(schema.instance, val, path3, e)
          );
        }
        shouldSet = false;
      }
      if (shouldSet) {
        this.$__set(pathToMark, path3, constructing, parts, schema, val, priorVal);
        if (this.$__.savedState != null) {
          if (!this.isNew && !this.$__.savedState.hasOwnProperty(path3)) {
            this.$__.savedState[path3] = priorVal;
          } else if (this.$__.savedState.hasOwnProperty(path3) && utils.deepEqual(val, this.$__.savedState[path3])) {
            this.unmarkModified(path3);
          }
        }
      }
      if (schema.$isSingleNested && (this.isDirectModified(path3) || val == null)) {
        cleanModifiedSubpaths(this, path3);
      }
      return this;
    };
    function _isManuallyPopulatedArray(val, ref) {
      if (!Array.isArray(val)) {
        return false;
      }
      if (val.length === 0) {
        return false;
      }
      for (const el of val) {
        if (!(el instanceof Document6)) {
          return false;
        }
        const modelName = el.constructor.modelName;
        if (modelName == null) {
          return false;
        }
        if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {
          return false;
        }
      }
      return true;
    }
    Document6.prototype.set = Document6.prototype.$set;
    Document6.prototype.$__shouldModify = function(pathToMark, path3, constructing, parts, schema, val, priorVal) {
      if (this.isNew) {
        return true;
      }
      if (this.$__schema.singleNestedPaths[path3] != null) {
        return false;
      }
      if (val === void 0 && !this.$__isSelected(path3)) {
        return true;
      }
      if (val === void 0 && path3 in this.$__.activePaths.states.default) {
        return false;
      }
      if (this.populated(path3) && val instanceof Document6 && deepEqual(val._id, priorVal)) {
        return false;
      }
      if (!deepEqual(val, priorVal || utils.getValue(path3, this))) {
        return true;
      }
      if (!constructing && val !== null && val !== void 0 && path3 in this.$__.activePaths.states.default && deepEqual(val, schema.getDefault(this, constructing))) {
        return true;
      }
      return false;
    };
    Document6.prototype.$__set = function(pathToMark, path3, constructing, parts, schema, val, priorVal) {
      Embedded = Embedded || require_embedded();
      const shouldModify = this.$__shouldModify(
        pathToMark,
        path3,
        constructing,
        parts,
        schema,
        val,
        priorVal
      );
      const _this = this;
      if (shouldModify) {
        this.markModified(pathToMark);
        MongooseArray || (MongooseArray = require_array());
        if (val && val.isMongooseArray) {
          val._registerAtomic("$set", val);
          if (val.isMongooseDocumentArray) {
            val.forEach(function(item) {
              item && item.__parentArray && (item.__parentArray = val);
            });
          }
          this.$__.activePaths.forEach(function(modifiedPath) {
            if (modifiedPath.startsWith(path3 + ".")) {
              _this.$__.activePaths.ignore(modifiedPath);
            }
          });
        }
      }
      let obj2 = this._doc;
      let i = 0;
      const l2 = parts.length;
      let cur = "";
      for (; i < l2; i++) {
        const next = i + 1;
        const last = next === l2;
        cur += cur ? "." + parts[i] : parts[i];
        if (specialProperties.has(parts[i])) {
          return;
        }
        if (last) {
          if (obj2 instanceof Map) {
            obj2.set(parts[i], val);
          } else {
            obj2[parts[i]] = val;
          }
        } else {
          if (utils.isPOJO(obj2[parts[i]])) {
            obj2 = obj2[parts[i]];
          } else if (obj2[parts[i]] && obj2[parts[i]] instanceof Embedded) {
            obj2 = obj2[parts[i]];
          } else if (obj2[parts[i]] && obj2[parts[i]].$isSingleNested) {
            obj2 = obj2[parts[i]];
          } else if (obj2[parts[i]] && Array.isArray(obj2[parts[i]])) {
            obj2 = obj2[parts[i]];
          } else {
            obj2[parts[i]] = obj2[parts[i]] || {};
            obj2 = obj2[parts[i]];
          }
        }
      }
    };
    Document6.prototype.$__getValue = function(path3) {
      return utils.getValue(path3, this._doc);
    };
    Document6.prototype.$__setValue = function(path3, val) {
      utils.setValue(path3, val, this._doc);
      return this;
    };
    Document6.prototype.get = function(path3, type, options) {
      let adhoc;
      options = options || {};
      if (type) {
        adhoc = this.$__schema.interpretAsType(path3, type, this.$__schema.options);
      }
      let schema = this.$__path(path3);
      if (schema == null) {
        schema = this.$__schema.virtualpath(path3);
      }
      if (schema instanceof MixedSchema) {
        const virtual = this.$__schema.virtualpath(path3);
        if (virtual != null) {
          schema = virtual;
        }
      }
      const pieces = path3.indexOf(".") === -1 ? [path3] : path3.split(".");
      let obj2 = this._doc;
      if (schema instanceof VirtualType) {
        return schema.applyGetters(void 0, this);
      }
      if (typeof this.$__schema.aliases[pieces[0]] == "string") {
        pieces[0] = this.$__schema.aliases[pieces[0]];
      }
      for (let i = 0, l2 = pieces.length; i < l2; i++) {
        if (obj2 && obj2._doc) {
          obj2 = obj2._doc;
        }
        if (obj2 == null) {
          obj2 = void 0;
        } else if (obj2 instanceof Map) {
          obj2 = obj2.get(pieces[i], { getters: false });
        } else if (i === l2 - 1) {
          obj2 = utils.getValue(pieces[i], obj2);
        } else {
          obj2 = obj2[pieces[i]];
        }
      }
      if (adhoc) {
        obj2 = adhoc.cast(obj2);
      }
      if (schema != null && options.getters !== false) {
        obj2 = schema.applyGetters(obj2, this);
      } else if (this.$__schema.nested[path3] && options.virtuals) {
        return applyVirtuals(this, utils.clone(obj2) || {}, { path: path3 });
      }
      return obj2;
    };
    Document6.prototype[getSymbol] = Document6.prototype.get;
    Document6.prototype.$__path = function(path3) {
      const adhocs = this.$__.adhocPaths;
      const adhocType = adhocs && adhocs.hasOwnProperty(path3) ? adhocs[path3] : null;
      if (adhocType) {
        return adhocType;
      }
      return this.$__schema.path(path3);
    };
    Document6.prototype.markModified = function(path3, scope) {
      this.$__.activePaths.modify(path3);
      if (scope != null && !this.ownerDocument) {
        this.$__.pathsToScopes[path3] = scope;
      }
    };
    Document6.prototype.unmarkModified = function(path3) {
      this.$__.activePaths.init(path3);
      delete this.$__.pathsToScopes[path3];
    };
    Document6.prototype.$ignore = function(path3) {
      this.$__.activePaths.ignore(path3);
    };
    Document6.prototype.directModifiedPaths = function() {
      return Object.keys(this.$__.activePaths.states.modify);
    };
    Document6.prototype.$isEmpty = function(path3) {
      const isEmptyOptions = {
        minimize: true,
        virtuals: false,
        getters: false,
        transform: false
      };
      if (arguments.length > 0) {
        const v = this.get(path3);
        if (v == null) {
          return true;
        }
        if (typeof v !== "object") {
          return false;
        }
        if (utils.isPOJO(v)) {
          return _isEmpty(v);
        }
        return Object.keys(v.toObject(isEmptyOptions)).length === 0;
      }
      return Object.keys(this.toObject(isEmptyOptions)).length === 0;
    };
    function _isEmpty(v) {
      if (v == null) {
        return true;
      }
      if (typeof v !== "object" || Array.isArray(v)) {
        return false;
      }
      for (const key of Object.keys(v)) {
        if (!_isEmpty(v[key])) {
          return false;
        }
      }
      return true;
    }
    Document6.prototype.modifiedPaths = function(options) {
      options = options || {};
      const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
      const _this = this;
      return directModifiedPaths.reduce(function(list, path3) {
        const parts = path3.split(".");
        list = list.concat(parts.reduce(function(chains, part, i) {
          return chains.concat(parts.slice(0, i).concat(part).join("."));
        }, []).filter(function(chain) {
          return list.indexOf(chain) === -1;
        }));
        if (!options.includeChildren) {
          return list;
        }
        let cur = _this.get(path3);
        if (cur != null && typeof cur === "object") {
          if (cur._doc) {
            cur = cur._doc;
          }
          if (Array.isArray(cur)) {
            const len = cur.length;
            for (let i = 0; i < len; ++i) {
              if (list.indexOf(path3 + "." + i) === -1) {
                list.push(path3 + "." + i);
                if (cur[i] != null && cur[i].$__) {
                  const modified = cur[i].modifiedPaths();
                  for (const childPath of modified) {
                    list.push(path3 + "." + i + "." + childPath);
                  }
                }
              }
            }
          } else {
            Object.keys(cur).filter(function(key) {
              return list.indexOf(path3 + "." + key) === -1;
            }).forEach(function(key) {
              list.push(path3 + "." + key);
            });
          }
        }
        return list;
      }, []);
    };
    Document6.prototype[documentModifiedPaths] = Document6.prototype.modifiedPaths;
    Document6.prototype.isModified = function(paths, modifiedPaths) {
      if (paths) {
        if (!Array.isArray(paths)) {
          paths = paths.split(" ");
        }
        const modified = modifiedPaths || this[documentModifiedPaths]();
        const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
        const isModifiedChild = paths.some(function(path3) {
          return !!~modified.indexOf(path3);
        });
        return isModifiedChild || paths.some(function(path3) {
          return directModifiedPaths.some(function(mod) {
            return mod === path3 || path3.startsWith(mod + ".");
          });
        });
      }
      return this.$__.activePaths.some("modify");
    };
    Document6.prototype[documentIsModified] = Document6.prototype.isModified;
    Document6.prototype.$isDefault = function(path3) {
      if (path3 == null) {
        return this.$__.activePaths.some("default");
      }
      if (typeof path3 === "string" && path3.indexOf(" ") === -1) {
        return this.$__.activePaths.states.default.hasOwnProperty(path3);
      }
      let paths = path3;
      if (!Array.isArray(paths)) {
        paths = paths.split(" ");
      }
      return paths.some((path4) => this.$__.activePaths.states.default.hasOwnProperty(path4));
    };
    Document6.prototype.$isDeleted = function(val) {
      if (arguments.length === 0) {
        return !!this.$__.isDeleted;
      }
      this.$__.isDeleted = !!val;
      return this;
    };
    Document6.prototype.isDirectModified = function(path3) {
      if (path3 == null) {
        return this.$__.activePaths.some("modify");
      }
      if (typeof path3 === "string" && path3.indexOf(" ") === -1) {
        return this.$__.activePaths.states.modify.hasOwnProperty(path3);
      }
      let paths = path3;
      if (!Array.isArray(paths)) {
        paths = paths.split(" ");
      }
      return paths.some((path4) => this.$__.activePaths.states.modify.hasOwnProperty(path4));
    };
    Document6.prototype.isInit = function(path3) {
      if (path3 == null) {
        return this.$__.activePaths.some("init");
      }
      if (typeof path3 === "string" && path3.indexOf(" ") === -1) {
        return this.$__.activePaths.states.init.hasOwnProperty(path3);
      }
      let paths = path3;
      if (!Array.isArray(paths)) {
        paths = paths.split(" ");
      }
      return paths.some((path4) => this.$__.activePaths.states.init.hasOwnProperty(path4));
    };
    Document6.prototype.isSelected = function isSelected(path3) {
      if (this.$__.selected == null) {
        return true;
      }
      if (path3 === "_id") {
        return this.$__.selected._id !== 0;
      }
      if (path3.indexOf(" ") !== -1) {
        path3 = path3.split(" ");
      }
      if (Array.isArray(path3)) {
        return path3.some((p) => this.$__isSelected(p));
      }
      const paths = Object.keys(this.$__.selected);
      let inclusive = null;
      if (paths.length === 1 && paths[0] === "_id") {
        return this.$__.selected._id === 0;
      }
      for (const cur of paths) {
        if (cur === "_id") {
          continue;
        }
        if (!isDefiningProjection(this.$__.selected[cur])) {
          continue;
        }
        inclusive = !!this.$__.selected[cur];
        break;
      }
      if (inclusive === null) {
        return true;
      }
      if (path3 in this.$__.selected) {
        return inclusive;
      }
      const pathDot = path3 + ".";
      for (const cur of paths) {
        if (cur === "_id") {
          continue;
        }
        if (cur.startsWith(pathDot)) {
          return inclusive || cur !== pathDot;
        }
        if (pathDot.startsWith(cur + ".")) {
          return inclusive;
        }
      }
      return !inclusive;
    };
    Document6.prototype.$__isSelected = Document6.prototype.isSelected;
    Document6.prototype.isDirectSelected = function isDirectSelected(path3) {
      if (this.$__.selected == null) {
        return true;
      }
      if (path3 === "_id") {
        return this.$__.selected._id !== 0;
      }
      if (path3.indexOf(" ") !== -1) {
        path3 = path3.split(" ");
      }
      if (Array.isArray(path3)) {
        return path3.some((p) => this.isDirectSelected(p));
      }
      const paths = Object.keys(this.$__.selected);
      let inclusive = null;
      if (paths.length === 1 && paths[0] === "_id") {
        return this.$__.selected._id === 0;
      }
      for (const cur of paths) {
        if (cur === "_id") {
          continue;
        }
        if (!isDefiningProjection(this.$__.selected[cur])) {
          continue;
        }
        inclusive = !!this.$__.selected[cur];
        break;
      }
      if (inclusive === null) {
        return true;
      }
      if (this.$__.selected.hasOwnProperty(path3)) {
        return inclusive;
      }
      return !inclusive;
    };
    Document6.prototype.validate = function(pathsToValidate, options, callback) {
      let parallelValidate;
      this.$op = "validate";
      if (this.ownerDocument != null) {
      } else if (this.$__.validating) {
        parallelValidate = new ParallelValidateError(this, {
          parentStack: options && options.parentStack,
          conflictStack: this.$__.validating.stack
        });
      } else {
        this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });
      }
      if (arguments.length === 1) {
        if (typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
          options = arguments[0];
          callback = null;
          pathsToValidate = null;
        } else if (typeof arguments[0] === "function") {
          callback = arguments[0];
          options = null;
          pathsToValidate = null;
        }
      } else if (typeof pathsToValidate === "function") {
        callback = pathsToValidate;
        options = null;
        pathsToValidate = null;
      } else if (typeof options === "function") {
        callback = options;
        options = pathsToValidate;
        pathsToValidate = null;
      }
      if (options && typeof options.pathsToSkip === "string") {
        const isOnePathOnly = options.pathsToSkip.indexOf(" ") === -1;
        options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(" ");
      }
      return promiseOrCallback(callback, (cb) => {
        if (parallelValidate != null) {
          return cb(parallelValidate);
        }
        this.$__validate(pathsToValidate, options, (error) => {
          this.$op = null;
          cb(error);
        });
      }, this.constructor.events);
    };
    function _evaluateRequiredFunctions(doc) {
      Object.keys(doc.$__.activePaths.states.require).forEach((path3) => {
        const p = doc.$__schema.path(path3);
        if (p != null && typeof p.originalRequiredValue === "function") {
          doc.$__.cachedRequired[path3] = p.originalRequiredValue.call(doc, doc);
        }
      });
    }
    function _getPathsToValidate(doc) {
      const skipSchemaValidators = {};
      _evaluateRequiredFunctions(doc);
      let paths = new Set(Object.keys(doc.$__.activePaths.states.require).filter(function(path3) {
        if (!doc.$__isSelected(path3) && !doc.isModified(path3)) {
          return false;
        }
        if (path3 in doc.$__.cachedRequired) {
          return doc.$__.cachedRequired[path3];
        }
        return true;
      }));
      Object.keys(doc.$__.activePaths.states.init).forEach(addToPaths);
      Object.keys(doc.$__.activePaths.states.modify).forEach(addToPaths);
      Object.keys(doc.$__.activePaths.states.default).forEach(addToPaths);
      function addToPaths(p) {
        paths.add(p);
      }
      const subdocs = doc.$getAllSubdocs();
      const modifiedPaths = doc.modifiedPaths();
      for (const subdoc of subdocs) {
        if (subdoc.$basePath) {
          for (const p of paths) {
            if (p === null || p.startsWith(subdoc.$basePath + ".")) {
              paths.delete(p);
            }
          }
          if (doc.isModified(subdoc.$basePath, modifiedPaths) && !doc.isDirectModified(subdoc.$basePath) && !doc.$isDefault(subdoc.$basePath)) {
            paths.add(subdoc.$basePath);
            skipSchemaValidators[subdoc.$basePath] = true;
          }
        }
      }
      for (const path3 of paths) {
        const _pathType = doc.$__schema.path(path3);
        if (!_pathType || !_pathType.$isMongooseArray || // To avoid potential performance issues, skip doc arrays whose children
        // are not required. `getPositionalPathType()` may be slow, so avoid
        // it unless we have a case of #6364
        _pathType.$isMongooseDocumentArray && !get(_pathType, "schemaOptions.required")) {
          continue;
        }
        const val = doc.$__getValue(path3);
        _pushNestedArrayPaths(val, paths, path3);
      }
      function _pushNestedArrayPaths(val, paths2, path3) {
        if (val != null) {
          const numElements = val.length;
          for (let j = 0; j < numElements; ++j) {
            if (Array.isArray(val[j])) {
              _pushNestedArrayPaths(val[j], paths2, path3 + "." + j);
            } else {
              paths2.add(path3 + "." + j);
            }
          }
        }
      }
      const flattenOptions = { skipArrays: true };
      for (const pathToCheck of paths) {
        if (doc.$__schema.nested[pathToCheck]) {
          let _v = doc.$__getValue(pathToCheck);
          if (isMongooseObject(_v)) {
            _v = _v.toObject({ transform: false });
          }
          const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);
          Object.keys(flat).forEach(addToPaths);
        }
      }
      for (const path3 of paths) {
        if (doc.$__schema.singleNestedPaths.hasOwnProperty(path3)) {
          paths.delete(path3);
          continue;
        }
        const _pathType = doc.$__schema.path(path3);
        if (!_pathType || !_pathType.$isSchemaMap) {
          continue;
        }
        const val = doc.$__getValue(path3);
        if (val == null) {
          continue;
        }
        for (const key of val.keys()) {
          paths.add(path3 + "." + key);
        }
      }
      paths = Array.from(paths);
      return [paths, skipSchemaValidators];
    }
    Document6.prototype.$__validate = function(pathsToValidate, options, callback) {
      if (typeof pathsToValidate === "function") {
        callback = pathsToValidate;
        options = null;
        pathsToValidate = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
      const pathsToSkip = get(options, "pathsToSkip", null);
      let shouldValidateModifiedOnly;
      if (hasValidateModifiedOnlyOption) {
        shouldValidateModifiedOnly = !!options.validateModifiedOnly;
      } else {
        shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
      }
      const _this = this;
      const _complete = () => {
        let validationError = this.$__.validationError;
        this.$__.validationError = void 0;
        if (shouldValidateModifiedOnly && validationError != null) {
          const errors = Object.keys(validationError.errors);
          for (const errPath of errors) {
            if (!this.isModified(errPath)) {
              delete validationError.errors[errPath];
            }
          }
          if (Object.keys(validationError.errors).length === 0) {
            validationError = void 0;
          }
        }
        this.$__.cachedRequired = {};
        this.emit("validate", _this);
        this.constructor.emit("validate", _this);
        this.$__.validating = null;
        if (validationError) {
          for (const key in validationError.errors) {
            if (!this[documentArrayParent] && validationError.errors[key] instanceof MongooseError.CastError) {
              this.invalidate(key, validationError.errors[key]);
            }
          }
          return validationError;
        }
      };
      const pathDetails = _getPathsToValidate(this);
      let paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path3) => this.isModified(path3)) : pathDetails[0];
      const skipSchemaValidators = pathDetails[1];
      if (typeof pathsToValidate === "string") {
        pathsToValidate = pathsToValidate.split(" ");
      }
      if (Array.isArray(pathsToValidate)) {
        paths = _handlePathsToValidate(paths, pathsToValidate);
      } else if (pathsToSkip) {
        paths = _handlePathsToSkip(paths, pathsToSkip);
      }
      if (paths.length === 0) {
        return immediate(function() {
          const error = _complete();
          if (error) {
            return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error }, function(error2) {
              callback(error2);
            });
          }
          callback(null, _this);
        });
      }
      const validated = {};
      let total = 0;
      for (const path3 of paths) {
        validatePath(path3);
      }
      function validatePath(path3) {
        if (path3 == null || validated[path3]) {
          return;
        }
        validated[path3] = true;
        total++;
        immediate(function() {
          const schemaType = _this.$__schema.path(path3);
          if (!schemaType) {
            return --total || complete();
          }
          if (!_this.$isValid(path3)) {
            --total || complete();
            return;
          }
          if (schemaType[schemaMixedSymbol] != null && path3 !== schemaType.path) {
            return --total || complete();
          }
          let val = _this.$__getValue(path3);
          let pop;
          if (val == null && (pop = _this.populated(path3))) {
            val = pop;
          }
          const scope = path3 in _this.$__.pathsToScopes ? _this.$__.pathsToScopes[path3] : _this;
          const doValidateOptions = {
            skipSchemaValidators: skipSchemaValidators[path3],
            path: path3,
            validateModifiedOnly: shouldValidateModifiedOnly
          };
          schemaType.doValidate(val, function(err) {
            if (err && (!schemaType.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
              if (schemaType.$isSingleNested && err instanceof ValidationError && schemaType.schema.options.storeSubdocValidationError === false) {
                return --total || complete();
              }
              _this.invalidate(path3, err, void 0, true);
            }
            --total || complete();
          }, scope, doValidateOptions);
        });
      }
      function complete() {
        const error = _complete();
        if (error) {
          return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error }, function(error2) {
            callback(error2);
          });
        }
        callback(null, _this);
      }
    };
    function _handlePathsToValidate(paths, pathsToValidate) {
      const _pathsToValidate = new Set(pathsToValidate);
      const parentPaths = /* @__PURE__ */ new Map([]);
      for (const path3 of pathsToValidate) {
        if (path3.indexOf(".") === -1) {
          continue;
        }
        const pieces = path3.split(".");
        let cur = pieces[0];
        for (let i = 1; i < pieces.length; ++i) {
          parentPaths.set(cur, path3);
          cur = cur + "." + pieces[i];
        }
      }
      const ret2 = [];
      for (const path3 of paths) {
        if (_pathsToValidate.has(path3)) {
          ret2.push(path3);
        } else if (parentPaths.has(path3)) {
          ret2.push(parentPaths.get(path3));
        }
      }
      return ret2;
    }
    function _handlePathsToSkip(paths, pathsToSkip) {
      pathsToSkip = new Set(pathsToSkip);
      paths = paths.filter((p) => !pathsToSkip.has(p));
      return paths;
    }
    Document6.prototype.validateSync = function(pathsToValidate, options) {
      const _this = this;
      if (arguments.length === 1 && typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
        options = arguments[0];
        pathsToValidate = null;
      }
      const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
      let shouldValidateModifiedOnly;
      if (hasValidateModifiedOnlyOption) {
        shouldValidateModifiedOnly = !!options.validateModifiedOnly;
      } else {
        shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
      }
      let pathsToSkip = options && options.pathsToSkip;
      if (typeof pathsToValidate === "string") {
        const isOnePathOnly = pathsToValidate.indexOf(" ") === -1;
        pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(" ");
      } else if (typeof pathsToSkip === "string" && pathsToSkip.indexOf(" ") !== -1) {
        pathsToSkip = pathsToSkip.split(" ");
      }
      const pathDetails = _getPathsToValidate(this);
      let paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path3) => this.isModified(path3)) : pathDetails[0];
      const skipSchemaValidators = pathDetails[1];
      if (Array.isArray(pathsToValidate)) {
        paths = _handlePathsToValidate(paths, pathsToValidate);
      } else if (Array.isArray(pathsToSkip)) {
        paths = _handlePathsToSkip(paths, pathsToSkip);
      }
      const validating = {};
      paths.forEach(function(path3) {
        if (validating[path3]) {
          return;
        }
        validating[path3] = true;
        const p = _this.$__schema.path(path3);
        if (!p) {
          return;
        }
        if (!_this.$isValid(path3)) {
          return;
        }
        const val = _this.$__getValue(path3);
        const err2 = p.doValidateSync(val, _this, {
          skipSchemaValidators: skipSchemaValidators[path3],
          path: path3,
          validateModifiedOnly: shouldValidateModifiedOnly
        });
        if (err2 && (!p.$isMongooseDocumentArray || err2.$isArrayValidatorError)) {
          if (p.$isSingleNested && err2 instanceof ValidationError && p.schema.options.storeSubdocValidationError === false) {
            return;
          }
          _this.invalidate(path3, err2, void 0, true);
        }
      });
      const err = _this.$__.validationError;
      _this.$__.validationError = void 0;
      _this.emit("validate", _this);
      _this.constructor.emit("validate", _this);
      if (err) {
        for (const key in err.errors) {
          if (err.errors[key] instanceof MongooseError.CastError) {
            _this.invalidate(key, err.errors[key]);
          }
        }
      }
      return err;
    };
    Document6.prototype.invalidate = function(path3, err, val, kind) {
      if (!this.$__.validationError) {
        this.$__.validationError = new ValidationError(this);
      }
      if (this.$__.validationError.errors[path3]) {
        return;
      }
      if (!err || typeof err === "string") {
        err = new ValidatorError({
          path: path3,
          message: err,
          type: kind || "user defined",
          value: val
        });
      }
      if (this.$__.validationError === err) {
        return this.$__.validationError;
      }
      this.$__.validationError.addError(path3, err);
      return this.$__.validationError;
    };
    Document6.prototype.$markValid = function(path3) {
      if (!this.$__.validationError || !this.$__.validationError.errors[path3]) {
        return;
      }
      delete this.$__.validationError.errors[path3];
      if (Object.keys(this.$__.validationError.errors).length === 0) {
        this.$__.validationError = null;
      }
    };
    function _markValidSubpaths(doc, path3) {
      if (!doc.$__.validationError) {
        return;
      }
      const keys = Object.keys(doc.$__.validationError.errors);
      for (const key of keys) {
        if (key.startsWith(path3 + ".")) {
          delete doc.$__.validationError.errors[key];
        }
      }
      if (Object.keys(doc.$__.validationError.errors).length === 0) {
        doc.$__.validationError = null;
      }
    }
    function _checkImmutableSubpaths(subdoc, schematype, priorVal) {
      const schema = schematype.schema;
      if (schema == null) {
        return;
      }
      for (const key of Object.keys(schema.paths)) {
        const path3 = schema.paths[key];
        if (path3.$immutableSetter == null) {
          continue;
        }
        const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);
        path3.$immutableSetter.call(subdoc, oldVal);
      }
    }
    Document6.prototype.$isValid = function(path3) {
      if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {
        return true;
      }
      if (path3 == null) {
        return false;
      }
      if (path3.indexOf(" ") !== -1) {
        path3 = path3.split(" ");
      }
      if (Array.isArray(path3)) {
        return path3.some((p) => this.$__.validationError.errors[p] == null);
      }
      return this.$__.validationError.errors[path3] == null;
    };
    Document6.prototype.$__reset = function reset() {
      let _this = this;
      DocumentArray || (DocumentArray = require_documentarray());
      this.$__.activePaths.map("init", "modify", function(i) {
        return _this.$__getValue(i);
      }).filter(function(val) {
        return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
      }).forEach(function(array) {
        let i = array.length;
        while (i--) {
          const doc = array[i];
          if (!doc) {
            continue;
          }
          doc.$__reset();
        }
        _this.$__.activePaths.init(array.$path());
        array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];
        array[arrayAtomicsSymbol] = {};
      });
      this.$__.activePaths.map("init", "modify", function(i) {
        return _this.$__getValue(i);
      }).filter(function(val) {
        return val && val.$isSingleNested;
      }).forEach(function(doc) {
        doc.$__reset();
        if (doc.$__parent === _this) {
          _this.$__.activePaths.init(doc.$basePath);
        } else if (doc.$__parent != null && doc.$__parent.ownerDocument) {
          doc.$__parent.$__reset();
        }
      });
      this.$__dirty().forEach(function(dirt) {
        const type = dirt.value;
        if (type && type[arrayAtomicsSymbol]) {
          type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];
          type[arrayAtomicsSymbol] = {};
        }
      });
      this.$__.backup = {};
      this.$__.backup.activePaths = {
        modify: Object.assign({}, this.$__.activePaths.states.modify),
        default: Object.assign({}, this.$__.activePaths.states.default)
      };
      this.$__.backup.validationError = this.$__.validationError;
      this.$__.backup.errors = this.errors;
      this.$__.activePaths.clear("modify");
      this.$__.activePaths.clear("default");
      this.$__.validationError = void 0;
      this.errors = void 0;
      _this = this;
      this.$__schema.requiredPaths().forEach(function(path3) {
        _this.$__.activePaths.require(path3);
      });
      return this;
    };
    Document6.prototype.$__undoReset = function $__undoReset() {
      if (this.$__.backup == null || this.$__.backup.activePaths == null) {
        return;
      }
      this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;
      this.$__.activePaths.states.default = this.$__.backup.activePaths.default;
      this.$__.validationError = this.$__.backup.validationError;
      this.errors = this.$__.backup.errors;
      for (const dirt of this.$__dirty()) {
        const type = dirt.value;
        if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {
          type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];
        }
      }
      for (const subdoc of this.$getAllSubdocs()) {
        subdoc.$__undoReset();
      }
    };
    Document6.prototype.$__dirty = function() {
      const _this = this;
      let all = this.$__.activePaths.map("modify", function(path3) {
        return {
          path: path3,
          value: _this.$__getValue(path3),
          schema: _this.$__path(path3)
        };
      });
      all = all.concat(this.$__.activePaths.map("default", function(path3) {
        if (path3 === "_id" || _this.$__getValue(path3) == null) {
          return;
        }
        return {
          path: path3,
          value: _this.$__getValue(path3),
          schema: _this.$__path(path3)
        };
      }));
      all.sort(function(a, b) {
        return a.path < b.path ? -1 : a.path > b.path ? 1 : 0;
      });
      const minimal = [];
      let lastPath;
      let top;
      all.forEach(function(item) {
        if (!item) {
          return;
        }
        if (lastPath == null || item.path.indexOf(lastPath) !== 0) {
          lastPath = item.path + ".";
          minimal.push(item);
          top = item;
        } else if (top != null && top.value != null && top.value[arrayAtomicsSymbol] != null && top.value.hasAtomics()) {
          top.value[arrayAtomicsSymbol] = {};
          top.value[arrayAtomicsSymbol].$set = top.value;
        }
      });
      top = lastPath = null;
      return minimal;
    };
    Document6.prototype.$__setSchema = function(schema) {
      schema.plugin(idGetter, { deduplicate: true });
      compile(schema.tree, this, void 0, schema.options);
      for (const key of Object.keys(schema.virtuals)) {
        schema.virtuals[key]._applyDefaultGetters();
      }
      if (schema.path("schema") == null) {
        this.schema = schema;
      }
      this.$__schema = schema;
      this[documentSchemaSymbol] = schema;
    };
    Document6.prototype.$__getArrayPathsToValidate = function() {
      DocumentArray || (DocumentArray = require_documentarray());
      return this.$__.activePaths.map("init", "modify", function(i) {
        return this.$__getValue(i);
      }.bind(this)).filter(function(val) {
        return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
      }).reduce(function(seed, array) {
        return seed.concat(array);
      }, []).filter(function(doc) {
        return doc;
      });
    };
    Document6.prototype.$getAllSubdocs = function $getAllSubdocs() {
      DocumentArray || (DocumentArray = require_documentarray());
      Embedded = Embedded || require_embedded();
      function docReducer(doc, seed, path3) {
        let val = doc;
        let isNested = false;
        if (path3) {
          if (doc instanceof Document6 && doc[documentSchemaSymbol].paths[path3]) {
            val = doc._doc[path3];
          } else if (doc instanceof Document6 && doc[documentSchemaSymbol].nested[path3]) {
            val = doc._doc[path3];
            isNested = true;
          } else {
            val = doc[path3];
          }
        }
        if (val instanceof Embedded) {
          seed.push(val);
        } else if (val instanceof Map) {
          seed = Array.from(val.keys()).reduce(function(seed2, path4) {
            return docReducer(val.get(path4), seed2, null);
          }, seed);
        } else if (val && val.$isSingleNested) {
          seed = Object.keys(val._doc).reduce(function(seed2, path4) {
            return docReducer(val._doc, seed2, path4);
          }, seed);
          seed.push(val);
        } else if (val && val.isMongooseDocumentArray) {
          val.forEach(function _docReduce(doc2) {
            if (!doc2 || !doc2._doc) {
              return;
            }
            seed = Object.keys(doc2._doc).reduce(function(seed2, path4) {
              return docReducer(doc2._doc, seed2, path4);
            }, seed);
            if (doc2 instanceof Embedded) {
              seed.push(doc2);
            }
          });
        } else if (isNested && val != null) {
          for (const path4 of Object.keys(val)) {
            docReducer(val, seed, path4);
          }
        }
        return seed;
      }
      const subDocs = [];
      for (const path3 of Object.keys(this._doc)) {
        docReducer(this, subDocs, path3);
      }
      return subDocs;
    };
    function applyQueue(doc) {
      const q = doc.$__schema && doc.$__schema.callQueue;
      if (!q.length) {
        return;
      }
      for (const pair of q) {
        if (pair[0] !== "pre" && pair[0] !== "post" && pair[0] !== "on") {
          doc[pair[0]].apply(doc, pair[1]);
        }
      }
    }
    Document6.prototype.$__handleReject = function handleReject(err) {
      if (this.listeners("error").length) {
        this.emit("error", err);
      } else if (this.constructor.listeners && this.constructor.listeners("error").length) {
        this.constructor.emit("error", err);
      }
    };
    Document6.prototype.$toObject = function(options, json) {
      let defaultOptions = {
        transform: true,
        flattenDecimals: true
      };
      const path3 = json ? "toJSON" : "toObject";
      const baseOptions = get(this, "constructor.base.options." + path3, {});
      const schemaOptions = get(this, "$__schema.options", {});
      defaultOptions = utils.options(defaultOptions, clone(baseOptions));
      defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path3] || {}));
      options = utils.isPOJO(options) ? clone(options) : {};
      options._calledWithOptions = options._calledWithOptions || clone(options);
      let _minimize;
      if (options._calledWithOptions.minimize != null) {
        _minimize = options.minimize;
      } else if (defaultOptions.minimize != null) {
        _minimize = defaultOptions.minimize;
      } else {
        _minimize = schemaOptions.minimize;
      }
      let flattenMaps;
      if (options._calledWithOptions.flattenMaps != null) {
        flattenMaps = options.flattenMaps;
      } else if (defaultOptions.flattenMaps != null) {
        flattenMaps = defaultOptions.flattenMaps;
      } else {
        flattenMaps = schemaOptions.flattenMaps;
      }
      const cloneOptions = Object.assign(utils.clone(options), {
        _isNested: true,
        json,
        minimize: _minimize,
        flattenMaps
      });
      if (utils.hasUserDefinedProperty(options, "getters")) {
        cloneOptions.getters = options.getters;
      }
      if (utils.hasUserDefinedProperty(options, "virtuals")) {
        cloneOptions.virtuals = options.virtuals;
      }
      const depopulate = options.depopulate || get(options, "_parentOptions.depopulate", false);
      if (depopulate && options._isNested && this.$__.wasPopulated) {
        return clone(this._id, cloneOptions);
      }
      options = utils.options(defaultOptions, options);
      options._isNested = true;
      options.json = json;
      options.minimize = _minimize;
      cloneOptions._parentOptions = options;
      cloneOptions._skipSingleNestedGetters = true;
      const gettersOptions = Object.assign({}, cloneOptions);
      gettersOptions._skipSingleNestedGetters = false;
      const originalTransform = options.transform;
      let ret2 = clone(this._doc, cloneOptions) || {};
      if (options.getters) {
        applyGetters(this, ret2, gettersOptions);
        if (options.minimize) {
          ret2 = minimize(ret2) || {};
        }
      }
      if (options.virtuals || options.getters && options.virtuals !== false) {
        applyVirtuals(this, ret2, gettersOptions, options);
      }
      if (options.versionKey === false && this.$__schema.options.versionKey) {
        delete ret2[this.$__schema.options.versionKey];
      }
      let transform = options.transform;
      if (transform) {
        applySchemaTypeTransforms(this, ret2);
      }
      if (options.useProjection) {
        omitDeselectedFields(this, ret2);
      }
      if (transform === true || schemaOptions.toObject && transform) {
        const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;
        if (opts) {
          transform = typeof options.transform === "function" ? options.transform : opts.transform;
        }
      } else {
        options.transform = originalTransform;
      }
      if (typeof transform === "function") {
        const xformed = transform(this, ret2, options);
        if (typeof xformed !== "undefined") {
          ret2 = xformed;
        }
      }
      return ret2;
    };
    Document6.prototype.toObject = function(options) {
      return this.$toObject(options);
    };
    function minimize(obj2) {
      const keys = Object.keys(obj2);
      let i = keys.length;
      let hasKeys;
      let key;
      let val;
      while (i--) {
        key = keys[i];
        val = obj2[key];
        if (utils.isObject(val) && !Buffer.isBuffer(val)) {
          obj2[key] = minimize(val);
        }
        if (void 0 === obj2[key]) {
          delete obj2[key];
          continue;
        }
        hasKeys = true;
      }
      return hasKeys ? obj2 : void 0;
    }
    function applyVirtuals(self2, json, options, toObjectOptions) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.virtuals);
      let i = paths.length;
      const numPaths = i;
      let path3;
      let assignPath;
      let cur = self2._doc;
      let v;
      const aliases = get(toObjectOptions, "aliases", true);
      let virtualsToApply = null;
      if (Array.isArray(options.virtuals)) {
        virtualsToApply = new Set(options.virtuals);
      } else if (options.virtuals && options.virtuals.pathsToSkip) {
        virtualsToApply = new Set(paths);
        for (let i2 = 0; i2 < options.virtuals.pathsToSkip.length; i2++) {
          if (virtualsToApply.has(options.virtuals.pathsToSkip[i2])) {
            virtualsToApply.delete(options.virtuals.pathsToSkip[i2]);
          }
        }
      }
      if (!cur) {
        return json;
      }
      options = options || {};
      for (i = 0; i < numPaths; ++i) {
        path3 = paths[i];
        if (virtualsToApply != null && !virtualsToApply.has(path3)) {
          continue;
        }
        if (!aliases && schema.aliases.hasOwnProperty(path3)) {
          continue;
        }
        assignPath = path3;
        if (options.path != null) {
          if (!path3.startsWith(options.path + ".")) {
            continue;
          }
          assignPath = path3.substr(options.path.length + 1);
        }
        const parts = assignPath.split(".");
        v = clone(self2.get(path3), options);
        if (v === void 0) {
          continue;
        }
        const plen = parts.length;
        cur = json;
        for (let j = 0; j < plen - 1; ++j) {
          cur[parts[j]] = cur[parts[j]] || {};
          cur = cur[parts[j]];
        }
        cur[parts[plen - 1]] = v;
      }
      return json;
    }
    function applyGetters(self2, json, options) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.paths);
      let i = paths.length;
      let path3;
      let cur = self2._doc;
      let v;
      if (!cur) {
        return json;
      }
      while (i--) {
        path3 = paths[i];
        const parts = path3.split(".");
        const plen = parts.length;
        const last = plen - 1;
        let branch = json;
        let part;
        cur = self2._doc;
        if (!self2.$__isSelected(path3)) {
          continue;
        }
        for (let ii = 0; ii < plen; ++ii) {
          part = parts[ii];
          v = cur[part];
          if (ii === last) {
            const val = self2.get(path3);
            branch[part] = clone(val, options);
          } else if (v == null) {
            if (part in cur) {
              branch[part] = v;
            }
            break;
          } else {
            branch = branch[part] || (branch[part] = {});
          }
          cur = v;
        }
      }
      return json;
    }
    function applySchemaTypeTransforms(self2, json) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.paths || {});
      const cur = self2._doc;
      if (!cur) {
        return json;
      }
      for (const path3 of paths) {
        const schematype = schema.paths[path3];
        if (typeof schematype.options.transform === "function") {
          const val = self2.get(path3);
          const transformedValue = schematype.options.transform.call(self2, val);
          throwErrorIfPromise(path3, transformedValue);
          utils.setValue(path3, transformedValue, json);
        } else if (schematype.$embeddedSchemaType != null && typeof schematype.$embeddedSchemaType.options.transform === "function") {
          const vals = [].concat(self2.get(path3));
          const transform = schematype.$embeddedSchemaType.options.transform;
          for (let i = 0; i < vals.length; ++i) {
            const transformedValue = transform.call(self2, vals[i]);
            vals[i] = transformedValue;
            throwErrorIfPromise(path3, transformedValue);
          }
          json[path3] = vals;
        }
      }
      return json;
    }
    function throwErrorIfPromise(path3, transformedValue) {
      if (isPromise(transformedValue)) {
        throw new Error("`transform` function must be synchronous, but the transform on path `" + path3 + "` returned a promise.");
      }
    }
    function omitDeselectedFields(self2, json) {
      const schema = self2.$__schema;
      const paths = Object.keys(schema.paths || {});
      const cur = self2._doc;
      if (!cur) {
        return json;
      }
      let selected = self2.$__.selected;
      if (selected === void 0) {
        selected = {};
        queryhelpers.applyPaths(selected, schema);
      }
      if (selected == null || Object.keys(selected).length === 0) {
        return json;
      }
      for (const path3 of paths) {
        if (selected[path3] != null && !selected[path3]) {
          delete json[path3];
        }
      }
      return json;
    }
    Document6.prototype.toJSON = function(options) {
      return this.$toObject(options, true);
    };
    Document6.prototype.parent = function() {
      return this.$__.parent;
    };
    Document6.prototype.$parent = Document6.prototype.parent;
    Document6.prototype.inspect = function(options) {
      const isPOJO = utils.isPOJO(options);
      let opts;
      if (isPOJO) {
        opts = options;
        opts.minimize = false;
      }
      const ret2 = this.toObject(opts);
      if (ret2 == null) {
        return "MongooseDocument { " + ret2 + " }";
      }
      return ret2;
    };
    if (inspect.custom) {
      Document6.prototype[inspect.custom] = Document6.prototype.inspect;
    }
    Document6.prototype.toString = function() {
      const ret2 = this.inspect();
      if (typeof ret2 === "string") {
        return ret2;
      }
      return inspect(ret2);
    };
    Document6.prototype.equals = function(doc) {
      if (!doc) {
        return false;
      }
      const tid = this.$__getValue("_id");
      const docid = doc.$__ != null ? doc.$__getValue("_id") : doc;
      if (!tid && !docid) {
        return deepEqual(this, doc);
      }
      return tid && tid.equals ? tid.equals(docid) : tid === docid;
    };
    Document6.prototype.populate = function populate() {
      if (arguments.length === 0) {
        return this;
      }
      const pop = this.$__.populate || (this.$__.populate = {});
      const args = utils.args(arguments);
      let fn;
      if (typeof args[args.length - 1] === "function") {
        fn = args.pop();
      }
      if (args.length) {
        const res = utils.populate.apply(null, args);
        for (const populateOptions of res) {
          pop[populateOptions.path] = populateOptions;
        }
      }
      if (fn) {
        const paths = utils.object.vals(pop);
        this.$__.populate = void 0;
        let topLevelModel = this.constructor;
        if (this.$__isNested) {
          topLevelModel = this.$__[scopeSymbol].constructor;
          const nestedPath = this.$__.nestedPath;
          paths.forEach(function(populateOptions) {
            populateOptions.path = nestedPath + "." + populateOptions.path;
          });
        }
        if (this.$session() != null) {
          const session = this.$session();
          paths.forEach((path3) => {
            if (path3.options == null) {
              path3.options = { session };
              return;
            }
            if (!("session" in path3.options)) {
              path3.options.session = session;
            }
          });
        }
        topLevelModel.populate(this, paths, fn);
      }
      return this;
    };
    Document6.prototype.$getPopulatedDocs = function $getPopulatedDocs() {
      let keys = [];
      if (this.$__.populated != null) {
        keys = keys.concat(Object.keys(this.$__.populated));
      }
      if (this.$$populatedVirtuals != null) {
        keys = keys.concat(Object.keys(this.$$populatedVirtuals));
      }
      let result = [];
      for (const key of keys) {
        const value = this.get(key);
        if (Array.isArray(value)) {
          result = result.concat(value);
        } else if (value instanceof Document6) {
          result.push(value);
        }
      }
      return result;
    };
    Document6.prototype.execPopulate = function(callback) {
      const isUsingShorthand = callback != null && typeof callback !== "function";
      if (isUsingShorthand) {
        return this.populate.apply(this, arguments).execPopulate();
      }
      return promiseOrCallback(callback, (cb) => {
        this.populate(cb);
      }, this.constructor.events);
    };
    Document6.prototype.populated = function(path3, val, options) {
      if (val == null || val === true) {
        if (!this.$__.populated) {
          return void 0;
        }
        const _path = path3.endsWith(".$*") ? path3.replace(/\.\$\*$/, "") : path3;
        const v = this.$__.populated[_path];
        if (v) {
          return val === true ? v : v.value;
        }
        return void 0;
      }
      this.$__.populated || (this.$__.populated = {});
      this.$__.populated[path3] = { value: val, options };
      const pieces = path3.split(".");
      for (let i = 0; i < pieces.length - 1; ++i) {
        const subpath = pieces.slice(0, i + 1).join(".");
        const subdoc = this.get(subpath);
        if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {
          const rest = pieces.slice(i + 1).join(".");
          subdoc.populated(rest, val, options);
          break;
        }
      }
      return val;
    };
    Document6.prototype.depopulate = function(path3) {
      if (typeof path3 === "string") {
        path3 = path3.split(" ");
      }
      let populatedIds;
      const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
      const populated = get(this, "$__.populated", {});
      if (arguments.length === 0) {
        for (const virtualKey of virtualKeys) {
          delete this.$$populatedVirtuals[virtualKey];
          delete this._doc[virtualKey];
          delete populated[virtualKey];
        }
        const keys = Object.keys(populated);
        for (const key of keys) {
          populatedIds = this.populated(key);
          if (!populatedIds) {
            continue;
          }
          delete populated[key];
          utils.setValue(key, populatedIds, this._doc);
        }
        return this;
      }
      for (const singlePath of path3) {
        populatedIds = this.populated(singlePath);
        delete populated[singlePath];
        if (virtualKeys.indexOf(singlePath) !== -1) {
          delete this.$$populatedVirtuals[singlePath];
          delete this._doc[singlePath];
        } else if (populatedIds) {
          utils.setValue(singlePath, populatedIds, this._doc);
        }
      }
      return this;
    };
    Document6.prototype.$__fullPath = function(path3) {
      return path3 || "";
    };
    Document6.prototype.getChanges = function() {
      const delta = this.$__delta();
      const changes = delta ? delta[1] : {};
      return changes;
    };
    Document6.ValidationError = ValidationError;
    module2.exports = exports2 = Document6;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/utils.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var ms = require_ms();
    var mpath = require_mpath();
    var sliced = require_sliced();
    var Buffer2 = require_safe_buffer().Buffer;
    var Decimal = require_decimal128();
    var ObjectId2 = require_objectid2();
    var PopulateOptions = require_PopulateOptions();
    var clone = require_clone();
    var immediate = require_immediate();
    var isObject3 = require_isObject();
    var isBsonType = require_isBsonType();
    var getFunctionName = require_getFunctionName();
    var isMongooseObject = require_isMongooseObject();
    var promiseOrCallback = require_promiseOrCallback();
    var schemaMerge = require_merge();
    var specialProperties = require_specialProperties();
    var Document6;
    exports2.specialProperties = specialProperties;
    exports2.toCollectionName = function(name, pluralize) {
      if (name === "system.profile") {
        return name;
      }
      if (name === "system.indexes") {
        return name;
      }
      if (typeof pluralize === "function") {
        return pluralize(name);
      }
      return name;
    };
    exports2.deepEqual = function deepEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (typeof a !== "object" && typeof b !== "object") {
        return a === b;
      }
      if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      }
      if (isBsonType(a, "ObjectID") && isBsonType(b, "ObjectID") || isBsonType(a, "Decimal128") && isBsonType(b, "Decimal128")) {
        return a.toString() === b.toString();
      }
      if (a instanceof RegExp && b instanceof RegExp) {
        return a.source === b.source && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.global === b.global;
      }
      if (a == null || b == null) {
        return false;
      }
      if (a.prototype !== b.prototype) {
        return false;
      }
      if (a instanceof Map && b instanceof Map) {
        return deepEqual(Array.from(a.keys()), Array.from(b.keys())) && deepEqual(Array.from(a.values()), Array.from(b.values()));
      }
      if (a instanceof Number && b instanceof Number) {
        return a.valueOf() === b.valueOf();
      }
      if (Buffer2.isBuffer(a)) {
        return exports2.buffer.areEqual(a, b);
      }
      if (Array.isArray(a) && Array.isArray(b)) {
        const len = a.length;
        if (len !== b.length) {
          return false;
        }
        for (let i = 0; i < len; ++i) {
          if (!deepEqual(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      if (a.$__ != null) {
        a = a._doc;
      } else if (isMongooseObject(a)) {
        a = a.toObject();
      }
      if (b.$__ != null) {
        b = b._doc;
      } else if (isMongooseObject(b)) {
        b = b.toObject();
      }
      const ka = Object.keys(a);
      const kb = Object.keys(b);
      const kaLength = ka.length;
      if (kaLength !== kb.length) {
        return false;
      }
      ka.sort();
      kb.sort();
      for (let i = kaLength - 1; i >= 0; i--) {
        if (ka[i] !== kb[i]) {
          return false;
        }
      }
      for (const key of ka) {
        if (!deepEqual(a[key], b[key])) {
          return false;
        }
      }
      return true;
    };
    exports2.last = function(arr) {
      if (arr.length > 0) {
        return arr[arr.length - 1];
      }
      return void 0;
    };
    exports2.clone = clone;
    exports2.promiseOrCallback = promiseOrCallback;
    exports2.omit = function omit(obj2, keys) {
      if (keys == null) {
        return Object.assign({}, obj2);
      }
      if (!Array.isArray(keys)) {
        keys = [keys];
      }
      const ret2 = Object.assign({}, obj2);
      for (const key of keys) {
        delete ret2[key];
      }
      return ret2;
    };
    exports2.options = function(defaults, options) {
      const keys = Object.keys(defaults);
      let i = keys.length;
      let k;
      options = options || {};
      while (i--) {
        k = keys[i];
        if (!(k in options)) {
          options[k] = defaults[k];
        }
      }
      return options;
    };
    exports2.random = function() {
      return Math.random().toString().substr(3);
    };
    exports2.merge = function merge2(to, from, options, path3) {
      options = options || {};
      const keys = Object.keys(from);
      let i = 0;
      const len = keys.length;
      let key;
      path3 = path3 || "";
      const omitNested = options.omitNested || {};
      while (i < len) {
        key = keys[i++];
        if (options.omit && options.omit[key]) {
          continue;
        }
        if (omitNested[path3]) {
          continue;
        }
        if (specialProperties.has(key)) {
          continue;
        }
        if (to[key] == null) {
          to[key] = from[key];
        } else if (exports2.isObject(from[key])) {
          if (!exports2.isObject(to[key])) {
            to[key] = {};
          }
          if (from[key] != null) {
            if (options.isDiscriminatorSchemaMerge && (from[key].$isSingleNested && to[key].$isMongooseDocumentArray) || from[key].$isMongooseDocumentArray && to[key].$isSingleNested) {
              continue;
            } else if (from[key].instanceOfSchema) {
              if (to[key].instanceOfSchema) {
                schemaMerge(to[key], from[key].clone(), options.isDiscriminatorSchemaMerge);
              } else {
                to[key] = from[key].clone();
              }
              continue;
            } else if (from[key] instanceof ObjectId2) {
              to[key] = new ObjectId2(from[key]);
              continue;
            }
          }
          merge2(to[key], from[key], options, path3 ? path3 + "." + key : key);
        } else if (options.overwrite) {
          to[key] = from[key];
        }
      }
    };
    exports2.toObject = function toObject(obj2) {
      Document6 || (Document6 = require_document());
      let ret2;
      if (obj2 == null) {
        return obj2;
      }
      if (obj2 instanceof Document6) {
        return obj2.toObject();
      }
      if (Array.isArray(obj2)) {
        ret2 = [];
        for (const doc of obj2) {
          ret2.push(toObject(doc));
        }
        return ret2;
      }
      if (exports2.isPOJO(obj2)) {
        ret2 = {};
        for (const k of Object.keys(obj2)) {
          if (specialProperties.has(k)) {
            continue;
          }
          ret2[k] = toObject(obj2[k]);
        }
        return ret2;
      }
      return obj2;
    };
    exports2.isObject = isObject3;
    exports2.isPOJO = function isPOJO(arg) {
      if (arg == null || typeof arg !== "object") {
        return false;
      }
      const proto = Object.getPrototypeOf(arg);
      return !proto || proto.constructor.name === "Object";
    };
    exports2.isNativeObject = function(arg) {
      return Array.isArray(arg) || arg instanceof Date || arg instanceof Boolean || arg instanceof Number || arg instanceof String;
    };
    exports2.isEmptyObject = function(val) {
      return val != null && typeof val === "object" && Object.keys(val).length === 0;
    };
    exports2.hasKey = function hasKey(obj2, key) {
      const props = Object.keys(obj2);
      for (const prop of props) {
        if (prop === key) {
          return true;
        }
        if (exports2.isPOJO(obj2[prop]) && exports2.hasKey(obj2[prop], key)) {
          return true;
        }
      }
      return false;
    };
    exports2.args = sliced;
    exports2.tick = function tick(callback) {
      if (typeof callback !== "function") {
        return;
      }
      return function() {
        try {
          callback.apply(this, arguments);
        } catch (err) {
          immediate(function() {
            throw err;
          });
        }
      };
    };
    exports2.isMongooseType = function(v) {
      return v instanceof ObjectId2 || v instanceof Decimal || v instanceof Buffer2;
    };
    exports2.isMongooseObject = isMongooseObject;
    exports2.expires = function expires(object) {
      if (!(object && object.constructor.name === "Object")) {
        return;
      }
      if (!("expires" in object)) {
        return;
      }
      let when;
      if (typeof object.expires !== "string") {
        when = object.expires;
      } else {
        when = Math.round(ms(object.expires) / 1e3);
      }
      object.expireAfterSeconds = when;
      delete object.expires;
    };
    exports2.populate = function populate(path3, select, model, match, options, subPopulate, justOne, count) {
      let obj2 = null;
      if (arguments.length === 1) {
        if (path3 instanceof PopulateOptions) {
          return [path3];
        }
        if (Array.isArray(path3)) {
          const singles = makeSingles(path3);
          return singles.map((o) => exports2.populate(o)[0]);
        }
        if (exports2.isObject(path3)) {
          obj2 = Object.assign({}, path3);
        } else {
          obj2 = { path: path3 };
        }
      } else if (typeof model === "object") {
        obj2 = {
          path: path3,
          select,
          match: model,
          options: match
        };
      } else {
        obj2 = {
          path: path3,
          select,
          model,
          match,
          options,
          populate: subPopulate,
          justOne,
          count
        };
      }
      if (typeof obj2.path !== "string") {
        throw new TypeError("utils.populate: invalid path. Expected string. Got typeof `" + typeof path3 + "`");
      }
      return _populateObj(obj2);
      function makeSingles(arr) {
        const ret2 = [];
        arr.forEach(function(obj3) {
          if (/[\s]/.test(obj3.path)) {
            const paths = obj3.path.split(" ");
            paths.forEach(function(p) {
              const copy = Object.assign({}, obj3);
              copy.path = p;
              ret2.push(copy);
            });
          } else {
            ret2.push(obj3);
          }
        });
        return ret2;
      }
    };
    function _populateObj(obj2) {
      if (Array.isArray(obj2.populate)) {
        const ret3 = [];
        obj2.populate.forEach(function(obj3) {
          if (/[\s]/.test(obj3.path)) {
            const copy = Object.assign({}, obj3);
            const paths2 = copy.path.split(" ");
            paths2.forEach(function(p) {
              copy.path = p;
              ret3.push(exports2.populate(copy)[0]);
            });
          } else {
            ret3.push(exports2.populate(obj3)[0]);
          }
        });
        obj2.populate = exports2.populate(ret3);
      } else if (obj2.populate != null && typeof obj2.populate === "object") {
        obj2.populate = exports2.populate(obj2.populate);
      }
      const ret2 = [];
      const paths = obj2.path.split(" ");
      if (obj2.options != null) {
        obj2.options = exports2.clone(obj2.options);
      }
      for (const path3 of paths) {
        ret2.push(new PopulateOptions(Object.assign({}, obj2, { path: path3 })));
      }
      return ret2;
    }
    exports2.getValue = function(path3, obj2, map) {
      return mpath.get(path3, obj2, "_doc", map);
    };
    exports2.setValue = function(path3, val, obj2, map, _copying) {
      mpath.set(path3, val, obj2, "_doc", map, _copying);
    };
    exports2.object = {};
    exports2.object.vals = function vals(o) {
      const keys = Object.keys(o);
      let i = keys.length;
      const ret2 = [];
      while (i--) {
        ret2.push(o[keys[i]]);
      }
      return ret2;
    };
    exports2.object.shallowCopy = exports2.options;
    var hop = Object.prototype.hasOwnProperty;
    exports2.object.hasOwnProperty = function(obj2, prop) {
      return hop.call(obj2, prop);
    };
    exports2.isNullOrUndefined = function(val) {
      return val === null || val === void 0;
    };
    exports2.array = {};
    exports2.array.flatten = function flatten(arr, filter, ret2) {
      ret2 || (ret2 = []);
      arr.forEach(function(item) {
        if (Array.isArray(item)) {
          flatten(item, filter, ret2);
        } else {
          if (!filter || filter(item)) {
            ret2.push(item);
          }
        }
      });
      return ret2;
    };
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    exports2.hasUserDefinedProperty = function(obj2, key) {
      if (obj2 == null) {
        return false;
      }
      if (Array.isArray(key)) {
        for (const k of key) {
          if (exports2.hasUserDefinedProperty(obj2, k)) {
            return true;
          }
        }
        return false;
      }
      if (_hasOwnProperty.call(obj2, key)) {
        return true;
      }
      if (typeof obj2 === "object" && key in obj2) {
        const v = obj2[key];
        return v !== Object.prototype[key] && v !== Array.prototype[key];
      }
      return false;
    };
    var MAX_ARRAY_INDEX = Math.pow(2, 32) - 1;
    exports2.isArrayIndex = function(val) {
      if (typeof val === "number") {
        return val >= 0 && val <= MAX_ARRAY_INDEX;
      }
      if (typeof val === "string") {
        if (!/^\d+$/.test(val)) {
          return false;
        }
        val = +val;
        return val >= 0 && val <= MAX_ARRAY_INDEX;
      }
      return false;
    };
    exports2.array.unique = function(arr) {
      const primitives = /* @__PURE__ */ new Set();
      const ids = /* @__PURE__ */ new Set();
      const ret2 = [];
      for (const item of arr) {
        if (typeof item === "number" || typeof item === "string" || item == null) {
          if (primitives.has(item)) {
            continue;
          }
          ret2.push(item);
          primitives.add(item);
        } else if (item instanceof ObjectId2) {
          if (ids.has(item.toString())) {
            continue;
          }
          ret2.push(item);
          ids.add(item.toString());
        } else {
          ret2.push(item);
        }
      }
      return ret2;
    };
    exports2.buffer = {};
    exports2.buffer.areEqual = function(a, b) {
      if (!Buffer2.isBuffer(a)) {
        return false;
      }
      if (!Buffer2.isBuffer(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0, len = a.length; i < len; ++i) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    };
    exports2.getFunctionName = getFunctionName;
    exports2.decorate = function(destination, source) {
      for (const key in source) {
        if (specialProperties.has(key)) {
          continue;
        }
        destination[key] = source[key];
      }
    };
    exports2.mergeClone = function(to, fromObj) {
      if (isMongooseObject(fromObj)) {
        fromObj = fromObj.toObject({
          transform: false,
          virtuals: false,
          depopulate: true,
          getters: false,
          flattenDecimals: false
        });
      }
      const keys = Object.keys(fromObj);
      const len = keys.length;
      let i = 0;
      let key;
      while (i < len) {
        key = keys[i++];
        if (specialProperties.has(key)) {
          continue;
        }
        if (typeof to[key] === "undefined") {
          to[key] = exports2.clone(fromObj[key], {
            transform: false,
            virtuals: false,
            depopulate: true,
            getters: false,
            flattenDecimals: false
          });
        } else {
          let val = fromObj[key];
          if (val != null && val.valueOf && !(val instanceof Date)) {
            val = val.valueOf();
          }
          if (exports2.isObject(val)) {
            let obj2 = val;
            if (isMongooseObject(val) && !val.isMongooseBuffer) {
              obj2 = obj2.toObject({
                transform: false,
                virtuals: false,
                depopulate: true,
                getters: false,
                flattenDecimals: false
              });
            }
            if (val.isMongooseBuffer) {
              obj2 = Buffer2.from(obj2);
            }
            exports2.mergeClone(to[key], obj2);
          } else {
            to[key] = exports2.clone(val, {
              flattenDecimals: false
            });
          }
        }
      }
    };
    exports2.each = function(arr, fn) {
      for (const item of arr) {
        fn(item);
      }
    };
    exports2.getOption = function(name) {
      const sources = Array.prototype.slice.call(arguments, 1);
      for (const source of sources) {
        if (source[name] != null) {
          return source[name];
        }
      }
      return null;
    };
    exports2.noop = function() {
    };
    exports2.errorToPOJO = function errorToPOJO(error) {
      const isError2 = error instanceof Error;
      if (!isError2) {
        throw new Error("`error` must be `instanceof Error`.");
      }
      const ret2 = {};
      for (const properyName of Object.getOwnPropertyNames(error)) {
        ret2[properyName] = error[properyName];
      }
      return ret2;
    };
    exports2.nodeMajorVersion = function nodeMajorVersion() {
      return parseInt(process.versions.node.split(".")[0], 10);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/clone.js
var require_clone = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/clone.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var cloneRegExp = require_regexp_clone();
    var Decimal = require_decimal128();
    var ObjectId2 = require_objectid2();
    var specialProperties = require_specialProperties();
    var isMongooseObject = require_isMongooseObject();
    var getFunctionName = require_getFunctionName();
    var isBsonType = require_isBsonType();
    var isObject3 = require_isObject();
    var symbols = require_symbols();
    var utils = require_utils2();
    function clone(obj2, options, isArrayChild) {
      if (obj2 == null) {
        return obj2;
      }
      if (Array.isArray(obj2)) {
        return cloneArray(obj2, options);
      }
      if (isMongooseObject(obj2)) {
        if (options && options._skipSingleNestedGetters && obj2.$isSingleNested) {
          options = Object.assign({}, options, { getters: false });
        }
        if (utils.isPOJO(obj2) && obj2.$__ != null && obj2._doc != null) {
          return obj2._doc;
        }
        if (options && options.json && typeof obj2.toJSON === "function") {
          return obj2.toJSON(options);
        }
        return obj2.toObject(options);
      }
      if (obj2.constructor) {
        switch (getFunctionName(obj2.constructor)) {
          case "Object":
            return cloneObject(obj2, options, isArrayChild);
          case "Date":
            return new obj2.constructor(+obj2);
          case "RegExp":
            return cloneRegExp(obj2);
          default:
            break;
        }
      }
      if (obj2 instanceof ObjectId2) {
        return new ObjectId2(obj2.id);
      }
      if (isBsonType(obj2, "Decimal128")) {
        if (options && options.flattenDecimals) {
          return obj2.toJSON();
        }
        return Decimal.fromString(obj2.toString());
      }
      if (!obj2.constructor && isObject3(obj2)) {
        return cloneObject(obj2, options, isArrayChild);
      }
      if (obj2[symbols.schemaTypeSymbol]) {
        return obj2.clone();
      }
      if (options && options.bson && typeof obj2.toBSON === "function") {
        return obj2;
      }
      if (obj2.valueOf != null) {
        return obj2.valueOf();
      }
      return cloneObject(obj2, options, isArrayChild);
    }
    module2.exports = clone;
    function cloneObject(obj2, options, isArrayChild) {
      const minimize = options && options.minimize;
      const ret2 = {};
      let hasKeys;
      for (const k of Object.keys(obj2)) {
        if (specialProperties.has(k)) {
          continue;
        }
        const val = clone(obj2[k], options);
        if (!minimize || typeof val !== "undefined") {
          if (minimize === false && typeof val === "undefined") {
            delete ret2[k];
          } else {
            hasKeys || (hasKeys = true);
            ret2[k] = val;
          }
        }
      }
      return minimize && !isArrayChild ? hasKeys && ret2 : ret2;
    }
    function cloneArray(arr, options) {
      const ret2 = [];
      for (const item of arr) {
        ret2.push(clone(item, options, true));
      }
      return ret2;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js
var require_collection4 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseCollection = require_collection();
    var MongooseError = require_mongooseError();
    var Collection = require("mongodb").Collection;
    var ObjectId2 = require_objectid();
    var get = require_get();
    var getConstructorName = require_getConstructorName();
    var sliced = require_sliced();
    var stream = require("stream");
    var util2 = require("util");
    function NativeCollection(name, conn, options) {
      this.collection = null;
      this.Promise = options.Promise || Promise;
      this.modelName = options.modelName;
      delete options.modelName;
      this._closed = false;
      MongooseCollection.apply(this, arguments);
    }
    NativeCollection.prototype.__proto__ = MongooseCollection.prototype;
    NativeCollection.prototype.onOpen = function() {
      const _this = this;
      if (!_this.opts.capped.size) {
        callback(null, _this.conn.db.collection(_this.name));
        return _this.collection;
      }
      if (_this.opts.autoCreate === false) {
        _this.collection = _this.conn.db.collection(_this.name);
        MongooseCollection.prototype.onOpen.call(_this);
        return _this.collection;
      }
      return _this.conn.db.collection(_this.name, function(err, c) {
        if (err)
          return callback(err);
        _this.conn.db.listCollections({ name: _this.name }).toArray(function(err2, docs) {
          if (err2) {
            return callback(err2);
          }
          const doc = docs[0];
          const exists = !!doc;
          if (exists) {
            if (doc.options && doc.options.capped) {
              callback(null, c);
            } else {
              const msg = "A non-capped collection exists with the name: " + _this.name + "\n\n To use this collection as a capped collection, please first convert it.\n http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-Convertingacollectiontocapped";
              err2 = new Error(msg);
              callback(err2);
            }
          } else {
            const opts = Object.assign({}, _this.opts.capped);
            opts.capped = true;
            _this.conn.db.createCollection(_this.name, opts, callback);
          }
        });
      });
      function callback(err, collection) {
        if (err) {
          _this.conn.emit("error", err);
        } else {
          _this.collection = collection;
          MongooseCollection.prototype.onOpen.call(_this);
        }
      }
    };
    NativeCollection.prototype.onClose = function(force) {
      MongooseCollection.prototype.onClose.call(this, force);
    };
    var syncCollectionMethods = { watch: true };
    function iter(i) {
      NativeCollection.prototype[i] = function() {
        const collection = this.collection;
        const args = Array.from(arguments);
        const _this = this;
        const debug = get(_this, "conn.base.options.debug");
        const lastArg = arguments[arguments.length - 1];
        const opId = new ObjectId2();
        if (this.conn.$wasForceClosed) {
          const error = new MongooseError("Connection was force closed");
          if (args.length > 0 && typeof args[args.length - 1] === "function") {
            args[args.length - 1](error);
            return;
          } else {
            throw error;
          }
        }
        let _args = args;
        let callback = null;
        if (this._shouldBufferCommands() && this.buffer) {
          if (syncCollectionMethods[i]) {
            throw new Error("Collection method " + i + " is synchronous");
          }
          this.conn.emit("buffer", {
            _id: opId,
            modelName: _this.modelName,
            collectionName: _this.name,
            method: i,
            args
          });
          let callback2;
          let _args2;
          let promise = null;
          let timeout = null;
          if (typeof lastArg === "function") {
            callback2 = function collectionOperationCallback() {
              if (timeout != null) {
                clearTimeout(timeout);
              }
              return lastArg.apply(this, arguments);
            };
            _args2 = args.slice(0, args.length - 1).concat([callback2]);
          } else {
            promise = new this.Promise((resolve, reject) => {
              callback2 = function collectionOperationCallback(err, res) {
                if (timeout != null) {
                  clearTimeout(timeout);
                }
                if (err != null) {
                  return reject(err);
                }
                resolve(res);
              };
              _args2 = args.concat([callback2]);
              this.addQueue(i, _args2);
            });
          }
          const bufferTimeoutMS = this._getBufferTimeoutMS();
          timeout = setTimeout(() => {
            const removed = this.removeQueue(i, _args2);
            if (removed) {
              const message = "Operation `" + this.name + "." + i + "()` buffering timed out after " + bufferTimeoutMS + "ms";
              const err = new MongooseError(message);
              this.conn.emit("buffer-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });
              callback2(err);
            }
          }, bufferTimeoutMS);
          if (typeof lastArg === "function") {
            this.addQueue(i, _args2);
            return;
          }
          return promise;
        } else if (!syncCollectionMethods[i] && typeof lastArg === "function") {
          callback = function collectionOperationCallback(err, res) {
            if (err != null) {
              _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });
            } else {
              _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, result: res });
            }
            return lastArg.apply(this, arguments);
          };
          _args = args.slice(0, args.length - 1).concat([callback]);
        }
        if (debug) {
          if (typeof debug === "function") {
            debug.apply(
              _this,
              [_this.name, i].concat(sliced(args, 0, args.length - 1))
            );
          } else if (debug instanceof stream.Writable) {
            this.$printToStream(_this.name, i, args, debug);
          } else {
            const color = debug.color == null ? true : debug.color;
            const shell = debug.shell == null ? false : debug.shell;
            this.$print(_this.name, i, args, color, shell);
          }
        }
        this.conn.emit("operation-start", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, params: _args });
        try {
          if (collection == null) {
            const message = "Cannot call `" + this.name + "." + i + "()` before initial connection is complete if `bufferCommands = false`. Make sure you `await mongoose.connect()` if you have `bufferCommands = false`.";
            throw new MongooseError(message);
          }
          const ret2 = collection[i].apply(collection, _args);
          if (ret2 != null && typeof ret2.then === "function") {
            return ret2.then(
              (res) => {
                this.conn.emit("operation-end", { _id: opId, modelName: this.modelName, collectionName: this.name, method: i, result: res });
                return res;
              },
              (err) => {
                this.conn.emit("operation-end", { _id: opId, modelName: this.modelName, collectionName: this.name, method: i, error: err });
                throw err;
              }
            );
          }
          return ret2;
        } catch (error) {
          if (typeof callback === "function") {
            callback(error);
          } else {
            this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, error });
          }
          if (typeof lastArg === "function") {
            lastArg(error);
          } else {
            throw error;
          }
        }
      };
    }
    for (const key of Object.keys(Collection.prototype)) {
      const descriptor = Object.getOwnPropertyDescriptor(Collection.prototype, key);
      if (descriptor.get !== void 0) {
        continue;
      }
      if (typeof Collection.prototype[key] !== "function") {
        continue;
      }
      iter(key);
    }
    NativeCollection.prototype.$print = function(name, i, args, color, shell) {
      const moduleName = color ? "\x1B[0;36mMongoose:\x1B[0m " : "Mongoose: ";
      const functionCall = [name, i].join(".");
      const _args = [];
      for (let j = args.length - 1; j >= 0; --j) {
        if (this.$format(args[j]) || _args.length) {
          _args.unshift(this.$format(args[j], color, shell));
        }
      }
      const params = "(" + _args.join(", ") + ")";
      console.info(moduleName + functionCall + params);
    };
    NativeCollection.prototype.$printToStream = function(name, i, args, stream2) {
      const functionCall = [name, i].join(".");
      const _args = [];
      for (let j = args.length - 1; j >= 0; --j) {
        if (this.$format(args[j]) || _args.length) {
          _args.unshift(this.$format(args[j]));
        }
      }
      const params = "(" + _args.join(", ") + ")";
      stream2.write(functionCall + params, "utf8");
    };
    NativeCollection.prototype.$format = function(arg, color, shell) {
      const type = typeof arg;
      if (type === "function" || type === "undefined")
        return "";
      return format3(arg, false, color, shell);
    };
    function inspectable(representation) {
      const ret2 = {
        inspect: function() {
          return representation;
        }
      };
      if (util2.inspect.custom) {
        ret2[util2.inspect.custom] = ret2.inspect;
      }
      return ret2;
    }
    function map(o) {
      return format3(o, true);
    }
    function formatObjectId(x, key) {
      x[key] = inspectable('ObjectId("' + x[key].toHexString() + '")');
    }
    function formatDate(x, key, shell) {
      if (shell) {
        x[key] = inspectable('ISODate("' + x[key].toUTCString() + '")');
      } else {
        x[key] = inspectable('new Date("' + x[key].toUTCString() + '")');
      }
    }
    function format3(obj2, sub, color, shell) {
      if (obj2 && typeof obj2.toBSON === "function") {
        obj2 = obj2.toBSON();
      }
      if (obj2 == null) {
        return obj2;
      }
      const clone = require_clone();
      let x = clone(obj2, { transform: false });
      const constructorName = getConstructorName(x);
      if (constructorName === "Binary") {
        x = "BinData(" + x.sub_type + ', "' + x.toString("base64") + '")';
      } else if (constructorName === "ObjectID") {
        x = inspectable('ObjectId("' + x.toHexString() + '")');
      } else if (constructorName === "Date") {
        x = inspectable('new Date("' + x.toUTCString() + '")');
      } else if (constructorName === "Object") {
        const keys = Object.keys(x);
        const numKeys = keys.length;
        let key;
        for (let i = 0; i < numKeys; ++i) {
          key = keys[i];
          if (x[key]) {
            let error;
            if (typeof x[key].toBSON === "function") {
              try {
                x[key] = x[key].toBSON();
              } catch (_error) {
                error = _error;
              }
            }
            const _constructorName = getConstructorName(x[key]);
            if (_constructorName === "Binary") {
              x[key] = "BinData(" + x[key].sub_type + ', "' + x[key].buffer.toString("base64") + '")';
            } else if (_constructorName === "Object") {
              x[key] = format3(x[key], true);
            } else if (_constructorName === "ObjectID") {
              formatObjectId(x, key);
            } else if (_constructorName === "Date") {
              formatDate(x, key, shell);
            } else if (_constructorName === "ClientSession") {
              x[key] = inspectable('ClientSession("' + get(x[key], "id.id.buffer", "").toString("hex") + '")');
            } else if (Array.isArray(x[key])) {
              x[key] = x[key].map(map);
            } else if (error != null) {
              throw error;
            }
          }
        }
      }
      if (sub) {
        return x;
      }
      return util2.inspect(x, false, 10, color).replace(/\n/g, "").replace(/\s{2,}/g, " ");
    }
    NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;
    module2.exports = NativeCollection;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/decimal128.js
var require_decimal1284 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/decimal128.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = require("mongodb").Decimal128;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/ReadPreference.js
var require_ReadPreference = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/ReadPreference.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var mongodb = require("mongodb");
    var ReadPref = mongodb.ReadPreference;
    module2.exports = function readPref(pref, tags) {
      if (Array.isArray(pref)) {
        tags = pref[1];
        pref = pref[0];
      }
      if (pref instanceof ReadPref) {
        return pref;
      }
      switch (pref) {
        case "p":
          pref = "primary";
          break;
        case "pp":
          pref = "primaryPreferred";
          break;
        case "s":
          pref = "secondary";
          break;
        case "sp":
          pref = "secondaryPreferred";
          break;
        case "n":
          pref = "nearest";
          break;
      }
      return new ReadPref(pref, tags);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cursor/ChangeStream.js
var require_ChangeStream = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cursor/ChangeStream.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var EventEmitter = require("events").EventEmitter;
    var ChangeStream = class extends EventEmitter {
      constructor(changeStreamThunk, pipeline, options) {
        super();
        this.driverChangeStream = null;
        this.closed = false;
        this.pipeline = pipeline;
        this.options = options;
        changeStreamThunk((err, driverChangeStream) => {
          if (err != null) {
            this.emit("error", err);
            return;
          }
          this.driverChangeStream = driverChangeStream;
          this._bindEvents();
          this.emit("ready");
        });
      }
      _bindEvents() {
        this.driverChangeStream.on("close", () => {
          this.closed = true;
        });
        ["close", "change", "end", "error"].forEach((ev) => {
          this.driverChangeStream.on(ev, (data) => this.emit(ev, data));
        });
      }
      _queue(cb) {
        this.once("ready", () => cb());
      }
      close() {
        this.closed = true;
        if (this.driverChangeStream) {
          this.driverChangeStream.close();
        }
      }
    };
    module2.exports = ChangeStream;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js
var require_allServersUnknown = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var getConstructorName = require_getConstructorName();
    module2.exports = function allServersUnknown(topologyDescription) {
      if (getConstructorName(topologyDescription) !== "TopologyDescription") {
        return false;
      }
      const servers = Array.from(topologyDescription.servers.values());
      return servers.length > 0 && servers.every((server) => server.type === "Unknown");
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/topology/isAtlas.js
var require_isAtlas = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/topology/isAtlas.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var getConstructorName = require_getConstructorName();
    module2.exports = function isAtlas(topologyDescription) {
      if (getConstructorName(topologyDescription) !== "TopologyDescription") {
        return false;
      }
      const hostnames = Array.from(topologyDescription.servers.keys());
      return hostnames.length > 0 && hostnames.every((host) => host.endsWith(".mongodb.net:27017"));
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/topology/isSSLError.js
var require_isSSLError = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/topology/isSSLError.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var getConstructorName = require_getConstructorName();
    var nonSSLMessage = "Client network socket disconnected before secure TLS connection was established";
    module2.exports = function isSSLError(topologyDescription) {
      if (getConstructorName(topologyDescription) !== "TopologyDescription") {
        return false;
      }
      const descriptions = Array.from(topologyDescription.servers.values());
      return descriptions.length > 0 && descriptions.every((descr) => descr.error && descr.error.message.indexOf(nonSSLMessage) !== -1);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/serverSelection.js
var require_serverSelection = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/error/serverSelection.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_mongooseError();
    var allServersUnknown = require_allServersUnknown();
    var isAtlas = require_isAtlas();
    var isSSLError = require_isSSLError();
    var atlasMessage = "Could not connect to any servers in your MongoDB Atlas cluster. One common reason is that you're trying to access the database from an IP that isn't whitelisted. Make sure your current IP address is on your Atlas cluster's IP whitelist: https://docs.atlas.mongodb.com/security-whitelist/";
    var sslMessage = "Mongoose is connecting with SSL enabled, but the server is not accepting SSL connections. Please ensure that the MongoDB server you are connecting to is configured to accept SSL connections. Learn more: https://mongoosejs.com/docs/tutorials/ssl.html";
    var MongooseServerSelectionError = class extends MongooseError {
      /**
       * MongooseServerSelectionError constructor
       *
       * @api private
       */
      assimilateError(err) {
        const reason = err.reason;
        const isAtlasWhitelistError = isAtlas(reason) && allServersUnknown(reason) && err.message.indexOf("bad auth") === -1 && err.message.indexOf("Authentication failed") === -1;
        if (isAtlasWhitelistError) {
          this.message = atlasMessage;
        } else if (isSSLError(reason)) {
          this.message = sslMessage;
        } else {
          this.message = err.message;
        }
        for (const key in err) {
          if (key !== "name") {
            this[key] = err[key];
          }
        }
        return this;
      }
    };
    Object.defineProperty(MongooseServerSelectionError.prototype, "name", {
      value: "MongooseServerSelectionError"
    });
    module2.exports = MongooseServerSelectionError;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/applyPlugins.js
var require_applyPlugins = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/applyPlugins.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function applyPlugins(schema, plugins, options, cacheKey) {
      if (schema[cacheKey]) {
        return;
      }
      schema[cacheKey] = true;
      if (!options || !options.skipTopLevel) {
        for (const plugin of plugins) {
          schema.plugin(plugin[0], plugin[1]);
        }
      }
      options = Object.assign({}, options);
      delete options.skipTopLevel;
      if (options.applyPluginsToChildSchemas !== false) {
        for (const path3 of Object.keys(schema.paths)) {
          const type = schema.paths[path3];
          if (type.schema != null) {
            applyPlugins(type.schema, plugins, options, cacheKey);
            type.caster.prototype.$__setSchema(type.schema);
          }
        }
      }
      const discriminators = schema.discriminators;
      if (discriminators == null) {
        return;
      }
      const applyPluginsToDiscriminators = options.applyPluginsToDiscriminators;
      const keys = Object.keys(discriminators);
      for (const discriminatorKey of keys) {
        const discriminatorSchema = discriminators[discriminatorKey];
        applyPlugins(
          discriminatorSchema,
          plugins,
          { skipTopLevel: !applyPluginsToDiscriminators },
          cacheKey
        );
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/package.json
var require_package = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/package.json"(exports2, module2) {
    module2.exports = {
      name: "mongoose",
      description: "Mongoose MongoDB ODM",
      version: "5.13.16",
      author: "Guillermo Rauch <guillermo@learnboost.com>",
      keywords: [
        "mongodb",
        "document",
        "model",
        "schema",
        "database",
        "odm",
        "data",
        "datastore",
        "query",
        "nosql",
        "orm",
        "db"
      ],
      license: "MIT",
      dependencies: {
        "@types/bson": "1.x || 4.0.x",
        "@types/mongodb": "^3.5.27",
        bson: "^1.1.4",
        kareem: "2.3.2",
        mongodb: "3.7.3",
        "mongoose-legacy-pluralize": "1.0.2",
        mpath: "0.8.4",
        mquery: "3.2.5",
        ms: "2.1.2",
        "optional-require": "1.0.x",
        "regexp-clone": "1.0.0",
        "safe-buffer": "5.2.1",
        sift: "13.5.2",
        sliced: "1.0.1"
      },
      devDependencies: {
        "@babel/core": "7.10.5",
        "@babel/preset-env": "7.10.4",
        "@typescript-eslint/eslint-plugin": "4.10.0",
        "@typescript-eslint/parser": "4.10.0",
        "@types/node": "16.11.23",
        acquit: "1.x",
        "acquit-ignore": "0.1.x",
        "acquit-require": "0.1.x",
        "babel-loader": "8.1.0",
        benchmark: "2.1.4",
        bluebird: "3.5.5",
        chalk: "2.4.2",
        cheerio: "1.0.0-rc.2",
        co: "4.6.0",
        dox: "0.3.1",
        eslint: "7.1.0",
        "eslint-plugin-mocha-no-only": "1.1.0",
        "highlight.js": "9.18.2",
        "lodash.isequal": "4.5.0",
        "lodash.isequalwith": "4.4.0",
        marked: "1.1.1",
        mkdirp: "0.5.5",
        mocha: "5.x",
        moment: "2.x",
        "node-static": "0.7.11",
        "object-sizeof": "1.3.0",
        pug: "2.0.3",
        q: "1.5.1",
        rimraf: "2.6.3",
        "schema-utils": "2.6.5",
        semver: "5.5.0",
        typescript: "4.1.x",
        uuid: "2.0.3",
        "uuid-parse": "1.0.0",
        validator: "10.8.0",
        webpack: "4.44.0"
      },
      directories: {
        lib: "./lib/mongoose"
      },
      scripts: {
        lint: "eslint .",
        "build-browser": "node build-browser.js",
        prepublishOnly: "npm run build-browser",
        release: "git pull && git push origin master --tags && npm publish",
        "release-legacy": "git pull origin 5.x && git push origin 5.x --tags && npm publish --tag legacy",
        test: "mocha --exit ./test/*.test.js ./test/typescript/main.test.js",
        tdd: "mocha ./test/*.test.js ./test/typescript/main.test.js --watch --recursive --watch-files ./**/*.js",
        "test-cov": "nyc --reporter=html --reporter=text npm test"
      },
      main: "./index.js",
      types: "./index.d.ts",
      engines: {
        node: ">=4.0.0"
      },
      bugs: {
        url: "https://github.com/Automattic/mongoose/issues/new"
      },
      repository: {
        type: "git",
        url: "git://github.com/Automattic/mongoose.git"
      },
      homepage: "https://mongoosejs.com",
      browser: "./dist/browser.umd.js",
      mocha: {
        extension: [
          "test.js"
        ],
        "watch-files": [
          "test/**/*.js"
        ]
      },
      eslintConfig: {
        extends: [
          "eslint:recommended"
        ],
        overrides: [
          {
            files: [
              "**/*.{ts,tsx}"
            ],
            extends: [
              "plugin:@typescript-eslint/eslint-recommended",
              "plugin:@typescript-eslint/recommended"
            ],
            plugins: [
              "@typescript-eslint"
            ],
            rules: {
              "@typescript-eslint/no-explicit-any": "off",
              "@typescript-eslint/ban-types": "off",
              "@typescript-eslint/no-unused-vars": "off",
              "@typescript-eslint/explicit-module-boundary-types": "off"
            }
          }
        ],
        plugins: [
          "mocha-no-only"
        ],
        parserOptions: {
          ecmaVersion: 2015
        },
        env: {
          node: true,
          es6: true
        },
        rules: {
          "comma-style": "error",
          indent: [
            "error",
            2,
            {
              SwitchCase: 1,
              VariableDeclarator: 2
            }
          ],
          "keyword-spacing": "error",
          "no-whitespace-before-property": "error",
          "no-buffer-constructor": "warn",
          "no-console": "off",
          "no-multi-spaces": "error",
          "no-constant-condition": "off",
          "func-call-spacing": "error",
          "no-trailing-spaces": "error",
          "no-undef": "error",
          "no-unneeded-ternary": "error",
          "no-const-assign": "error",
          "no-useless-rename": "error",
          "no-dupe-keys": "error",
          "space-in-parens": [
            "error",
            "never"
          ],
          "spaced-comment": [
            "error",
            "always",
            {
              block: {
                markers: [
                  "!"
                ],
                balanced: true
              }
            }
          ],
          "key-spacing": [
            "error",
            {
              beforeColon: false,
              afterColon: true
            }
          ],
          "comma-spacing": [
            "error",
            {
              before: false,
              after: true
            }
          ],
          "array-bracket-spacing": 1,
          "arrow-spacing": [
            "error",
            {
              before: true,
              after: true
            }
          ],
          "object-curly-spacing": [
            "error",
            "always"
          ],
          "comma-dangle": [
            "error",
            "never"
          ],
          "no-unreachable": "error",
          quotes: [
            "error",
            "single"
          ],
          "quote-props": [
            "error",
            "as-needed"
          ],
          semi: "error",
          "no-extra-semi": "error",
          "semi-spacing": "error",
          "no-spaced-func": "error",
          "no-throw-literal": "error",
          "space-before-blocks": "error",
          "space-before-function-paren": [
            "error",
            "never"
          ],
          "space-infix-ops": "error",
          "space-unary-ops": "error",
          "no-var": "warn",
          "prefer-const": "warn",
          strict: [
            "error",
            "global"
          ],
          "no-restricted-globals": [
            "error",
            {
              name: "context",
              message: "Don't use Mocha's global context"
            }
          ],
          "no-prototype-builtins": "off",
          "mocha-no-only/mocha-no-only": [
            "error"
          ]
        }
      },
      funding: {
        type: "opencollective",
        url: "https://opencollective.com/mongoose"
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/connection.js
var require_connection = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/connection.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ChangeStream = require_ChangeStream();
    var EventEmitter = require("events").EventEmitter;
    var Schema6 = require_schema2();
    var Collection = require_driver().get().Collection;
    var STATES = require_connectionstate();
    var MongooseError = require_error();
    var PromiseProvider = require_promise_provider();
    var ServerSelectionError = require_serverSelection();
    var applyPlugins = require_applyPlugins();
    var promiseOrCallback = require_promiseOrCallback();
    var get = require_get();
    var immediate = require_immediate();
    var mongodb = require("mongodb");
    var pkg = require_package();
    var utils = require_utils2();
    var parseConnectionString = require("mongodb/lib/core").parseConnectionString;
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var sessionNewDocuments = require_symbols().sessionNewDocuments;
    var noPasswordAuthMechanisms = [
      "MONGODB-X509"
    ];
    function Connection4(base) {
      this.base = base;
      this.collections = {};
      this.models = {};
      this.config = {};
      this.replica = false;
      this.options = null;
      this.otherDbs = [];
      this.relatedDbs = {};
      this.states = STATES;
      this._readyState = STATES.disconnected;
      this._closeCalled = false;
      this._hasOpened = false;
      this.plugins = [];
      if (typeof base === "undefined" || !base.connections.length) {
        this.id = 0;
      } else {
        this.id = base.connections.length;
      }
      this._queue = [];
    }
    Connection4.prototype.__proto__ = EventEmitter.prototype;
    Object.defineProperty(Connection4.prototype, "readyState", {
      get: function() {
        return this._readyState;
      },
      set: function(val) {
        if (!(val in STATES)) {
          throw new Error("Invalid connection state: " + val);
        }
        if (this._readyState !== val) {
          this._readyState = val;
          for (const db of this.otherDbs) {
            db.readyState = val;
          }
          if (STATES.connected === val) {
            this._hasOpened = true;
          }
          this.emit(STATES[val]);
        }
      }
    });
    Connection4.prototype.get = function(key) {
      if (this.config.hasOwnProperty(key)) {
        return this.config[key];
      }
      return get(this.options, key);
    };
    Connection4.prototype.set = function(key, val) {
      if (this.config.hasOwnProperty(key)) {
        this.config[key] = val;
        return val;
      }
      this.options = this.options || {};
      this.options[key] = val;
      return val;
    };
    Connection4.prototype.collections;
    Connection4.prototype.name;
    Connection4.prototype.models;
    Connection4.prototype.id;
    Object.defineProperty(Connection4.prototype, "plugins", {
      configurable: false,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection4.prototype, "host", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection4.prototype, "port", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection4.prototype, "user", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Object.defineProperty(Connection4.prototype, "pass", {
      configurable: true,
      enumerable: true,
      writable: true
    });
    Connection4.prototype.db;
    Connection4.prototype.client;
    Connection4.prototype.config;
    Connection4.prototype.createCollection = _wrapConnHelper(function createCollection(collection, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      this.db.createCollection(collection, options, cb);
    });
    Connection4.prototype.startSession = _wrapConnHelper(function startSession(options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      const session = this.client.startSession(options);
      cb(null, session);
    });
    Connection4.prototype.transaction = function transaction(fn, options) {
      return this.startSession().then((session) => {
        session[sessionNewDocuments] = /* @__PURE__ */ new Map();
        return session.withTransaction(() => fn(session), options).then((res) => {
          delete session[sessionNewDocuments];
          return res;
        }).catch((err) => {
          for (const doc of session[sessionNewDocuments].keys()) {
            const state = session[sessionNewDocuments].get(doc);
            if (state.hasOwnProperty("isNew")) {
              doc.isNew = state.isNew;
            }
            if (state.hasOwnProperty("versionKey")) {
              doc.set(doc.schema.options.versionKey, state.versionKey);
            }
            for (const path3 of state.modifiedPaths) {
              doc.$__.activePaths.paths[path3] = "modify";
              doc.$__.activePaths.states.modify[path3] = true;
            }
            for (const path3 of state.atomics.keys()) {
              const val = doc.$__getValue(path3);
              if (val == null) {
                continue;
              }
              val[arrayAtomicsSymbol] = state.atomics.get(path3);
            }
          }
          delete session[sessionNewDocuments];
          throw err;
        });
      });
    };
    Connection4.prototype.dropCollection = _wrapConnHelper(function dropCollection(collection, cb) {
      this.db.dropCollection(collection, cb);
    });
    Connection4.prototype.dropDatabase = _wrapConnHelper(function dropDatabase(cb) {
      for (const name of Object.keys(this.models)) {
        delete this.models[name].$init;
      }
      this.db.dropDatabase(cb);
    });
    function _wrapConnHelper(fn) {
      return function() {
        const cb = arguments.length > 0 ? arguments[arguments.length - 1] : null;
        const argsWithoutCb = typeof cb === "function" ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : Array.prototype.slice.call(arguments);
        const disconnectedError = new MongooseError("Connection " + this.id + " was disconnected when calling `" + fn.name + "`");
        return promiseOrCallback(cb, (cb2) => {
          immediate(() => {
            if (this.readyState === STATES.connecting && this._shouldBufferCommands()) {
              this._queue.push({ fn, ctx: this, args: argsWithoutCb.concat([cb2]) });
            } else if (this.readyState === STATES.disconnected && this.db == null) {
              cb2(disconnectedError);
            } else {
              try {
                fn.apply(this, argsWithoutCb.concat([cb2]));
              } catch (err) {
                return cb2(err);
              }
            }
          });
        });
      };
    }
    Connection4.prototype._shouldBufferCommands = function _shouldBufferCommands() {
      if (this.config.bufferCommands != null) {
        return this.config.bufferCommands;
      }
      if (this.base.get("bufferCommands") != null) {
        return this.base.get("bufferCommands");
      }
      return true;
    };
    Connection4.prototype.error = function(err, callback) {
      if (callback) {
        callback(err);
        return null;
      }
      if (this.listeners("error").length > 0) {
        this.emit("error", err);
      }
      return Promise.reject(err);
    };
    Connection4.prototype.onOpen = function() {
      this.readyState = STATES.connected;
      for (const d of this._queue) {
        d.fn.apply(d.ctx, d.args);
      }
      this._queue = [];
      for (const i in this.collections) {
        if (utils.object.hasOwnProperty(this.collections, i)) {
          this.collections[i].onOpen();
        }
      }
      this.emit("open");
    };
    Connection4.prototype.openUri = function(uri, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (["string", "number"].indexOf(typeof options) !== -1) {
        throw new MongooseError("Mongoose 5.x no longer supports `mongoose.connect(host, dbname, port)` or `mongoose.createConnection(host, dbname, port)`. See http://mongoosejs.com/docs/connections.html for supported connection syntax");
      }
      if (typeof uri !== "string") {
        throw new MongooseError(`The \`uri\` parameter to \`openUri()\` must be a string, got "${typeof uri}". Make sure the first parameter to \`mongoose.connect()\` or \`mongoose.createConnection()\` is a string.`);
      }
      if (callback != null && typeof callback !== "function") {
        throw new MongooseError('3rd parameter to `mongoose.connect()` or `mongoose.createConnection()` must be a function, got "' + typeof callback + '"');
      }
      if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {
        if (this._connectionString !== uri) {
          throw new MongooseError("Can't call `openUri()` on an active connection with different connection strings. Make sure you aren't calling `mongoose.connect()` multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections");
        }
        if (typeof callback === "function") {
          this.$initialConnection = this.$initialConnection.then(
            () => callback(null, this),
            (err) => callback(err)
          );
        }
        return this;
      }
      this._connectionString = uri;
      this.readyState = STATES.connecting;
      this._closeCalled = false;
      const Promise2 = PromiseProvider.get();
      const _this = this;
      if (options) {
        options = utils.clone(options);
        const autoIndex = options.config && options.config.autoIndex != null ? options.config.autoIndex : options.autoIndex;
        if (autoIndex != null) {
          this.config.autoIndex = autoIndex !== false;
          delete options.config;
          delete options.autoIndex;
        }
        if ("autoCreate" in options) {
          this.config.autoCreate = !!options.autoCreate;
          delete options.autoCreate;
        }
        if ("useCreateIndex" in options) {
          this.config.useCreateIndex = !!options.useCreateIndex;
          delete options.useCreateIndex;
        }
        if ("useFindAndModify" in options) {
          this.config.useFindAndModify = !!options.useFindAndModify;
          delete options.useFindAndModify;
        }
        if (options.user || options.pass) {
          options.auth = options.auth || {};
          options.auth.user = options.user;
          options.auth.password = options.pass;
          this.user = options.user;
          this.pass = options.pass;
        }
        delete options.user;
        delete options.pass;
        if (options.bufferCommands != null) {
          if (options.bufferMaxEntries == null) {
            options.bufferMaxEntries = 0;
          }
          this.config.bufferCommands = options.bufferCommands;
          delete options.bufferCommands;
        }
        if (options.useMongoClient != null) {
          handleUseMongoClient(options);
        }
      } else {
        options = {};
      }
      this._connectionOptions = options;
      const dbName = options.dbName;
      if (dbName != null) {
        this.$dbName = dbName;
      }
      delete options.dbName;
      if (!("promiseLibrary" in options)) {
        options.promiseLibrary = PromiseProvider.get();
      }
      if (!("useNewUrlParser" in options)) {
        if ("useNewUrlParser" in this.base.options) {
          options.useNewUrlParser = this.base.options.useNewUrlParser;
        } else {
          options.useNewUrlParser = false;
        }
      }
      if (!utils.hasUserDefinedProperty(options, "useUnifiedTopology")) {
        if (utils.hasUserDefinedProperty(this.base.options, "useUnifiedTopology")) {
          options.useUnifiedTopology = this.base.options.useUnifiedTopology;
        } else {
          options.useUnifiedTopology = false;
        }
      }
      if (!utils.hasUserDefinedProperty(options, "driverInfo")) {
        options.driverInfo = {
          name: "Mongoose",
          version: pkg.version
        };
      }
      const parsePromise = new Promise2((resolve, reject) => {
        parseConnectionString(uri, options, (err, parsed) => {
          if (err) {
            return reject(err);
          }
          if (dbName) {
            this.name = dbName;
          } else if (parsed.defaultDatabase) {
            this.name = parsed.defaultDatabase;
          } else {
            this.name = get(parsed, "auth.db", null);
          }
          this.host = get(parsed, "hosts.0.host", "localhost");
          this.port = get(parsed, "hosts.0.port", 27017);
          this.user = this.user || get(parsed, "auth.username");
          this.pass = this.pass || get(parsed, "auth.password");
          resolve();
        });
      });
      const promise = new Promise2((resolve, reject) => {
        const client = new mongodb.MongoClient(uri, options);
        _this.client = client;
        client.setMaxListeners(0);
        client.connect((error) => {
          if (error) {
            return reject(error);
          }
          _setClient(_this, client, options, dbName);
          resolve(_this);
        });
      });
      const serverSelectionError = new ServerSelectionError();
      this.$initialConnection = Promise2.all([promise, parsePromise]).then((res) => res[0]).catch((err) => {
        this.readyState = STATES.disconnected;
        if (err != null && err.name === "MongoServerSelectionError") {
          err = serverSelectionError.assimilateError(err);
        }
        if (this.listeners("error").length > 0) {
          immediate(() => this.emit("error", err));
        }
        throw err;
      });
      this.then = function(resolve, reject) {
        return this.$initialConnection.then(() => {
          if (typeof resolve === "function") {
            return resolve(_this);
          }
        }, reject);
      };
      this.catch = function(reject) {
        return this.$initialConnection.catch(reject);
      };
      if (callback != null) {
        this.$initialConnection = this.$initialConnection.then(
          () => callback(null, this),
          (err) => callback(err)
        );
      }
      return this;
    };
    function _setClient(conn, client, options, dbName) {
      const db = dbName != null ? client.db(dbName) : client.db();
      conn.db = db;
      conn.client = client;
      conn._closeCalled = client._closeCalled;
      const _handleReconnect = () => {
        if (conn.readyState !== STATES.connected) {
          conn.readyState = STATES.connected;
          conn.emit("reconnect");
          conn.emit("reconnected");
          conn.onOpen();
        }
      };
      const type = get(db, "s.topology.s.description.type", "");
      if (options.useUnifiedTopology) {
        if (type === "Single") {
          const server = Array.from(db.s.topology.s.servers.values())[0];
          server.s.topology.on("serverHeartbeatSucceeded", () => {
            _handleReconnect();
          });
          server.s.pool.on("reconnect", () => {
            _handleReconnect();
          });
          client.on("serverDescriptionChanged", (ev) => {
            const newDescription = ev.newDescription;
            if (newDescription.type === "Standalone") {
              _handleReconnect();
            } else {
              conn.readyState = STATES.disconnected;
            }
          });
        } else if (type.startsWith("ReplicaSet")) {
          client.on("topologyDescriptionChanged", (ev) => {
            const description = ev.newDescription;
            const servers = Array.from(ev.newDescription.servers.values());
            const allServersDisconnected = description.type === "ReplicaSetNoPrimary" && servers.reduce((cur, d) => cur || d.type === "Unknown", false);
            if (conn.readyState === STATES.connected && allServersDisconnected) {
              conn.readyState = STATES.disconnected;
            } else if (conn.readyState === STATES.disconnected && !allServersDisconnected) {
              _handleReconnect();
            }
          });
          client.on("close", function() {
            const type2 = get(db, "s.topology.s.description.type", "");
            if (type2 !== "ReplicaSetWithPrimary") {
              conn.readyState = STATES.disconnected;
            }
          });
        }
      }
      db.s.topology.on("reconnectFailed", function() {
        conn.emit("reconnectFailed");
      });
      if (!options.useUnifiedTopology) {
        client.on("reconnect", function() {
          _handleReconnect();
        });
        db.s.topology.on("left", function(data) {
          conn.emit("left", data);
        });
      }
      db.s.topology.on("joined", function(data) {
        conn.emit("joined", data);
      });
      db.s.topology.on("fullsetup", function(data) {
        conn.emit("fullsetup", data);
      });
      if (get(db, "s.topology.s.coreTopology.s.pool") != null) {
        db.s.topology.s.coreTopology.s.pool.on("attemptReconnect", function() {
          conn.emit("attemptReconnect");
        });
      }
      if (!options.useUnifiedTopology) {
        client.on("close", function() {
          conn.readyState = STATES.disconnected;
        });
      } else if (!type.startsWith("ReplicaSet")) {
        client.on("close", function() {
          conn.readyState = STATES.disconnected;
        });
      }
      if (!options.useUnifiedTopology) {
        client.on("left", function() {
          if (conn.readyState === STATES.connected && get(db, "s.topology.s.coreTopology.s.replicaSetState.topologyType") === "ReplicaSetNoPrimary") {
            conn.readyState = STATES.disconnected;
          }
        });
        client.on("timeout", function() {
          conn.emit("timeout");
        });
      }
      delete conn.then;
      delete conn.catch;
      conn.onOpen();
    }
    var handleUseMongoClient = function handleUseMongoClient2(options) {
      console.warn("WARNING: The `useMongoClient` option is no longer necessary in mongoose 5.x, please remove it.");
      const stack = new Error().stack;
      console.warn(stack.substr(stack.indexOf("\n") + 1));
      delete options.useMongoClient;
    };
    Connection4.prototype.close = function(force, callback) {
      if (typeof force === "function") {
        callback = force;
        force = false;
      }
      this.$wasForceClosed = !!force;
      return promiseOrCallback(callback, (cb) => {
        this._close(force, cb);
      });
    };
    Connection4.prototype._close = function(force, callback) {
      const _this = this;
      const closeCalled = this._closeCalled;
      this._closeCalled = true;
      if (this.client != null) {
        this.client._closeCalled = true;
      }
      switch (this.readyState) {
        case STATES.disconnected:
          if (closeCalled) {
            callback();
          } else {
            this.doClose(force, function(err) {
              if (err) {
                return callback(err);
              }
              _this.onClose(force);
              callback(null);
            });
          }
          break;
        case STATES.connected:
          this.readyState = STATES.disconnecting;
          this.doClose(force, function(err) {
            if (err) {
              return callback(err);
            }
            _this.onClose(force);
            callback(null);
          });
          break;
        case STATES.connecting:
          this.once("open", function() {
            _this.close(callback);
          });
          break;
        case STATES.disconnecting:
          this.once("close", function() {
            callback();
          });
          break;
      }
      return this;
    };
    Connection4.prototype.onClose = function(force) {
      this.readyState = STATES.disconnected;
      for (const i in this.collections) {
        if (utils.object.hasOwnProperty(this.collections, i)) {
          this.collections[i].onClose(force);
        }
      }
      this.emit("close", force);
    };
    Connection4.prototype.collection = function(name, options) {
      const defaultOptions = {
        autoIndex: this.config.autoIndex != null ? this.config.autoIndex : this.base.options.autoIndex,
        autoCreate: this.config.autoCreate != null ? this.config.autoCreate : this.base.options.autoCreate
      };
      options = Object.assign({}, defaultOptions, options ? utils.clone(options) : {});
      options.$wasForceClosed = this.$wasForceClosed;
      if (!(name in this.collections)) {
        this.collections[name] = new Collection(name, this, options);
      }
      return this.collections[name];
    };
    Connection4.prototype.plugin = function(fn, opts) {
      this.plugins.push([fn, opts]);
      return this;
    };
    Connection4.prototype.model = function(name, schema, collection, options) {
      if (!(this instanceof Connection4)) {
        throw new MongooseError("`connection.model()` should not be run with `new`. If you are doing `new db.model(foo)(bar)`, use `db.model(foo)(bar)` instead");
      }
      let fn;
      if (typeof name === "function") {
        fn = name;
        name = fn.name;
      }
      if (typeof schema === "string") {
        collection = schema;
        schema = false;
      }
      if (utils.isObject(schema) && !schema.instanceOfSchema) {
        schema = new Schema6(schema);
      }
      if (schema && !schema.instanceOfSchema) {
        throw new Error("The 2nd parameter to `mongoose.model()` should be a schema or a POJO");
      }
      const defaultOptions = { cache: false, overwriteModels: this.base.options.overwriteModels };
      const opts = Object.assign(defaultOptions, options, { connection: this });
      if (this.models[name] && !collection && opts.overwriteModels !== true) {
        if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {
          throw new MongooseError.OverwriteModelError(name);
        }
        return this.models[name];
      }
      let model;
      if (schema && schema.instanceOfSchema) {
        applyPlugins(schema, this.plugins, null, "$connectionPluginsApplied");
        model = this.base.model(fn || name, schema, collection, opts);
        if (!this.models[name]) {
          this.models[name] = model;
        }
        model.init(function $modelInitNoop() {
        });
        return model;
      }
      if (this.models[name] && collection) {
        model = this.models[name];
        schema = model.prototype.schema;
        const sub = model.__subclass(this, schema, collection);
        return sub;
      }
      model = this.base.models[name];
      if (!model) {
        throw new MongooseError.MissingSchemaError(name);
      }
      if (this === model.prototype.db && (!collection || collection === model.collection.name)) {
        if (!this.models[name]) {
          this.models[name] = model;
        }
        return model;
      }
      this.models[name] = model.__subclass(this, schema, collection);
      return this.models[name];
    };
    Connection4.prototype.deleteModel = function(name) {
      if (typeof name === "string") {
        const model = this.model(name);
        if (model == null) {
          return this;
        }
        const collectionName = model.collection.name;
        delete this.models[name];
        delete this.collections[collectionName];
        delete this.base.modelSchemas[name];
        this.emit("deleteModel", model);
      } else if (name instanceof RegExp) {
        const pattern = name;
        const names = this.modelNames();
        for (const name2 of names) {
          if (pattern.test(name2)) {
            this.deleteModel(name2);
          }
        }
      } else {
        throw new Error('First parameter to `deleteModel()` must be a string or regexp, got "' + name + '"');
      }
      return this;
    };
    Connection4.prototype.watch = function(pipeline, options) {
      const disconnectedError = new MongooseError("Connection " + this.id + " was disconnected when calling `watch()`");
      const changeStreamThunk = (cb) => {
        immediate(() => {
          if (this.readyState === STATES.connecting) {
            this.once("open", function() {
              const driverChangeStream = this.db.watch(pipeline, options);
              cb(null, driverChangeStream);
            });
          } else if (this.readyState === STATES.disconnected && this.db == null) {
            cb(disconnectedError);
          } else {
            const driverChangeStream = this.db.watch(pipeline, options);
            cb(null, driverChangeStream);
          }
        });
      };
      const changeStream = new ChangeStream(changeStreamThunk, pipeline, options);
      return changeStream;
    };
    Connection4.prototype.modelNames = function() {
      return Object.keys(this.models);
    };
    Connection4.prototype.shouldAuthenticate = function() {
      return this.user != null && (this.pass != null || this.authMechanismDoesNotRequirePassword());
    };
    Connection4.prototype.authMechanismDoesNotRequirePassword = function() {
      if (this.options && this.options.auth) {
        return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;
      }
      return true;
    };
    Connection4.prototype.optionsProvideAuthenticationData = function(options) {
      return options && options.user && (options.pass || this.authMechanismDoesNotRequirePassword());
    };
    Connection4.prototype.getClient = function getClient() {
      return this.client;
    };
    Connection4.prototype.setClient = function setClient(client) {
      if (!(client instanceof mongodb.MongoClient)) {
        throw new MongooseError("Must call `setClient()` with an instance of MongoClient");
      }
      if (this.client != null || this.readyState !== STATES.disconnected) {
        throw new MongooseError("Cannot call `setClient()` on a connection that is already connected.");
      }
      if (!client.isConnected()) {
        throw new MongooseError("Cannot call `setClient()` with a MongoClient that is not connected.");
      }
      this._connectionString = client.s.url;
      _setClient(this, client, { useUnifiedTopology: client.s.options.useUnifiedTopology }, client.s.options.dbName);
      return this;
    };
    Connection4.STATES = STATES;
    module2.exports = Connection4;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/timers.js
var require_timers2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/timers.js"(exports2) {
    "use strict";
    init_cjs_shims();
    exports2.setTimeout = setTimeout;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js
var require_connection2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseConnection = require_connection();
    var STATES = require_connectionstate();
    var immediate = require_immediate();
    var setTimeout2 = require_timers2().setTimeout;
    function NativeConnection() {
      MongooseConnection.apply(this, arguments);
      this._listening = false;
    }
    NativeConnection.STATES = STATES;
    NativeConnection.prototype.__proto__ = MongooseConnection.prototype;
    NativeConnection.prototype.useDb = function(name, options) {
      options = options || {};
      if (options.useCache && this.relatedDbs[name]) {
        return this.relatedDbs[name];
      }
      const newConn = new this.constructor();
      newConn.name = name;
      newConn.base = this.base;
      newConn.collections = {};
      newConn.models = {};
      newConn.replica = this.replica;
      newConn.config = Object.assign({}, this.config, newConn.config);
      newConn.name = this.name;
      newConn.options = this.options;
      newConn._readyState = this._readyState;
      newConn._closeCalled = this._closeCalled;
      newConn._hasOpened = this._hasOpened;
      newConn._listening = false;
      newConn.host = this.host;
      newConn.port = this.port;
      newConn.user = this.user;
      newConn.pass = this.pass;
      const _this = this;
      newConn.client = _this.client;
      if (this.db && this._readyState === STATES.connected) {
        wireup();
      } else {
        this.once("connected", wireup);
      }
      function wireup() {
        newConn.client = _this.client;
        const _opts = {};
        if (options.hasOwnProperty("noListener")) {
          _opts.noListener = options.noListener;
        }
        newConn.db = _this.client.db(name, _opts);
        newConn.onOpen();
        if (options.noListener !== true) {
          listen(newConn);
        }
      }
      newConn.name = name;
      if (options.noListener !== true) {
        this.otherDbs.push(newConn);
      }
      newConn.otherDbs.push(this);
      if (options && options.useCache) {
        this.relatedDbs[newConn.name] = newConn;
        newConn.relatedDbs = this.relatedDbs;
      }
      return newConn;
    };
    function listen(conn) {
      if (conn._listening) {
        return;
      }
      conn._listening = true;
      conn.client.on("close", function(force) {
        if (conn._closeCalled) {
          return;
        }
        conn._closeCalled = conn.client._closeCalled;
        if (conn.db.serverConfig.autoReconnect) {
          conn.readyState = STATES.disconnected;
          conn.emit("close");
          return;
        }
        conn.onClose(force);
      });
      conn.client.on("error", function(err) {
        conn.emit("error", err);
      });
      if (!conn.client.s.options.useUnifiedTopology) {
        conn.db.on("reconnect", function() {
          conn.readyState = STATES.connected;
          conn.emit("reconnect");
          conn.emit("reconnected");
          conn.onOpen();
        });
        conn.db.on("open", function(err, db) {
          if (STATES.disconnected === conn.readyState && db && db.databaseName) {
            conn.readyState = STATES.connected;
            conn.emit("reconnect");
            conn.emit("reconnected");
          }
        });
      }
      conn.client.on("timeout", function(err) {
        conn.emit("timeout", err);
      });
      conn.client.on("parseError", function(err) {
        conn.emit("parseError", err);
      });
    }
    NativeConnection.prototype.doClose = function(force, fn) {
      if (this.client == null) {
        immediate(() => fn());
        return this;
      }
      this.client.close(force, (err, res) => {
        setTimeout2(() => fn(err, res), 1);
      });
      return this;
    };
    module2.exports = NativeConnection;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js
var require_node_mongodb_native = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    exports2.Binary = require_binary();
    exports2.Collection = require_collection4();
    exports2.Decimal128 = require_decimal1284();
    exports2.ObjectId = require_objectid();
    exports2.ReadPreference = require_ReadPreference();
    exports2.getConnection = () => require_connection2();
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/validoptions.js
var require_validoptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/validoptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var VALID_OPTIONS = Object.freeze([
      "applyPluginsToChildSchemas",
      "applyPluginsToDiscriminators",
      "autoCreate",
      "autoIndex",
      "bufferCommands",
      "bufferTimeoutMS",
      "cloneSchemas",
      "debug",
      "maxTimeMS",
      "objectIdGetter",
      "overwriteModels",
      "returnOriginal",
      "runValidators",
      "sanitizeProjection",
      "selectPopulatedPaths",
      "setDefaultsOnInsert",
      "strict",
      "strictQuery",
      "toJSON",
      "toObject",
      "typePojoToMixed",
      "useCreateIndex",
      "useFindAndModify",
      "useNewUrlParser",
      "usePushEach",
      "useUnifiedTopology"
    ]);
    module2.exports = VALID_OPTIONS;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/cursor/eachAsync.js
var require_eachAsync = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/cursor/eachAsync.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var immediate = require_immediate();
    var promiseOrCallback = require_promiseOrCallback();
    module2.exports = function eachAsync(next, fn, options, callback) {
      const parallel = options.parallel || 1;
      const batchSize = options.batchSize;
      const enqueue = asyncQueue();
      return promiseOrCallback(callback, (cb) => {
        if (batchSize != null) {
          if (typeof batchSize !== "number") {
            throw new TypeError("batchSize must be a number");
          }
          if (batchSize < 1) {
            throw new TypeError("batchSize must be at least 1");
          }
          if (batchSize !== Math.floor(batchSize)) {
            throw new TypeError("batchSize must be a positive integer");
          }
        }
        iterate(cb);
      });
      function iterate(finalCallback) {
        let drained = false;
        let handleResultsInProgress = 0;
        let currentDocumentIndex = 0;
        let documentsBatch = [];
        let error = null;
        for (let i = 0; i < parallel; ++i) {
          enqueue(fetch);
        }
        function fetch(done) {
          if (drained || error) {
            return done();
          }
          next(function(err, doc) {
            if (drained || error != null) {
              return done();
            }
            if (err != null) {
              error = err;
              finalCallback(err);
              return done();
            }
            if (doc == null) {
              drained = true;
              if (handleResultsInProgress <= 0) {
                finalCallback(null);
              } else if (batchSize != null && documentsBatch.length) {
                handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);
              }
              return done();
            }
            ++handleResultsInProgress;
            immediate(() => done());
            if (batchSize != null) {
              documentsBatch.push(doc);
            }
            if (batchSize != null && documentsBatch.length !== batchSize) {
              setTimeout(() => enqueue(fetch), 0);
              return;
            }
            const docsToProcess = batchSize != null ? documentsBatch : doc;
            function handleNextResultCallBack(err2) {
              if (batchSize != null) {
                handleResultsInProgress -= documentsBatch.length;
                documentsBatch = [];
              } else {
                --handleResultsInProgress;
              }
              if (err2 != null) {
                error = err2;
                return finalCallback(err2);
              }
              if (drained && handleResultsInProgress <= 0) {
                return finalCallback(null);
              }
              setTimeout(() => enqueue(fetch), 0);
            }
            handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);
          });
        }
      }
      function handleNextResult(doc, i, callback2) {
        const promise = fn(doc, i);
        if (promise && typeof promise.then === "function") {
          promise.then(
            function() {
              callback2(null);
            },
            function(error) {
              callback2(error || new Error("`eachAsync()` promise rejected without error"));
            }
          );
        } else {
          callback2(null);
        }
      }
    };
    function asyncQueue() {
      const _queue = [];
      let inProgress = null;
      let id = 0;
      return function enqueue(fn) {
        if (_queue.length === 0 && inProgress == null) {
          inProgress = id++;
          return fn(_step);
        }
        _queue.push(fn);
      };
      function _step() {
        inProgress = null;
        if (_queue.length > 0) {
          inProgress = id++;
          const fn = _queue.shift();
          fn(_step);
        }
      }
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cursor/QueryCursor.js
var require_QueryCursor = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cursor/QueryCursor.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Readable = require("stream").Readable;
    var promiseOrCallback = require_promiseOrCallback();
    var eachAsync = require_eachAsync();
    var helpers = require_queryhelpers();
    var immediate = require_immediate();
    var util2 = require("util");
    var utils = require_utils2();
    function QueryCursor(query, options) {
      const streamOpts = { objectMode: true };
      if (utils.nodeMajorVersion() >= 12) {
        streamOpts.autoDestroy = true;
      }
      Readable.call(this, streamOpts);
      this.cursor = null;
      this.query = query;
      const _this = this;
      const model = query.model;
      this._mongooseOptions = {};
      this._transforms = [];
      this.model = model;
      this.options = options || {};
      model.hooks.execPre("find", query, () => {
        this._transforms = this._transforms.concat(query._transforms.slice());
        if (this.options.transform) {
          this._transforms.push(options.transform);
        }
        if (this.options.batchSize) {
          this.options.cursor = options.cursor || {};
          this.options.cursor.batchSize = options.batchSize;
          this.options._populateBatchSize = Math.min(this.options.batchSize, 5e3);
        }
        model.collection.find(query._conditions, this.options, function(err, cursor) {
          if (_this._error) {
            if (cursor != null) {
              cursor.close(function() {
              });
            }
            _this.emit("cursor", null);
            _this.listeners("error").length > 0 && _this.emit("error", _this._error);
            return;
          }
          if (err) {
            return _this.emit("error", err);
          }
          _this.cursor = cursor;
          _this.emit("cursor", cursor);
        });
      });
    }
    util2.inherits(QueryCursor, Readable);
    QueryCursor.prototype._read = function() {
      const _this = this;
      _next(this, function(error, doc) {
        if (error) {
          return _this.emit("error", error);
        }
        if (!doc) {
          _this.push(null);
          _this.cursor.close(function(error2) {
            if (error2) {
              return _this.emit("error", error2);
            }
            if (utils.nodeMajorVersion() < 12) {
              _this.on("end", () => _this.emit("close"));
            }
          });
          return;
        }
        _this.push(doc);
      });
    };
    QueryCursor.prototype.map = function(fn) {
      this._transforms.push(fn);
      return this;
    };
    QueryCursor.prototype._markError = function(error) {
      this._error = error;
      return this;
    };
    QueryCursor.prototype.close = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        this.cursor.close((error) => {
          if (error) {
            cb(error);
            return this.listeners("error").length > 0 && this.emit("error", error);
          }
          this.emit("close");
          cb(null);
        });
      }, this.model.events);
    };
    QueryCursor.prototype.next = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        _next(this, function(error, doc) {
          if (error) {
            return cb(error);
          }
          cb(null, doc);
        });
      }, this.model.events);
    };
    QueryCursor.prototype.eachAsync = function(fn, opts, callback) {
      const _this = this;
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      opts = opts || {};
      return eachAsync(function(cb) {
        return _next(_this, cb);
      }, fn, opts, callback);
    };
    QueryCursor.prototype.options;
    QueryCursor.prototype.addCursorFlag = function(flag, value) {
      const _this = this;
      _waitForCursor(this, function() {
        _this.cursor.addCursorFlag(flag, value);
      });
      return this;
    };
    QueryCursor.prototype.transformNull = function(val) {
      if (arguments.length === 0) {
        val = true;
      }
      this._mongooseOptions.transformNull = val;
      return this;
    };
    QueryCursor.prototype._transformForAsyncIterator = function() {
      if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
        this.map(_transformForAsyncIterator);
      }
      return this;
    };
    if (Symbol.asyncIterator != null) {
      QueryCursor.prototype[Symbol.asyncIterator] = function() {
        return this.transformNull()._transformForAsyncIterator();
      };
    }
    function _transformForAsyncIterator(doc) {
      return doc == null ? { done: true } : { value: doc, done: false };
    }
    function _next(ctx, cb) {
      let callback = cb;
      if (ctx._transforms.length) {
        callback = function(err, doc) {
          if (err || doc === null && !ctx._mongooseOptions.transformNull) {
            return cb(err, doc);
          }
          cb(err, ctx._transforms.reduce(function(doc2, fn) {
            return fn.call(ctx, doc2);
          }, doc));
        };
      }
      if (ctx._error) {
        return immediate(function() {
          callback(ctx._error);
        });
      }
      if (ctx.cursor) {
        if (ctx.query._mongooseOptions.populate && !ctx._pop) {
          ctx._pop = helpers.preparePopulationOptionsMQ(
            ctx.query,
            ctx.query._mongooseOptions
          );
          ctx._pop.__noPromise = true;
        }
        if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {
          if (ctx._batchDocs && ctx._batchDocs.length) {
            return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);
          } else if (ctx._batchExhausted) {
            return callback(null, null);
          } else {
            ctx._batchDocs = [];
            return ctx.cursor.next(_onNext.bind({ ctx, callback }));
          }
        } else {
          return ctx.cursor.next(function(error, doc) {
            if (error) {
              return callback(error);
            }
            if (!doc) {
              return callback(null, null);
            }
            if (!ctx.query._mongooseOptions.populate) {
              return _nextDoc(ctx, doc, null, callback);
            }
            ctx.query.model.populate(doc, ctx._pop, function(err, doc2) {
              if (err) {
                return callback(err);
              }
              return _nextDoc(ctx, doc2, ctx._pop, callback);
            });
          });
        }
      } else {
        ctx.once("cursor", function(cursor) {
          if (cursor == null) {
            return;
          }
          _next(ctx, cb);
        });
      }
    }
    function _onNext(error, doc) {
      if (error) {
        return this.callback(error);
      }
      if (!doc) {
        this.ctx._batchExhausted = true;
        return _populateBatch.call(this);
      }
      this.ctx._batchDocs.push(doc);
      if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {
        if (this.ctx._batchDocs.length > 0 && this.ctx._batchDocs.length % 1e3 === 0) {
          return immediate(() => this.ctx.cursor.next(_onNext.bind(this)));
        }
        this.ctx.cursor.next(_onNext.bind(this));
      } else {
        _populateBatch.call(this);
      }
    }
    function _populateBatch() {
      if (!this.ctx._batchDocs.length) {
        return this.callback(null, null);
      }
      const _this = this;
      this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop, function(err) {
        if (err) {
          return _this.callback(err);
        }
        _nextDoc(_this.ctx, _this.ctx._batchDocs.shift(), _this.ctx._pop, _this.callback);
      });
    }
    function _nextDoc(ctx, doc, pop, callback) {
      if (ctx.query._mongooseOptions.lean) {
        return ctx.model.hooks.execPost("find", ctx.query, [[doc]], (err) => {
          if (err != null) {
            return callback(err);
          }
          callback(null, doc);
        });
      }
      _create(ctx, doc, pop, (err, doc2) => {
        if (err != null) {
          return callback(err);
        }
        ctx.model.hooks.execPost("find", ctx.query, [[doc2]], (err2) => {
          if (err2 != null) {
            return callback(err2);
          }
          callback(null, doc2);
        });
      });
    }
    function _waitForCursor(ctx, cb) {
      if (ctx.cursor) {
        return cb();
      }
      ctx.once("cursor", function(cursor) {
        if (cursor == null) {
          return;
        }
        cb();
      });
    }
    function _create(ctx, doc, populatedIds, cb) {
      const instance = helpers.createModel(ctx.query.model, doc, ctx.query._fields);
      const opts = populatedIds ? { populated: populatedIds } : void 0;
      instance.init(doc, opts, function(err) {
        if (err) {
          return cb(err);
        }
        cb(null, instance);
      });
    }
    module2.exports = QueryCursor;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/applyGlobalMaxTimeMS.js
var require_applyGlobalMaxTimeMS = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/applyGlobalMaxTimeMS.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var utils = require_utils2();
    module2.exports = function applyGlobalMaxTimeMS(options, model) {
      if (utils.hasUserDefinedProperty(options, "maxTimeMS")) {
        return;
      }
      if (utils.hasUserDefinedProperty(model.db.options, "maxTimeMS")) {
        options.maxTimeMS = model.db.options.maxTimeMS;
      } else if (utils.hasUserDefinedProperty(model.base.options, "maxTimeMS")) {
        options.maxTimeMS = model.base.options.maxTimeMS;
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js
var require_applyWriteConcern = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var get = require_get();
    module2.exports = function applyWriteConcern(schema, options) {
      const writeConcern = get(schema, "options.writeConcern", {});
      if (Object.keys(writeConcern).length != 0) {
        options.writeConcern = {};
        if (!("w" in options) && writeConcern.w != null) {
          options.writeConcern.w = writeConcern.w;
        }
        if (!("j" in options) && writeConcern.j != null) {
          options.writeConcern.j = writeConcern.j;
        }
        if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
          options.writeConcern.wtimeout = writeConcern.wtimeout;
        }
      } else {
        if (!("w" in options) && writeConcern.w != null) {
          options.w = writeConcern.w;
        }
        if (!("j" in options) && writeConcern.j != null) {
          options.j = writeConcern.j;
        }
        if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
          options.wtimeout = writeConcern.wtimeout;
        }
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/castFilterPath.js
var require_castFilterPath = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/castFilterPath.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var isOperator = require_isOperator();
    module2.exports = function castFilterPath(query, schematype, val) {
      const ctx = query;
      const any$conditionals = Object.keys(val).some(isOperator);
      if (!any$conditionals) {
        return schematype.castForQueryWrapper({
          val,
          context: ctx
        });
      }
      const ks = Object.keys(val);
      let k = ks.length;
      while (k--) {
        const $cond = ks[k];
        const nested = val[$cond];
        if ($cond === "$not") {
          if (nested && schematype && !schematype.caster) {
            const _keys = Object.keys(nested);
            if (_keys.length && isOperator(_keys[0])) {
              for (const key of Object.keys(nested)) {
                nested[key] = schematype.castForQueryWrapper({
                  $conditional: key,
                  val: nested[key],
                  context: ctx
                });
              }
            } else {
              val[$cond] = schematype.castForQueryWrapper({
                $conditional: $cond,
                val: nested,
                context: ctx
              });
            }
            continue;
          }
        } else {
          val[$cond] = schematype.castForQueryWrapper({
            $conditional: $cond,
            val: nested,
            context: ctx
          });
        }
      }
      return val;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/getPath.js
var require_getPath = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/schema/getPath.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function getPath(schema, path3) {
      let schematype = schema.path(path3);
      if (schematype != null) {
        return schematype;
      }
      const pieces = path3.split(".");
      let cur = "";
      let isArray2 = false;
      for (const piece of pieces) {
        if (/^\d+$/.test(piece) && isArray2) {
          continue;
        }
        cur = cur.length === 0 ? piece : cur + "." + piece;
        schematype = schema.path(cur);
        if (schematype != null && schematype.schema) {
          schema = schematype.schema;
          cur = "";
          if (schematype.$isMongooseDocumentArray) {
            isArray2 = true;
          }
        }
      }
      return schematype;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/modifiedPaths.js
var require_modifiedPaths = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/modifiedPaths.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var _modifiedPaths = require_common().modifiedPaths;
    module2.exports = function modifiedPaths(update) {
      const keys = Object.keys(update);
      const res = {};
      const withoutDollarKeys = {};
      for (const key of keys) {
        if (key.startsWith("$")) {
          _modifiedPaths(update[key], "", res);
          continue;
        }
        withoutDollarKeys[key] = update[key];
      }
      _modifiedPaths(withoutDollarKeys, "", res);
      return res;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js
var require_updatedPathsByArrayFilter = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var modifiedPaths = require_modifiedPaths();
    module2.exports = function updatedPathsByArrayFilter(update) {
      const updatedPaths = modifiedPaths(update);
      return Object.keys(updatedPaths).reduce((cur, path3) => {
        const matches = path3.match(/\$\[[^\]]+\]/g);
        if (matches == null) {
          return cur;
        }
        for (const match of matches) {
          const firstMatch = path3.indexOf(match);
          if (firstMatch !== path3.lastIndexOf(match)) {
            throw new Error(`Path '${path3}' contains the same array filter multiple times`);
          }
          cur[match.substring(2, match.length - 1)] = path3.substr(0, firstMatch - 1).replace(/\$\[[^\]]+\]/g, "0");
        }
        return cur;
      }, {});
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/castArrayFilters.js
var require_castArrayFilters = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/castArrayFilters.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var castFilterPath = require_castFilterPath();
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var getPath = require_getPath();
    var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
    module2.exports = function castArrayFilters(query) {
      const arrayFilters = query.options.arrayFilters;
      if (!Array.isArray(arrayFilters)) {
        return;
      }
      const update = query.getUpdate();
      const schema = query.schema;
      const strictQuery = schema.options.strictQuery;
      const updatedPathsByFilter = updatedPathsByArrayFilter(update);
      for (const filter of arrayFilters) {
        if (filter == null) {
          throw new Error(`Got null array filter in ${arrayFilters}`);
        }
        for (const key of Object.keys(filter)) {
          if (filter[key] == null) {
            continue;
          }
          const dot = key.indexOf(".");
          let filterPath = dot === -1 ? updatedPathsByFilter[key] + ".0" : updatedPathsByFilter[key.substr(0, dot)] + ".0" + key.substr(dot);
          if (filterPath == null) {
            throw new Error(`Filter path not found for ${key}`);
          }
          filterPath = cleanPositionalOperators(filterPath);
          const schematype = getPath(schema, filterPath);
          if (schematype == null) {
            if (!strictQuery) {
              return;
            }
            throw new Error(`Could not find path "${filterPath}" in schema`);
          }
          if (typeof filter[key] === "object") {
            filter[key] = castFilterPath(query, schematype, filter[key]);
          } else {
            filter[key] = schematype.castForQuery(filter[key]);
          }
        }
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var get = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
    module2.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path3, options) {
      const parts = path3.split(".");
      let schematype = null;
      let type = "adhocOrUndefined";
      filter = filter || {};
      update = update || {};
      const arrayFilters = options != null && Array.isArray(options.arrayFilters) ? options.arrayFilters : [];
      const updatedPathsByFilter = updatedPathsByArrayFilter(update);
      for (let i = 0; i < parts.length; ++i) {
        const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join("."));
        schematype = schema.path(subpath);
        if (schematype == null) {
          continue;
        }
        type = schema.pathType(subpath);
        if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) && schematype.schema.discriminators != null) {
          const key = get(schematype, "schema.options.discriminatorKey");
          const discriminatorValuePath = subpath + "." + key;
          const discriminatorFilterPath = discriminatorValuePath.replace(/\.\d+\./, ".");
          let discriminatorKey = null;
          if (discriminatorValuePath in filter) {
            discriminatorKey = filter[discriminatorValuePath];
          }
          if (discriminatorFilterPath in filter) {
            discriminatorKey = filter[discriminatorFilterPath];
          }
          const wrapperPath = subpath.replace(/\.\d+$/, "");
          if (schematype.$isMongooseDocumentArrayElement && get(filter[wrapperPath], "$elemMatch." + key) != null) {
            discriminatorKey = filter[wrapperPath].$elemMatch[key];
          }
          if (discriminatorValuePath in update) {
            discriminatorKey = update[discriminatorValuePath];
          }
          for (const filterKey of Object.keys(updatedPathsByFilter)) {
            const schemaKey = updatedPathsByFilter[filterKey] + "." + key;
            const arrayFilterKey = filterKey + "." + key;
            if (schemaKey === discriminatorFilterPath) {
              const filter2 = arrayFilters.find((filter3) => filter3.hasOwnProperty(arrayFilterKey));
              if (filter2 != null) {
                discriminatorKey = filter2[arrayFilterKey];
              }
            }
          }
          if (discriminatorKey == null) {
            continue;
          }
          const discriminatorSchema = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey).schema;
          const rest = parts.slice(i + 1).join(".");
          schematype = discriminatorSchema.path(rest);
          if (schematype != null) {
            type = discriminatorSchema._getPathType(rest);
            break;
          }
        }
      }
      return { type, schematype };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/handleImmutable.js
var require_handleImmutable2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/handleImmutable.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var StrictModeError = require_strict();
    module2.exports = function handleImmutable(schematype, strict, obj2, key, fullPath, ctx) {
      if (schematype == null || !schematype.options || !schematype.options.immutable) {
        return false;
      }
      let immutable = schematype.options.immutable;
      if (typeof immutable === "function") {
        immutable = immutable.call(ctx, ctx);
      }
      if (!immutable) {
        return false;
      }
      if (strict === false) {
        return false;
      }
      if (strict === "throw") {
        throw new StrictModeError(
          null,
          `Field ${fullPath} is immutable and strict = 'throw'`
        );
      }
      delete obj2[key];
      return true;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js
var require_moveImmutableProperties = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var get = require_get();
    module2.exports = function moveImmutableProperties(schema, update, ctx) {
      if (update == null) {
        return;
      }
      const keys = Object.keys(update);
      for (const key of keys) {
        const isDollarKey = key.startsWith("$");
        if (key === "$set") {
          const updatedPaths = Object.keys(update[key]);
          for (const path3 of updatedPaths) {
            _walkUpdatePath(schema, update[key], path3, update, ctx);
          }
        } else if (!isDollarKey) {
          _walkUpdatePath(schema, update, key, update, ctx);
        }
      }
    };
    function _walkUpdatePath(schema, op, path3, update, ctx) {
      const schematype = schema.path(path3);
      if (schematype == null) {
        return;
      }
      let immutable = get(schematype, "options.immutable", null);
      if (immutable == null) {
        return;
      }
      if (typeof immutable === "function") {
        immutable = immutable.call(ctx, ctx);
      }
      if (!immutable) {
        return;
      }
      update.$setOnInsert = update.$setOnInsert || {};
      update.$setOnInsert[path3] = op[path3];
      delete op[path3];
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/path/setDottedPath.js
var require_setDottedPath = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/path/setDottedPath.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function setDottedPath(obj2, path3, val) {
      const parts = path3.split(".");
      let cur = obj2;
      for (const part of parts.slice(0, -1)) {
        if (cur[part] == null) {
          cur[part] = {};
        }
        cur = cur[part];
      }
      const last = parts[parts.length - 1];
      cur[last] = val;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/castUpdate.js
var require_castUpdate = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/castUpdate.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var CastError = require_cast();
    var MongooseError = require_mongooseError();
    var StrictModeError = require_strict();
    var ValidationError = require_validation();
    var castNumber = require_number();
    var cast = require_cast2();
    var getConstructorName = require_getConstructorName();
    var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath2();
    var handleImmutable = require_handleImmutable2();
    var moveImmutableProperties = require_moveImmutableProperties();
    var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
    var setDottedPath = require_setDottedPath();
    var utils = require_utils2();
    module2.exports = function castUpdate(schema, obj2, options, context, filter) {
      if (obj2 == null) {
        return void 0;
      }
      options = options || {};
      if (Array.isArray(obj2)) {
        const len = obj2.length;
        for (let i2 = 0; i2 < len; ++i2) {
          const ops2 = Object.keys(obj2[i2]);
          for (const op of ops2) {
            obj2[i2][op] = castPipelineOperator(op, obj2[i2][op]);
          }
        }
        return obj2;
      }
      if (options.upsert) {
        moveImmutableProperties(schema, obj2, context);
      }
      const ops = Object.keys(obj2);
      let i = ops.length;
      const ret2 = {};
      let val;
      let hasDollarKey = false;
      const overwrite = options.overwrite;
      filter = filter || {};
      while (i--) {
        const op = ops[i];
        if (op[0] !== "$" && !overwrite) {
          if (!ret2.$set) {
            if (obj2.$set) {
              ret2.$set = obj2.$set;
            } else {
              ret2.$set = {};
            }
          }
          ret2.$set[op] = obj2[op];
          ops.splice(i, 1);
          if (!~ops.indexOf("$set"))
            ops.push("$set");
        } else if (op === "$set") {
          if (!ret2.$set) {
            ret2[op] = obj2[op];
          }
        } else {
          ret2[op] = obj2[op];
        }
      }
      i = ops.length;
      while (i--) {
        const op = ops[i];
        val = ret2[op];
        hasDollarKey = hasDollarKey || op.startsWith("$");
        if (val && typeof val === "object" && !Buffer.isBuffer(val) && (!overwrite || hasDollarKey)) {
          walkUpdatePath(schema, val, op, options, context, filter);
        } else if (overwrite && ret2 && typeof ret2 === "object") {
          walkUpdatePath(schema, ret2, "$set", options, context, filter);
        } else {
          const msg = "Invalid atomic update value for " + op + ". Expected an object, received " + typeof val;
          throw new Error(msg);
        }
        if (op.startsWith("$") && utils.isEmptyObject(val)) {
          delete ret2[op];
        }
      }
      if (Object.keys(ret2).length === 0 && options.upsert && Object.keys(filter).length > 0) {
        return { $setOnInsert: filter };
      }
      return ret2;
    };
    function castPipelineOperator(op, val) {
      if (op === "$unset") {
        if (!Array.isArray(val) || val.find((v) => typeof v !== "string")) {
          throw new MongooseError("Invalid $unset in pipeline, must be an array of strings");
        }
        return val;
      }
      if (op === "$project") {
        if (val == null || typeof val !== "object") {
          throw new MongooseError("Invalid $project in pipeline, must be an object");
        }
        return val;
      }
      if (op === "$addFields" || op === "$set") {
        if (val == null || typeof val !== "object") {
          throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
        }
        return val;
      } else if (op === "$replaceRoot" || op === "$replaceWith") {
        if (val == null || typeof val !== "object") {
          throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
        }
        return val;
      }
      throw new MongooseError('Invalid update pipeline operator: "' + op + '"');
    }
    function walkUpdatePath(schema, obj2, op, options, context, filter, pref) {
      const strict = options.strict;
      const prefix = pref ? pref + "." : "";
      const keys = Object.keys(obj2);
      let i = keys.length;
      let hasKeys = false;
      let schematype;
      let key;
      let val;
      let aggregatedError = null;
      let useNestedStrict;
      if (options.useNestedStrict === void 0) {
        useNestedStrict = schema.options.useNestedStrict;
      } else {
        useNestedStrict = options.useNestedStrict;
      }
      while (i--) {
        key = keys[i];
        val = obj2[key];
        if (op === "$pull") {
          schematype = schema._getSchema(prefix + key);
          if (schematype != null && schematype.schema != null) {
            obj2[key] = cast(schematype.schema, obj2[key], options, context);
            hasKeys = true;
            continue;
          }
        }
        if (getConstructorName(val) === "Object") {
          schematype = schema._getSchema(prefix + key);
          if (schematype == null) {
            const _res = getEmbeddedDiscriminatorPath(schema, obj2, filter, prefix + key, options);
            if (_res.schematype != null) {
              schematype = _res.schematype;
            }
          }
          if (op !== "$setOnInsert" && handleImmutable(schematype, strict, obj2, key, prefix + key, context)) {
            continue;
          }
          if (schematype && schematype.caster && op in castOps) {
            if ("$each" in val) {
              hasKeys = true;
              try {
                obj2[key] = {
                  $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)
                };
              } catch (error) {
                aggregatedError = _handleCastError(error, context, key, aggregatedError);
              }
              if (val.$slice != null) {
                obj2[key].$slice = val.$slice | 0;
              }
              if (val.$sort) {
                obj2[key].$sort = val.$sort;
              }
              if (val.$position != null) {
                obj2[key].$position = castNumber(val.$position);
              }
            } else {
              if (schematype != null && schematype.$isSingleNested) {
                let _strict = strict;
                if (useNestedStrict !== false && schematype.schema.options.hasOwnProperty("strict")) {
                  _strict = schematype.schema.options.strict;
                } else if (useNestedStrict === false) {
                  _strict = schema.options.strict;
                }
                try {
                  obj2[key] = schematype.castForQuery(val, context, { strict: _strict });
                } catch (error) {
                  aggregatedError = _handleCastError(error, context, key, aggregatedError);
                }
              } else {
                try {
                  obj2[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
                } catch (error) {
                  aggregatedError = _handleCastError(error, context, key, aggregatedError);
                }
              }
              if (options.omitUndefined && obj2[key] === void 0) {
                delete obj2[key];
                continue;
              }
              hasKeys = true;
            }
          } else if (op === "$currentDate" || op in castOps && schematype) {
            try {
              obj2[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
            } catch (error) {
              aggregatedError = _handleCastError(error, context, key, aggregatedError);
            }
            if (options.omitUndefined && obj2[key] === void 0) {
              delete obj2[key];
              continue;
            }
            hasKeys = true;
          } else {
            const pathToCheck = prefix + key;
            const v = schema._getPathType(pathToCheck);
            let _strict = strict;
            if (useNestedStrict && v && v.schema && "strict" in v.schema.options) {
              _strict = v.schema.options.strict;
            }
            if (v.pathType === "undefined") {
              if (_strict === "throw") {
                throw new StrictModeError(pathToCheck);
              } else if (_strict) {
                delete obj2[key];
                continue;
              }
            }
            hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils.isObject(val) && Object.keys(val).length === 0;
          }
        } else {
          const checkPath = key === "$each" || key === "$or" || key === "$and" || key === "$in" ? pref : prefix + key;
          schematype = schema._getSchema(checkPath);
          if (op !== "$setOnInsert" && handleImmutable(schematype, strict, obj2, key, prefix + key, context)) {
            continue;
          }
          let pathDetails = schema._getPathType(checkPath);
          if (schematype == null) {
            const _res = getEmbeddedDiscriminatorPath(schema, obj2, filter, checkPath, options);
            if (_res.schematype != null) {
              schematype = _res.schematype;
              pathDetails = _res.type;
            }
          }
          let isStrict = strict;
          if (useNestedStrict && pathDetails && pathDetails.schema && "strict" in pathDetails.schema.options) {
            isStrict = pathDetails.schema.options.strict;
          }
          const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);
          if (skip) {
            if (isStrict === "throw" && schema.virtuals[checkPath] == null) {
              throw new StrictModeError(prefix + key);
            } else {
              delete obj2[key];
            }
          } else {
            if (op === "$rename") {
              hasKeys = true;
              continue;
            }
            try {
              if (prefix.length === 0 || key.indexOf(".") === -1) {
                obj2[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
              } else {
                setDottedPath(obj2, key, castUpdateVal(schematype, val, op, key, context, prefix + key));
                delete obj2[key];
              }
            } catch (error) {
              aggregatedError = _handleCastError(error, context, key, aggregatedError);
            }
            if (Array.isArray(obj2[key]) && (op === "$addToSet" || op === "$push") && key !== "$each") {
              if (schematype && schematype.caster && !schematype.caster.$isMongooseArray) {
                obj2[key] = { $each: obj2[key] };
              }
            }
            if (options.omitUndefined && obj2[key] === void 0) {
              delete obj2[key];
              continue;
            }
            hasKeys = true;
          }
        }
      }
      if (aggregatedError != null) {
        throw aggregatedError;
      }
      return hasKeys;
    }
    function _handleCastError(error, query, key, aggregatedError) {
      if (typeof query !== "object" || !query.options.multipleCastError) {
        throw error;
      }
      aggregatedError = aggregatedError || new ValidationError();
      aggregatedError.addError(key, error);
      return aggregatedError;
    }
    var numberOps = {
      $pop: 1,
      $inc: 1
    };
    var noCastOps = {
      $unset: 1
    };
    var castOps = {
      $push: 1,
      $addToSet: 1,
      $set: 1,
      $setOnInsert: 1
    };
    var overwriteOps = {
      $set: 1,
      $setOnInsert: 1
    };
    function castUpdateVal(schema, val, op, $conditional, context, path3) {
      if (!schema) {
        if (op in numberOps) {
          try {
            return castNumber(val);
          } catch (err) {
            throw new CastError("number", val, path3);
          }
        }
        return val;
      }
      const cond = schema.caster && op in castOps && (utils.isObject(val) || Array.isArray(val));
      if (cond && !overwriteOps[op]) {
        let schemaArrayDepth = 0;
        let cur = schema;
        while (cur.$isMongooseArray) {
          ++schemaArrayDepth;
          cur = cur.caster;
        }
        let arrayDepth = 0;
        let _val = val;
        while (Array.isArray(_val)) {
          ++arrayDepth;
          _val = _val[0];
        }
        const additionalNesting = schemaArrayDepth - arrayDepth;
        while (arrayDepth < schemaArrayDepth) {
          val = [val];
          ++arrayDepth;
        }
        let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);
        for (let i = 0; i < additionalNesting; ++i) {
          tmp = tmp[0];
        }
        return tmp;
      }
      if (op in noCastOps) {
        return val;
      }
      if (op in numberOps) {
        if (val == null) {
          throw new CastError("number", val, schema.path);
        }
        if (op === "$inc") {
          return schema.castForQueryWrapper({
            val,
            context
          });
        }
        try {
          return castNumber(val);
        } catch (error) {
          throw new CastError("number", val, schema.path);
        }
      }
      if (op === "$currentDate") {
        if (typeof val === "object") {
          return { $type: val.$type };
        }
        return Boolean(val);
      }
      if (/^\$/.test($conditional)) {
        return schema.castForQueryWrapper({
          $conditional,
          val,
          context
        });
      }
      if (overwriteOps[op]) {
        return schema.castForQueryWrapper({
          val,
          context,
          $skipQueryCastForUpdate: val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\d+$/),
          $applySetters: schema[schemaMixedSymbol] != null
        });
      }
      return schema.castForQueryWrapper({ val, context });
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/completeMany.js
var require_completeMany = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/completeMany.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var helpers = require_queryhelpers();
    var immediate = require_immediate();
    module2.exports = completeMany;
    function completeMany(model, docs, fields, userProvidedFields, opts, callback) {
      const arr = [];
      let count = docs.length;
      const len = count;
      let error = null;
      function init(_error) {
        if (_error != null) {
          error = error || _error;
        }
        if (error != null) {
          --count || immediate(() => callback(error));
          return;
        }
        --count || immediate(() => callback(error, arr));
      }
      for (let i = 0; i < len; ++i) {
        arr[i] = helpers.createModel(model, docs[i], fields, userProvidedFields);
        try {
          arr[i].init(docs[i], opts, init);
        } catch (error2) {
          init(error2);
        }
        if (opts.session != null) {
          arr[i].$session(opts.session);
        }
      }
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js
var require_hasDollarKeys = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(obj2) {
      if (obj2 == null) {
        return false;
      }
      const keys = Object.keys(obj2);
      const len = keys.length;
      for (let i = 0; i < len; ++i) {
        if (keys[i].startsWith("$")) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/projection/isInclusive.js
var require_isInclusive = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/projection/isInclusive.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var isDefiningProjection = require_isDefiningProjection();
    module2.exports = function isInclusive(projection) {
      if (projection == null) {
        return false;
      }
      const props = Object.keys(projection);
      const numProps = props.length;
      if (numProps === 0) {
        return false;
      }
      for (let i = 0; i < numProps; ++i) {
        const prop = props[i];
        if (prop.startsWith("+")) {
          continue;
        }
        if (isDefiningProjection(projection[prop]) && !!projection[prop]) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/projection/parseProjection.js
var require_parseProjection = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/projection/parseProjection.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function parseProjection(v, retainMinusPaths) {
      const type = typeof v;
      if (type === "string") {
        v = v.split(/\s+/);
      }
      if (!Array.isArray(v) && Object.prototype.toString.call(v) !== "[object Arguments]") {
        return v;
      }
      const len = v.length;
      const ret2 = {};
      for (let i = 0; i < len; ++i) {
        let field = v[i];
        if (!field) {
          continue;
        }
        const include = "-" == field[0] ? 0 : 1;
        if (!retainMinusPaths && include === 0) {
          field = field.substring(1);
        }
        ret2[field] = include;
      }
      return ret2;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js
var require_removeUnusedArrayFilters = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function removeUnusedArrayFilters(update, arrayFilters) {
      const updateKeys = Object.keys(update).map((key) => Object.keys(update[key])).reduce((cur, arr) => cur.concat(arr), []);
      return arrayFilters.filter((obj2) => {
        const firstKey = Object.keys(obj2)[0];
        const firstDot = firstKey.indexOf(".");
        const arrayFilterKey = firstDot === -1 ? firstKey : firstKey.slice(0, firstDot);
        return updateKeys.find((key) => key.includes("$[" + arrayFilterKey + "]")) != null;
      });
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js
var require_sanitizeProjection = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function sanitizeProjection(projection) {
      if (projection == null) {
        return;
      }
      const keys = Object.keys(projection);
      for (let i = 0; i < keys.length; ++i) {
        if (typeof projection[keys[i]] === "string") {
          projection[keys[i]] = 1;
        }
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js
var require_selectPopulatedFields = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var isExclusive = require_isExclusive();
    var isInclusive = require_isInclusive();
    module2.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {
      if (populateOptions == null) {
        return;
      }
      const paths = Object.keys(populateOptions);
      userProvidedFields = userProvidedFields || {};
      if (isInclusive(fields)) {
        for (const path3 of paths) {
          if (!isPathInFields(userProvidedFields, path3)) {
            fields[path3] = 1;
          } else if (userProvidedFields[path3] === 0) {
            delete fields[path3];
          }
        }
      } else if (isExclusive(fields)) {
        for (const path3 of paths) {
          if (userProvidedFields[path3] == null) {
            delete fields[path3];
          }
        }
      }
    };
    function isPathInFields(userProvidedFields, path3) {
      const pieces = path3.split(".");
      const len = pieces.length;
      let cur = pieces[0];
      for (let i = 1; i < len; ++i) {
        if (userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null) {
          return true;
        }
        cur += "." + pieces[i];
      }
      return userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js
var require_setDefaultsOnInsert = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var modifiedPaths = require_common().modifiedPaths;
    var get = require_get();
    module2.exports = function(filter, schema, castedDoc, options) {
      options = options || {};
      const shouldSetDefaultsOnInsert = options.setDefaultsOnInsert != null ? options.setDefaultsOnInsert : schema.base.options.setDefaultsOnInsert;
      if (!options.upsert || !shouldSetDefaultsOnInsert) {
        return castedDoc;
      }
      const keys = Object.keys(castedDoc || {});
      const updatedKeys = {};
      const updatedValues = {};
      const numKeys = keys.length;
      const modified = {};
      let hasDollarUpdate = false;
      for (let i = 0; i < numKeys; ++i) {
        if (keys[i].startsWith("$")) {
          modifiedPaths(castedDoc[keys[i]], "", modified);
          hasDollarUpdate = true;
        }
      }
      if (!hasDollarUpdate) {
        modifiedPaths(castedDoc, "", modified);
      }
      const paths = Object.keys(filter);
      const numPaths = paths.length;
      for (let i = 0; i < numPaths; ++i) {
        const path3 = paths[i];
        const condition = filter[path3];
        if (condition && typeof condition === "object") {
          const conditionKeys = Object.keys(condition);
          const numConditionKeys = conditionKeys.length;
          let hasDollarKey = false;
          for (let j = 0; j < numConditionKeys; ++j) {
            if (conditionKeys[j].startsWith("$")) {
              hasDollarKey = true;
              break;
            }
          }
          if (hasDollarKey) {
            continue;
          }
        }
        updatedKeys[path3] = true;
        modified[path3] = true;
      }
      if (options && options.overwrite && !hasDollarUpdate) {
        return castedDoc;
      }
      schema.eachPath(function(path3, schemaType) {
        const isUnderneathMap = schemaType.path.endsWith(".$*") || schemaType.path.indexOf(".$*.") !== -1;
        if (schemaType.$isSingleNested && !isUnderneathMap) {
          schemaType.schema.eachPath(function(_path, _schemaType) {
            if (_path === "_id" && _schemaType.auto) {
              return;
            }
            const def = _schemaType.getDefault(null, true);
            if (!isModified(modified, path3 + "." + _path) && typeof def !== "undefined") {
              castedDoc = castedDoc || {};
              castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
              castedDoc.$setOnInsert[path3 + "." + _path] = def;
              updatedValues[path3 + "." + _path] = def;
            }
          });
        } else {
          const def = schemaType.getDefault(null, true);
          if (!isModified(modified, path3) && typeof def !== "undefined") {
            castedDoc = castedDoc || {};
            castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
            if (get(castedDoc, path3) == null) {
              castedDoc.$setOnInsert[path3] = def;
            }
            updatedValues[path3] = def;
          }
        }
      });
      return castedDoc;
    };
    function isModified(modified, path3) {
      if (modified[path3]) {
        return true;
      }
      const sp = path3.split(".");
      let cur = sp[0];
      for (let i = 1; i < sp.length; ++i) {
        if (modified[cur]) {
          return true;
        }
        cur += "." + sp[i];
      }
      return false;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/updateValidators.js
var require_updateValidators = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/updateValidators.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var ValidationError = require_validation();
    var cleanPositionalOperators = require_cleanPositionalOperators();
    var flatten = require_common().flatten;
    var modifiedPaths = require_common().modifiedPaths;
    module2.exports = function(query, schema, castedDoc, options, callback) {
      let _keys;
      const keys = Object.keys(castedDoc || {});
      let updatedKeys = {};
      let updatedValues = {};
      const isPull = {};
      const arrayAtomicUpdates = {};
      const numKeys = keys.length;
      let hasDollarUpdate = false;
      const modified = {};
      let currentUpdate;
      let key;
      let i;
      for (i = 0; i < numKeys; ++i) {
        if (keys[i].startsWith("$")) {
          hasDollarUpdate = true;
          if (keys[i] === "$push" || keys[i] === "$addToSet") {
            _keys = Object.keys(castedDoc[keys[i]]);
            for (let ii = 0; ii < _keys.length; ++ii) {
              currentUpdate = castedDoc[keys[i]][_keys[ii]];
              if (currentUpdate && currentUpdate.$each) {
                arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat(currentUpdate.$each);
              } else {
                arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat([currentUpdate]);
              }
            }
            continue;
          }
          modifiedPaths(castedDoc[keys[i]], "", modified);
          const flat = flatten(castedDoc[keys[i]], null, null, schema);
          const paths = Object.keys(flat);
          const numPaths = paths.length;
          for (let j = 0; j < numPaths; ++j) {
            const updatedPath = cleanPositionalOperators(paths[j]);
            key = keys[i];
            if (updatedPath.includes("$")) {
              continue;
            }
            if (key === "$set" || key === "$setOnInsert" || key === "$pull" || key === "$pullAll") {
              updatedValues[updatedPath] = flat[paths[j]];
              isPull[updatedPath] = key === "$pull" || key === "$pullAll";
            } else if (key === "$unset") {
              updatedValues[updatedPath] = void 0;
            }
            updatedKeys[updatedPath] = true;
          }
        }
      }
      if (!hasDollarUpdate) {
        modifiedPaths(castedDoc, "", modified);
        updatedValues = flatten(castedDoc, null, null, schema);
        updatedKeys = Object.keys(updatedValues);
      }
      const updates = Object.keys(updatedValues);
      const numUpdates = updates.length;
      const validatorsToExecute = [];
      const validationErrors = [];
      const alreadyValidated = [];
      const context = options && options.context === "query" ? query : null;
      function iter(i2, v) {
        const schemaPath = schema._getSchema(updates[i2]);
        if (schemaPath == null) {
          return;
        }
        if (schemaPath.instance === "Mixed" && schemaPath.path !== updates[i2]) {
          return;
        }
        if (v && Array.isArray(v.$in)) {
          v.$in.forEach((v4, i3) => {
            validatorsToExecute.push(function(callback2) {
              schemaPath.doValidate(
                v4,
                function(err) {
                  if (err) {
                    err.path = updates[i3] + ".$in." + i3;
                    validationErrors.push(err);
                  }
                  callback2(null);
                },
                context,
                { updateValidator: true }
              );
            });
          });
        } else {
          if (isPull[updates[i2]] && schemaPath.$isMongooseArray) {
            return;
          }
          if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {
            alreadyValidated.push(updates[i2]);
            validatorsToExecute.push(function(callback2) {
              schemaPath.doValidate(v, function(err) {
                if (err) {
                  err.path = updates[i2];
                  validationErrors.push(err);
                  return callback2(null);
                }
                v.validate(function(err2) {
                  if (err2) {
                    if (err2.errors) {
                      for (const key2 of Object.keys(err2.errors)) {
                        const _err = err2.errors[key2];
                        _err.path = updates[i2] + "." + key2;
                        validationErrors.push(_err);
                      }
                    } else {
                      err2.path = updates[i2];
                      validationErrors.push(err2);
                    }
                  }
                  callback2(null);
                });
              }, context, { updateValidator: true });
            });
          } else {
            validatorsToExecute.push(function(callback2) {
              for (const path3 of alreadyValidated) {
                if (updates[i2].startsWith(path3 + ".")) {
                  return callback2(null);
                }
              }
              schemaPath.doValidate(v, function(err) {
                if (schemaPath.schema != null && schemaPath.schema.options.storeSubdocValidationError === false && err instanceof ValidationError) {
                  return callback2(null);
                }
                if (err) {
                  err.path = updates[i2];
                  validationErrors.push(err);
                }
                callback2(null);
              }, context, { updateValidator: true });
            });
          }
        }
      }
      for (i = 0; i < numUpdates; ++i) {
        iter(i, updatedValues[updates[i]]);
      }
      const arrayUpdates = Object.keys(arrayAtomicUpdates);
      for (const arrayUpdate of arrayUpdates) {
        let schemaPath = schema._getSchema(arrayUpdate);
        if (schemaPath && schemaPath.$isMongooseDocumentArray) {
          validatorsToExecute.push(function(callback2) {
            schemaPath.doValidate(
              arrayAtomicUpdates[arrayUpdate],
              getValidationCallback(arrayUpdate, validationErrors, callback2),
              options && options.context === "query" ? query : null
            );
          });
        } else {
          schemaPath = schema._getSchema(arrayUpdate + ".0");
          for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {
            validatorsToExecute.push(function(callback2) {
              schemaPath.doValidate(
                atomicUpdate,
                getValidationCallback(arrayUpdate, validationErrors, callback2),
                options && options.context === "query" ? query : null,
                { updateValidator: true }
              );
            });
          }
        }
      }
      if (callback != null) {
        let numValidators = validatorsToExecute.length;
        if (numValidators === 0) {
          return _done(callback);
        }
        for (const validator of validatorsToExecute) {
          validator(function() {
            if (--numValidators <= 0) {
              _done(callback);
            }
          });
        }
        return;
      }
      return function(callback2) {
        let numValidators = validatorsToExecute.length;
        if (numValidators === 0) {
          return _done(callback2);
        }
        for (const validator of validatorsToExecute) {
          validator(function() {
            if (--numValidators <= 0) {
              _done(callback2);
            }
          });
        }
      };
      function _done(callback2) {
        if (validationErrors.length) {
          const err = new ValidationError(null);
          for (const validationError of validationErrors) {
            err.addError(validationError.path, validationError);
          }
          return callback2(err);
        }
        callback2(null);
      }
      function getValidationCallback(arrayUpdate, validationErrors2, callback2) {
        return function(err) {
          if (err) {
            err.path = arrayUpdate;
            validationErrors2.push(err);
          }
          callback2(null);
        };
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/wrapThunk.js
var require_wrapThunk = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/query/wrapThunk.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function wrapThunk(fn) {
      return function _wrappedThunk(cb) {
        ++this._executionCount;
        fn.call(this, cb);
      };
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/query.js
var require_query = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/query.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var CastError = require_cast();
    var DocumentNotFoundError = require_notFound();
    var Kareem = require_kareem();
    var MongooseError = require_mongooseError();
    var ObjectParameterError = require_objectParameter();
    var QueryCursor = require_QueryCursor();
    var ReadPreference = require_driver().get().ReadPreference;
    var applyGlobalMaxTimeMS = require_applyGlobalMaxTimeMS();
    var applyWriteConcern = require_applyWriteConcern();
    var cast = require_cast2();
    var castArrayFilters = require_castArrayFilters();
    var castUpdate = require_castUpdate();
    var completeMany = require_completeMany();
    var get = require_get();
    var promiseOrCallback = require_promiseOrCallback();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var hasDollarKeys = require_hasDollarKeys();
    var helpers = require_queryhelpers();
    var immediate = require_immediate();
    var isExclusive = require_isExclusive();
    var isInclusive = require_isInclusive();
    var mquery = require_mquery();
    var parseProjection = require_parseProjection();
    var removeUnusedArrayFilters = require_removeUnusedArrayFilters();
    var sanitizeProjection = require_sanitizeProjection();
    var selectPopulatedFields = require_selectPopulatedFields();
    var setDefaultsOnInsert = require_setDefaultsOnInsert();
    var slice = require_sliced();
    var updateValidators = require_updateValidators();
    var util2 = require("util");
    var utils = require_utils2();
    var wrapThunk = require_wrapThunk();
    function Query(conditions, options, model, collection) {
      if (!this._mongooseOptions) {
        this._mongooseOptions = {};
      }
      options = options || {};
      this._transforms = [];
      this._hooks = new Kareem();
      this._executionCount = 0;
      const keys = Object.keys(options);
      for (const key of keys) {
        this._mongooseOptions[key] = options[key];
      }
      if (collection) {
        this.mongooseCollection = collection;
      }
      if (model) {
        this.model = model;
        this.schema = model.schema;
      }
      if (this.model && this.model._mapreduce) {
        this.lean();
      }
      mquery.call(this, this.mongooseCollection, options);
      if (conditions) {
        this.find(conditions);
      }
      this.options = this.options || {};
      this.$useProjection = true;
      const collation = get(this, "schema.options.collation", null);
      if (collation != null) {
        this.options.collation = collation;
      }
    }
    Query.prototype = new mquery();
    Query.prototype.constructor = Query;
    Query.base = mquery.prototype;
    Query.use$geoWithin = mquery.use$geoWithin;
    Query.prototype.toConstructor = function toConstructor() {
      const model = this.model;
      const coll = this.mongooseCollection;
      const CustomQuery = function(criteria, options2) {
        if (!(this instanceof CustomQuery)) {
          return new CustomQuery(criteria, options2);
        }
        this._mongooseOptions = utils.clone(p._mongooseOptions);
        Query.call(this, criteria, options2 || null, model, coll);
      };
      util2.inherits(CustomQuery, model.Query);
      const p = CustomQuery.prototype;
      p.options = {};
      const options = Object.assign({}, this.options);
      if (options.sort != null) {
        p.sort(options.sort);
        delete options.sort;
      }
      p.setOptions(options);
      p.op = this.op;
      p._conditions = utils.clone(this._conditions);
      p._fields = utils.clone(this._fields);
      p._update = utils.clone(this._update, {
        flattenDecimals: false
      });
      p._path = this._path;
      p._distinct = this._distinct;
      p._collection = this._collection;
      p._mongooseOptions = this._mongooseOptions;
      return CustomQuery;
    };
    Query.prototype.slice = function() {
      if (arguments.length === 0) {
        return this;
      }
      this._validate("slice");
      let path3;
      let val;
      if (arguments.length === 1) {
        const arg = arguments[0];
        if (typeof arg === "object" && !Array.isArray(arg)) {
          const keys = Object.keys(arg);
          const numKeys = keys.length;
          for (let i = 0; i < numKeys; ++i) {
            this.slice(keys[i], arg[keys[i]]);
          }
          return this;
        }
        this._ensurePath("slice");
        path3 = this._path;
        val = arguments[0];
      } else if (arguments.length === 2) {
        if ("number" === typeof arguments[0]) {
          this._ensurePath("slice");
          path3 = this._path;
          val = slice(arguments);
        } else {
          path3 = arguments[0];
          val = arguments[1];
        }
      } else if (arguments.length === 3) {
        path3 = arguments[0];
        val = slice(arguments, 1);
      }
      const p = {};
      p[path3] = { $slice: val };
      this.select(p);
      return this;
    };
    Query.prototype.mod = function() {
      let val;
      let path3;
      if (arguments.length === 1) {
        this._ensurePath("mod");
        val = arguments[0];
        path3 = this._path;
      } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {
        this._ensurePath("mod");
        val = slice(arguments);
        path3 = this._path;
      } else if (arguments.length === 3) {
        val = slice(arguments, 1);
        path3 = arguments[0];
      } else {
        val = arguments[1];
        path3 = arguments[0];
      }
      const conds = this._conditions[path3] || (this._conditions[path3] = {});
      conds.$mod = val;
      return this;
    };
    Query.prototype.projection = function(arg) {
      if (arguments.length === 0) {
        return this._fields;
      }
      this._fields = {};
      this._userProvidedFields = {};
      this.select(arg);
      return this._fields;
    };
    Query.prototype.select = function select() {
      let arg = arguments[0];
      if (!arg)
        return this;
      if (arguments.length !== 1) {
        throw new Error("Invalid select: select only takes 1 argument");
      }
      this._validate("select");
      const fields = this._fields || (this._fields = {});
      const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});
      let sanitizeProjection2 = void 0;
      if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, "sanitizeProjection")) {
        sanitizeProjection2 = this.model.db.options.sanitizeProjection;
      } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, "sanitizeProjection")) {
        sanitizeProjection2 = this.model.base.options.sanitizeProjection;
      } else {
        sanitizeProjection2 = this._mongooseOptions.sanitizeProjection;
      }
      arg = parseProjection(arg);
      if (utils.isObject(arg)) {
        const keys = Object.keys(arg);
        for (let i = 0; i < keys.length; ++i) {
          let value = arg[keys[i]];
          if (typeof value === "string" && sanitizeProjection2) {
            value = 1;
          }
          fields[keys[i]] = value;
          userProvidedFields[keys[i]] = value;
        }
        return this;
      }
      throw new TypeError("Invalid select() argument. Must be string or object.");
    };
    Query.prototype.read = function read(pref, tags) {
      const read2 = new ReadPreference(pref, tags);
      this.options.readPreference = read2;
      return this;
    };
    Query.prototype.session = function session(v) {
      if (v == null) {
        delete this.options.session;
      }
      this.options.session = v;
      return this;
    };
    Query.prototype.writeConcern = function writeConcern(val) {
      if (val == null) {
        delete this.options.writeConcern;
        return this;
      }
      this.options.writeConcern = val;
      return this;
    };
    Query.prototype.w = function w(val) {
      if (val == null) {
        delete this.options.w;
      }
      if (this.options.writeConcern != null) {
        this.options.writeConcern.w = val;
      } else {
        this.options.w = val;
      }
      return this;
    };
    Query.prototype.j = function j(val) {
      if (val == null) {
        delete this.options.j;
      }
      if (this.options.writeConcern != null) {
        this.options.writeConcern.j = val;
      } else {
        this.options.j = val;
      }
      return this;
    };
    Query.prototype.wtimeout = function wtimeout(ms) {
      if (ms == null) {
        delete this.options.wtimeout;
      }
      if (this.options.writeConcern != null) {
        this.options.writeConcern.wtimeout = ms;
      } else {
        this.options.wtimeout = ms;
      }
      return this;
    };
    Query.prototype.getOptions = function() {
      return this.options;
    };
    Query.prototype.setOptions = function(options, overwrite) {
      if (overwrite) {
        this._mongooseOptions = options && utils.clone(options) || {};
        this.options = options || {};
        if ("populate" in options) {
          this.populate(this._mongooseOptions);
        }
        return this;
      }
      if (options == null) {
        return this;
      }
      if (typeof options !== "object") {
        throw new Error('Options must be an object, got "' + options + '"');
      }
      if (Array.isArray(options.populate)) {
        const populate = options.populate;
        delete options.populate;
        const _numPopulate = populate.length;
        for (let i = 0; i < _numPopulate; ++i) {
          this.populate(populate[i]);
        }
      }
      if ("useFindAndModify" in options) {
        this._mongooseOptions.useFindAndModify = options.useFindAndModify;
        delete options.useFindAndModify;
      }
      if ("omitUndefined" in options) {
        this._mongooseOptions.omitUndefined = options.omitUndefined;
        delete options.omitUndefined;
      }
      if ("setDefaultsOnInsert" in options) {
        this._mongooseOptions.setDefaultsOnInsert = options.setDefaultsOnInsert;
        delete options.setDefaultsOnInsert;
      }
      if ("overwriteDiscriminatorKey" in options) {
        this._mongooseOptions.overwriteDiscriminatorKey = options.overwriteDiscriminatorKey;
        delete options.overwriteDiscriminatorKey;
      }
      if ("sanitizeProjection" in options) {
        if (options.sanitizeProjection && !this._mongooseOptions.sanitizeProjection) {
          sanitizeProjection(this._fields);
        }
        this._mongooseOptions.sanitizeProjection = options.sanitizeProjection;
        delete options.sanitizeProjection;
      }
      if ("defaults" in options) {
        this._mongooseOptions.defaults = options.defaults;
      }
      return Query.base.setOptions.call(this, options);
    };
    Query.prototype.explain = function(verbose) {
      if (arguments.length === 0) {
        this.options.explain = true;
      } else if (verbose === false) {
        delete this.options.explain;
      } else {
        this.options.explain = verbose;
      }
      return this;
    };
    Query.prototype.allowDiskUse = function(v) {
      if (arguments.length === 0) {
        this.options.allowDiskUse = true;
      } else if (v === false) {
        delete this.options.allowDiskUse;
      } else {
        this.options.allowDiskUse = v;
      }
      return this;
    };
    Query.prototype.maxTimeMS = function(ms) {
      this.options.maxTimeMS = ms;
      return this;
    };
    Query.prototype.getFilter = function() {
      return this._conditions;
    };
    Query.prototype.getQuery = function() {
      return this._conditions;
    };
    Query.prototype.setQuery = function(val) {
      this._conditions = val;
    };
    Query.prototype.getUpdate = function() {
      return this._update;
    };
    Query.prototype.setUpdate = function(val) {
      this._update = val;
    };
    Query.prototype._fieldsForExec = function() {
      return utils.clone(this._fields);
    };
    Query.prototype._updateForExec = function() {
      const update = utils.clone(this._update, {
        transform: false,
        depopulate: true
      });
      const ops = Object.keys(update);
      let i = ops.length;
      const ret2 = {};
      while (i--) {
        const op = ops[i];
        if (this.options.overwrite) {
          ret2[op] = update[op];
          continue;
        }
        if ("$" !== op[0]) {
          if (!ret2.$set) {
            if (update.$set) {
              ret2.$set = update.$set;
            } else {
              ret2.$set = {};
            }
          }
          ret2.$set[op] = update[op];
          ops.splice(i, 1);
          if (!~ops.indexOf("$set"))
            ops.push("$set");
        } else if ("$set" === op) {
          if (!ret2.$set) {
            ret2[op] = update[op];
          }
        } else {
          ret2[op] = update[op];
        }
      }
      return ret2;
    };
    Query.prototype._optionsForExec = function(model) {
      const options = utils.clone(this.options);
      delete options.populate;
      model = model || this.model;
      if (!model) {
        return options;
      }
      const safe = get(model, "schema.options.safe", null);
      if (!("safe" in options) && safe != null) {
        setSafe(options, safe);
      }
      applyWriteConcern(model.schema, options);
      const readPreference = get(model, "schema.options.read");
      if (!("readPreference" in options) && readPreference) {
        options.readPreference = readPreference;
      }
      if (options.upsert !== void 0) {
        options.upsert = !!options.upsert;
      }
      if (options.writeConcern) {
        if (options.j) {
          options.writeConcern.j = options.j;
          delete options.j;
        }
        if (options.w) {
          options.writeConcern.w = options.w;
          delete options.w;
        }
        if (options.wtimeout) {
          options.writeConcern.wtimeout = options.wtimeout;
          delete options.wtimeout;
        }
      }
      return options;
    };
    var safeDeprecationWarning = "Mongoose: the `safe` option is deprecated. Use write concerns instead: http://bit.ly/mongoose-w";
    var setSafe = util2.deprecate(function setSafe2(options, safe) {
      options.safe = safe;
    }, safeDeprecationWarning);
    Query.prototype.lean = function(v) {
      this._mongooseOptions.lean = arguments.length ? v : true;
      return this;
    };
    Query.prototype.set = function(path3, val) {
      if (typeof path3 === "object") {
        const keys = Object.keys(path3);
        for (const key of keys) {
          this.set(key, path3[key]);
        }
        return this;
      }
      this._update = this._update || {};
      this._update.$set = this._update.$set || {};
      this._update.$set[path3] = val;
      return this;
    };
    Query.prototype.get = function get2(path3) {
      const update = this._update;
      if (update == null) {
        return void 0;
      }
      const $set = update.$set;
      if ($set == null) {
        return update[path3];
      }
      if (utils.hasUserDefinedProperty(update, path3)) {
        return update[path3];
      }
      if (utils.hasUserDefinedProperty($set, path3)) {
        return $set[path3];
      }
      return void 0;
    };
    Query.prototype.error = function error(err) {
      if (arguments.length === 0) {
        return this._error;
      }
      this._error = err;
      return this;
    };
    Query.prototype._unsetCastError = function _unsetCastError() {
      if (this._error != null && !(this._error instanceof CastError)) {
        return;
      }
      return this.error(null);
    };
    Query.prototype.mongooseOptions = function(v) {
      if (arguments.length > 0) {
        this._mongooseOptions = v;
      }
      return this._mongooseOptions;
    };
    Query.prototype._castConditions = function() {
      try {
        this.cast(this.model);
        this._unsetCastError();
      } catch (err) {
        this.error(err);
      }
    };
    function _castArrayFilters(query) {
      try {
        castArrayFilters(query);
      } catch (err) {
        query.error(err);
      }
    }
    Query.prototype._find = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      callback = _wrapThunkCallback(this, callback);
      this._applyPaths();
      this._fields = this._castFields(this._fields);
      const fields = this._fieldsForExec();
      const mongooseOptions = this._mongooseOptions;
      const _this = this;
      const userProvidedFields = _this._userProvidedFields || {};
      applyGlobalMaxTimeMS(this.options, this.model);
      const completeManyOptions = Object.assign({}, {
        session: get(this, "options.session", null)
      });
      const cb = (err, docs) => {
        if (err) {
          return callback(err);
        }
        if (docs.length === 0) {
          return callback(null, docs);
        }
        if (this.options.explain) {
          return callback(null, docs);
        }
        if (!mongooseOptions.populate) {
          return mongooseOptions.lean ? callback(null, docs) : completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, callback);
        }
        const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);
        completeManyOptions.populated = pop;
        _this.model.populate(docs, pop, function(err2, docs2) {
          if (err2)
            return callback(err2);
          return mongooseOptions.lean ? callback(null, docs2) : completeMany(_this.model, docs2, fields, userProvidedFields, completeManyOptions, callback);
        });
      };
      const options = this._optionsForExec();
      options.projection = this._fieldsForExec();
      const filter = this._conditions;
      this._collection.find(filter, options, cb);
      return null;
    });
    Query.prototype.find = function(conditions, callback) {
      this.op = "find";
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      conditions = utils.toObject(conditions);
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
      } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "find"));
      }
      if (!callback) {
        return Query.base.find.call(this);
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.merge = function(source) {
      if (!source) {
        return this;
      }
      const opts = { overwrite: true };
      if (source instanceof Query) {
        if (source._conditions) {
          utils.merge(this._conditions, source._conditions, opts);
        }
        if (source._fields) {
          this._fields || (this._fields = {});
          utils.merge(this._fields, source._fields, opts);
        }
        if (source.options) {
          this.options || (this.options = {});
          utils.merge(this.options, source.options, opts);
        }
        if (source._update) {
          this._update || (this._update = {});
          utils.mergeClone(this._update, source._update);
        }
        if (source._distinct) {
          this._distinct = source._distinct;
        }
        utils.merge(this._mongooseOptions, source._mongooseOptions);
        return this;
      }
      utils.merge(this._conditions, source, opts);
      return this;
    };
    Query.prototype.collation = function(value) {
      if (this.options == null) {
        this.options = {};
      }
      this.options.collation = value;
      return this;
    };
    Query.prototype._completeOne = function(doc, res, callback) {
      if (!doc && !this.options.rawResult) {
        return callback(null, null);
      }
      const model = this.model;
      const projection = utils.clone(this._fields);
      const userProvidedFields = this._userProvidedFields || {};
      const mongooseOptions = this._mongooseOptions;
      const options = this.options;
      if (options.explain) {
        return callback(null, doc);
      }
      if (!mongooseOptions.populate) {
        return mongooseOptions.lean ? _completeOneLean(doc, res, options, callback) : completeOne(
          model,
          doc,
          res,
          options,
          projection,
          userProvidedFields,
          null,
          callback
        );
      }
      const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);
      model.populate(doc, pop, (err, doc2) => {
        if (err) {
          return callback(err);
        }
        return mongooseOptions.lean ? _completeOneLean(doc2, res, options, callback) : completeOne(
          model,
          doc2,
          res,
          options,
          projection,
          userProvidedFields,
          pop,
          callback
        );
      });
    };
    Query.prototype._findOne = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error()) {
        callback(this.error());
        return null;
      }
      this._applyPaths();
      this._fields = this._castFields(this._fields);
      applyGlobalMaxTimeMS(this.options, this.model);
      Query.base.findOne.call(this, {}, (err, doc) => {
        if (err) {
          callback(err);
          return null;
        }
        this._completeOne(doc, null, _wrapThunkCallback(this, callback));
      });
    });
    Query.prototype.findOne = function(conditions, projection, options, callback) {
      this.op = "findOne";
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = null;
        projection = null;
        options = null;
      } else if (typeof projection === "function") {
        callback = projection;
        options = null;
        projection = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      conditions = utils.toObject(conditions);
      if (options) {
        this.setOptions(options);
      }
      if (projection) {
        this.select(projection);
      }
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
      } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "findOne"));
      }
      if (!callback) {
        return Query.base.findOne.call(this);
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._count = wrapThunk(function(callback) {
      try {
        this.cast(this.model);
      } catch (err) {
        this.error(err);
      }
      if (this.error()) {
        return callback(this.error());
      }
      applyGlobalMaxTimeMS(this.options, this.model);
      const conds = this._conditions;
      const options = this._optionsForExec();
      this._collection.count(conds, options, utils.tick(callback));
    });
    Query.prototype._countDocuments = wrapThunk(function(callback) {
      try {
        this.cast(this.model);
      } catch (err) {
        this.error(err);
      }
      if (this.error()) {
        return callback(this.error());
      }
      applyGlobalMaxTimeMS(this.options, this.model);
      const conds = this._conditions;
      const options = this._optionsForExec();
      this._collection.collection.countDocuments(conds, options, utils.tick(callback));
    });
    Query.prototype._estimatedDocumentCount = wrapThunk(function(callback) {
      if (this.error()) {
        return callback(this.error());
      }
      const options = this._optionsForExec();
      this._collection.collection.estimatedDocumentCount(options, utils.tick(callback));
    });
    Query.prototype.count = function(filter, callback) {
      this.op = "count";
      if (typeof filter === "function") {
        callback = filter;
        filter = void 0;
      }
      filter = utils.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
      }
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.estimatedDocumentCount = function(options, callback) {
      this.op = "estimatedDocumentCount";
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      if (typeof options === "object" && options != null) {
        this.setOptions(options);
      }
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.countDocuments = function(conditions, callback) {
      this.op = "countDocuments";
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
      }
      conditions = utils.toObject(conditions);
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
      }
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.__distinct = wrapThunk(function __distinct(callback) {
      this._castConditions();
      if (this.error()) {
        callback(this.error());
        return null;
      }
      applyGlobalMaxTimeMS(this.options, this.model);
      const options = this._optionsForExec();
      this._collection.collection.distinct(this._distinct, this._conditions, options, callback);
    });
    Query.prototype.distinct = function(field, conditions, callback) {
      this.op = "distinct";
      if (!callback) {
        if (typeof conditions === "function") {
          callback = conditions;
          conditions = void 0;
        } else if (typeof field === "function") {
          callback = field;
          field = void 0;
          conditions = void 0;
        }
      }
      conditions = utils.toObject(conditions);
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
        prepareDiscriminatorCriteria(this);
      } else if (conditions != null) {
        this.error(new ObjectParameterError(conditions, "filter", "distinct"));
      }
      if (field != null) {
        this._distinct = field;
      }
      if (callback != null) {
        this.exec(callback);
      }
      return this;
    };
    Query.prototype.sort = function(arg) {
      if (arguments.length > 1) {
        throw new Error("sort() only takes 1 Argument");
      }
      return Query.base.sort.call(this, arg);
    };
    Query.prototype.remove = function(filter, callback) {
      this.op = "remove";
      if (typeof filter === "function") {
        callback = filter;
        filter = null;
      }
      filter = utils.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
      } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "remove"));
      }
      if (!callback) {
        return Query.base.remove.call(this);
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._remove = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return this;
      }
      callback = _wrapThunkCallback(this, callback);
      return Query.base.remove.call(this, helpers.handleDeleteWriteOpResult(callback));
    });
    Query.prototype.deleteOne = function(filter, options, callback) {
      this.op = "deleteOne";
      if (typeof filter === "function") {
        callback = filter;
        filter = null;
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      } else {
        this.setOptions(options);
      }
      filter = utils.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
      } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "deleteOne"));
      }
      if (!callback) {
        return Query.base.deleteOne.call(this);
      }
      this.exec.call(this, callback);
      return this;
    };
    Query.prototype._deleteOne = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return this;
      }
      callback = _wrapThunkCallback(this, callback);
      return Query.base.deleteOne.call(this, helpers.handleDeleteWriteOpResult(callback));
    });
    Query.prototype.deleteMany = function(filter, options, callback) {
      this.op = "deleteMany";
      if (typeof filter === "function") {
        callback = filter;
        filter = null;
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      } else {
        this.setOptions(options);
      }
      filter = utils.toObject(filter);
      if (mquery.canMerge(filter)) {
        this.merge(filter);
        prepareDiscriminatorCriteria(this);
      } else if (filter != null) {
        this.error(new ObjectParameterError(filter, "filter", "deleteMany"));
      }
      if (!callback) {
        return Query.base.deleteMany.call(this);
      }
      this.exec.call(this, callback);
      return this;
    };
    Query.prototype._deleteMany = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return this;
      }
      callback = _wrapThunkCallback(this, callback);
      return Query.base.deleteMany.call(this, helpers.handleDeleteWriteOpResult(callback));
    });
    function completeOne(model, doc, res, options, fields, userProvidedFields, pop, callback) {
      const opts = pop ? { populated: pop } : void 0;
      if (options.rawResult && doc == null) {
        _init(null);
        return null;
      }
      const casted = helpers.createModel(model, doc, fields, userProvidedFields, options);
      try {
        casted.init(doc, opts, _init);
      } catch (error) {
        _init(error);
      }
      function _init(err) {
        if (err) {
          return immediate(() => callback(err));
        }
        if (options.rawResult) {
          if (doc && casted) {
            if (options.session != null) {
              casted.$session(options.session);
            }
            res.value = casted;
          } else {
            res.value = null;
          }
          return immediate(() => callback(null, res));
        }
        if (options.session != null) {
          casted.$session(options.session);
        }
        immediate(() => callback(null, casted));
      }
    }
    function prepareDiscriminatorCriteria(query) {
      if (!query || !query.model || !query.model.schema) {
        return;
      }
      const schema = query.model.schema;
      if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
        query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
      }
    }
    Query.prototype.findOneAndUpdate = function(criteria, doc, options, callback) {
      this.op = "findOneAndUpdate";
      this._validate();
      switch (arguments.length) {
        case 3:
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          break;
        case 2:
          if (typeof doc === "function") {
            callback = doc;
            doc = criteria;
            criteria = void 0;
          }
          options = void 0;
          break;
        case 1:
          if (typeof criteria === "function") {
            callback = criteria;
            criteria = options = doc = void 0;
          } else {
            doc = criteria;
            criteria = options = void 0;
          }
      }
      if (mquery.canMerge(criteria)) {
        this.merge(criteria);
      }
      if (doc) {
        this._mergeUpdate(doc);
      }
      options = options ? utils.clone(options) : {};
      if (options.projection) {
        this.select(options.projection);
        delete options.projection;
      }
      if (options.fields) {
        this.select(options.fields);
        delete options.fields;
      }
      const returnOriginal = get(this, "model.base.options.returnOriginal");
      if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
        options.returnOriginal = returnOriginal;
      }
      this.setOptions(options);
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._findOneAndUpdate = wrapThunk(function(callback) {
      if (this.error() != null) {
        return callback(this.error());
      }
      this._findAndModify("update", callback);
    });
    Query.prototype.findOneAndRemove = function(conditions, options, callback) {
      this.op = "findOneAndRemove";
      this._validate();
      switch (arguments.length) {
        case 2:
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          break;
        case 1:
          if (typeof conditions === "function") {
            callback = conditions;
            conditions = void 0;
            options = void 0;
          }
          break;
      }
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
      }
      options && this.setOptions(options);
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype.findOneAndDelete = function(conditions, options, callback) {
      this.op = "findOneAndDelete";
      this._validate();
      switch (arguments.length) {
        case 2:
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          break;
        case 1:
          if (typeof conditions === "function") {
            callback = conditions;
            conditions = void 0;
            options = void 0;
          }
          break;
      }
      if (mquery.canMerge(conditions)) {
        this.merge(conditions);
      }
      options && this.setOptions(options);
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._findOneAndDelete = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      const filter = this._conditions;
      const options = this._optionsForExec();
      let fields = null;
      if (this._fields != null) {
        options.projection = this._castFields(utils.clone(this._fields));
        fields = options.projection;
        if (fields instanceof Error) {
          callback(fields);
          return null;
        }
      }
      this._collection.collection.findOneAndDelete(filter, options, _wrapThunkCallback(this, (err, res) => {
        if (err) {
          return callback(err);
        }
        const doc = res.value;
        return this._completeOne(doc, res, callback);
      }));
    });
    Query.prototype.findOneAndReplace = function(filter, replacement, options, callback) {
      this.op = "findOneAndReplace";
      this._validate();
      switch (arguments.length) {
        case 3:
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
          break;
        case 2:
          if (typeof replacement === "function") {
            callback = replacement;
            replacement = void 0;
          }
          break;
        case 1:
          if (typeof filter === "function") {
            callback = filter;
            filter = void 0;
            replacement = void 0;
            options = void 0;
          }
          break;
      }
      if (mquery.canMerge(filter)) {
        this.merge(filter);
      }
      if (replacement != null) {
        if (hasDollarKeys(replacement)) {
          throw new Error("The replacement document must not contain atomic operators.");
        }
        this._mergeUpdate(replacement);
      }
      options = options || {};
      const returnOriginal = get(this, "model.base.options.returnOriginal");
      if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
        options.returnOriginal = returnOriginal;
      }
      this.setOptions(options);
      this.setOptions({ overwrite: true });
      if (!callback) {
        return this;
      }
      this.exec(callback);
      return this;
    };
    Query.prototype._findOneAndReplace = wrapThunk(function(callback) {
      this._castConditions();
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      const filter = this._conditions;
      const options = this._optionsForExec();
      convertNewToReturnDocument(options);
      let fields = null;
      let castedDoc = new this.model(this._update, null, true);
      this._update = castedDoc;
      this._applyPaths();
      if (this._fields != null) {
        options.projection = this._castFields(utils.clone(this._fields));
        fields = options.projection;
        if (fields instanceof Error) {
          callback(fields);
          return null;
        }
      }
      castedDoc.validate((err) => {
        if (err != null) {
          return callback(err);
        }
        if (castedDoc.toBSON) {
          castedDoc = castedDoc.toBSON();
        }
        this._collection.collection.findOneAndReplace(filter, castedDoc, options, _wrapThunkCallback(this, (err2, res) => {
          if (err2) {
            return callback(err2);
          }
          const doc = res.value;
          return this._completeOne(doc, res, callback);
        }));
      });
    });
    function convertNewToReturnDocument(options) {
      if ("new" in options) {
        options.returnDocument = options["new"] ? "after" : "before";
        delete options["new"];
      }
      if ("returnOriginal" in options) {
        options.returnDocument = options["returnOriginal"] ? "before" : "after";
        delete options["returnOriginal"];
      }
    }
    Query.prototype._findOneAndRemove = wrapThunk(function(callback) {
      if (this.error() != null) {
        callback(this.error());
        return;
      }
      this._findAndModify("remove", callback);
    });
    function _getOption(query, option, def) {
      const opts = query._optionsForExec(query.model);
      if (option in opts) {
        return opts[option];
      }
      if (option in query.model.base.options) {
        return query.model.base.options[option];
      }
      return def;
    }
    Query.prototype._findAndModify = function(type, callback) {
      if (typeof callback !== "function") {
        throw new Error("Expected callback in _findAndModify");
      }
      const model = this.model;
      const schema = model.schema;
      const _this = this;
      let fields;
      const castedQuery = castQuery(this);
      if (castedQuery instanceof Error) {
        return callback(castedQuery);
      }
      _castArrayFilters(this);
      const opts = this._optionsForExec(model);
      if ("strict" in opts) {
        this._mongooseOptions.strict = opts.strict;
      }
      const isOverwriting = this.options.overwrite && !hasDollarKeys(this._update);
      if (isOverwriting) {
        this._update = new this.model(this._update, null, true);
      }
      if (type === "remove") {
        opts.remove = true;
      } else {
        if (!("new" in opts) && !("returnOriginal" in opts) && !("returnDocument" in opts)) {
          opts.new = false;
        }
        if (!("upsert" in opts)) {
          opts.upsert = false;
        }
        if (opts.upsert || opts["new"]) {
          opts.remove = false;
        }
        if (!isOverwriting) {
          this._update = castDoc(this, opts.overwrite);
          const _opts = Object.assign({}, opts, {
            setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
          });
          this._update = setDefaultsOnInsert(this._conditions, schema, this._update, _opts);
          if (!this._update || Object.keys(this._update).length === 0) {
            if (opts.upsert) {
              const doc = utils.clone(castedQuery);
              delete doc._id;
              this._update = { $set: doc };
            } else {
              this.findOne(callback);
              return this;
            }
          } else if (this._update instanceof Error) {
            return callback(this._update);
          } else {
            if (this._update.$set && Object.keys(this._update.$set).length === 0) {
              delete this._update.$set;
            }
          }
        }
        if (Array.isArray(opts.arrayFilters)) {
          opts.arrayFilters = removeUnusedArrayFilters(this._update, opts.arrayFilters);
        }
      }
      this._applyPaths();
      const options = this._mongooseOptions;
      if (this._fields) {
        fields = utils.clone(this._fields);
        opts.projection = this._castFields(fields);
        if (opts.projection instanceof Error) {
          return callback(opts.projection);
        }
      }
      if (opts.sort)
        convertSortToArray(opts);
      const cb = function(err, doc, res) {
        if (err) {
          return callback(err);
        }
        _this._completeOne(doc, res, callback);
      };
      let useFindAndModify = true;
      const runValidators = _getOption(this, "runValidators", false);
      const base = _this.model && _this.model.base;
      const conn = get(model, "collection.conn", {});
      if ("useFindAndModify" in base.options) {
        useFindAndModify = base.get("useFindAndModify");
      }
      if ("useFindAndModify" in conn.config) {
        useFindAndModify = conn.config.useFindAndModify;
      }
      if ("useFindAndModify" in options) {
        useFindAndModify = options.useFindAndModify;
      }
      if (useFindAndModify === false) {
        const collection = _this._collection.collection;
        convertNewToReturnDocument(opts);
        if (type === "remove") {
          collection.findOneAndDelete(castedQuery, opts, _wrapThunkCallback(_this, function(error, res) {
            return cb(error, res ? res.value : res, res);
          }));
          return this;
        }
        const updateMethod = isOverwriting ? "findOneAndReplace" : "findOneAndUpdate";
        if (runValidators) {
          this.validate(this._update, opts, isOverwriting, (error) => {
            if (error) {
              return callback(error);
            }
            if (this._update && this._update.toBSON) {
              this._update = this._update.toBSON();
            }
            collection[updateMethod](castedQuery, this._update, opts, _wrapThunkCallback(_this, function(error2, res) {
              return cb(error2, res ? res.value : res, res);
            }));
          });
        } else {
          if (this._update && this._update.toBSON) {
            this._update = this._update.toBSON();
          }
          collection[updateMethod](castedQuery, this._update, opts, _wrapThunkCallback(_this, function(error, res) {
            return cb(error, res ? res.value : res, res);
          }));
        }
        return this;
      }
      if (runValidators) {
        this.validate(this._update, opts, isOverwriting, function(error) {
          if (error) {
            return callback(error);
          }
          _legacyFindAndModify.call(_this, castedQuery, _this._update, opts, cb);
        });
      } else {
        _legacyFindAndModify.call(_this, castedQuery, _this._update, opts, cb);
      }
      return this;
    };
    function _completeOneLean(doc, res, opts, callback) {
      if (opts.rawResult) {
        return callback(null, res);
      }
      return callback(null, doc);
    }
    var _legacyFindAndModify = util2.deprecate(function(filter, update, opts, cb) {
      if (update && update.toBSON) {
        update = update.toBSON();
      }
      const collection = this._collection;
      const sort = opts != null && Array.isArray(opts.sort) ? opts.sort : [];
      const _cb = _wrapThunkCallback(this, function(error, res) {
        return cb(error, res ? res.value : res, res);
      });
      collection.collection._findAndModify(filter, sort, update, opts, _cb);
    }, "Mongoose: `findOneAndUpdate()` and `findOneAndDelete()` without the `useFindAndModify` option set to false are deprecated. See: https://mongoosejs.com/docs/5.x/docs/deprecations.html#findandmodify");
    Query.prototype._mergeUpdate = function(doc) {
      if (doc == null || typeof doc === "object" && Object.keys(doc).length === 0) {
        return;
      }
      if (!this._update) {
        this._update = Array.isArray(doc) ? [] : {};
      }
      if (doc instanceof Query) {
        if (Array.isArray(this._update)) {
          throw new Error("Cannot mix array and object updates");
        }
        if (doc._update) {
          utils.mergeClone(this._update, doc._update);
        }
      } else if (Array.isArray(doc)) {
        if (!Array.isArray(this._update)) {
          throw new Error("Cannot mix array and object updates");
        }
        this._update = this._update.concat(doc);
      } else {
        if (Array.isArray(this._update)) {
          throw new Error("Cannot mix array and object updates");
        }
        utils.mergeClone(this._update, doc);
      }
    };
    function convertSortToArray(opts) {
      if (Array.isArray(opts.sort)) {
        return;
      }
      if (!utils.isObject(opts.sort)) {
        return;
      }
      const sort = [];
      for (const key in opts.sort) {
        if (utils.object.hasOwnProperty(opts.sort, key)) {
          sort.push([key, opts.sort[key]]);
        }
      }
      opts.sort = sort;
    }
    function _updateThunk(op, callback) {
      this._castConditions();
      _castArrayFilters(this);
      if (this.error() != null) {
        callback(this.error());
        return null;
      }
      callback = _wrapThunkCallback(this, callback);
      const oldCb = callback;
      callback = function(error, result) {
        oldCb(error, result ? result.result : { ok: 0, n: 0, nModified: 0 });
      };
      const castedQuery = this._conditions;
      const options = this._optionsForExec(this.model);
      ++this._executionCount;
      this._update = utils.clone(this._update, options);
      const isOverwriting = this.options.overwrite && !hasDollarKeys(this._update);
      if (isOverwriting) {
        if (op === "updateOne" || op === "updateMany") {
          return callback(new MongooseError("The MongoDB server disallows overwriting documents using `" + op + "`. See: https://mongoosejs.com/docs/deprecations.html#update"));
        }
        this._update = new this.model(this._update, null, true);
      } else {
        this._update = castDoc(this, options.overwrite);
        if (this._update instanceof Error) {
          callback(this._update);
          return null;
        }
        if (this._update == null || Object.keys(this._update).length === 0) {
          callback(null, 0);
          return null;
        }
        const _opts = Object.assign({}, options, {
          setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
        });
        this._update = setDefaultsOnInsert(
          this._conditions,
          this.model.schema,
          this._update,
          _opts
        );
      }
      if (Array.isArray(options.arrayFilters)) {
        options.arrayFilters = removeUnusedArrayFilters(this._update, options.arrayFilters);
      }
      const runValidators = _getOption(this, "runValidators", false);
      if (runValidators) {
        this.validate(this._update, options, isOverwriting, (err) => {
          if (err) {
            return callback(err);
          }
          if (this._update.toBSON) {
            this._update = this._update.toBSON();
          }
          this._collection[op](castedQuery, this._update, options, callback);
        });
        return null;
      }
      if (this._update.toBSON) {
        this._update = this._update.toBSON();
      }
      this._collection[op](castedQuery, this._update, options, callback);
      return null;
    }
    Query.prototype.validate = function validate(castedDoc, options, isOverwriting, callback) {
      return promiseOrCallback(callback, (cb) => {
        try {
          if (isOverwriting) {
            castedDoc.validate(cb);
          } else {
            updateValidators(this, this.model.schema, castedDoc, options, cb);
          }
        } catch (err) {
          immediate(function() {
            cb(err);
          });
        }
      });
    };
    Query.prototype._execUpdate = wrapThunk(function(callback) {
      return _updateThunk.call(this, "update", callback);
    });
    Query.prototype._updateMany = wrapThunk(function(callback) {
      return _updateThunk.call(this, "updateMany", callback);
    });
    Query.prototype._updateOne = wrapThunk(function(callback) {
      return _updateThunk.call(this, "updateOne", callback);
    });
    Query.prototype._replaceOne = wrapThunk(function(callback) {
      return _updateThunk.call(this, "replaceOne", callback);
    });
    Query.prototype.update = function(conditions, doc, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options = void 0;
      } else if (typeof conditions === "object" && !doc && !options && !callback) {
        doc = conditions;
        conditions = void 0;
        options = void 0;
        callback = void 0;
      }
      return _update(this, "update", conditions, doc, options, callback);
    };
    Query.prototype.updateMany = function(conditions, doc, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options = void 0;
      } else if (typeof conditions === "object" && !doc && !options && !callback) {
        doc = conditions;
        conditions = void 0;
        options = void 0;
        callback = void 0;
      }
      return _update(this, "updateMany", conditions, doc, options, callback);
    };
    Query.prototype.updateOne = function(conditions, doc, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options = void 0;
      } else if (typeof conditions === "object" && !doc && !options && !callback) {
        doc = conditions;
        conditions = void 0;
        options = void 0;
        callback = void 0;
      }
      return _update(this, "updateOne", conditions, doc, options, callback);
    };
    Query.prototype.replaceOne = function(conditions, doc, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof doc === "function") {
        callback = doc;
        doc = conditions;
        conditions = {};
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = void 0;
        doc = void 0;
        options = void 0;
      } else if (typeof conditions === "object" && !doc && !options && !callback) {
        doc = conditions;
        conditions = void 0;
        options = void 0;
        callback = void 0;
      }
      this.setOptions({ overwrite: true });
      return _update(this, "replaceOne", conditions, doc, options, callback);
    };
    function _update(query, op, filter, doc, options, callback) {
      query.op = op;
      filter = utils.toObject(filter);
      doc = doc || {};
      if (options != null) {
        if ("strict" in options) {
          query._mongooseOptions.strict = options.strict;
        }
      }
      if (!(filter instanceof Query) && filter != null && filter.toString() !== "[object Object]") {
        query.error(new ObjectParameterError(filter, "filter", op));
      } else {
        query.merge(filter);
      }
      if (utils.isObject(options)) {
        query.setOptions(options);
      }
      query._mergeUpdate(doc);
      if (callback) {
        query.exec(callback);
        return query;
      }
      return Query.base[op].call(query, filter, void 0, options, callback);
    }
    Query.prototype.map = function(fn) {
      this._transforms.push(fn);
      return this;
    };
    Query.prototype.orFail = function(err) {
      this.map((res) => {
        switch (this.op) {
          case "find":
            if (res.length === 0) {
              throw _orFailError(err, this);
            }
            break;
          case "findOne":
            if (res == null) {
              throw _orFailError(err, this);
            }
            break;
          case "update":
          case "updateMany":
          case "updateOne":
            if (get(res, "nModified") === 0) {
              throw _orFailError(err, this);
            }
            break;
          case "findOneAndDelete":
          case "findOneAndRemove":
            if (get(res, "lastErrorObject.n") === 0) {
              throw _orFailError(err, this);
            }
            break;
          case "findOneAndUpdate":
          case "findOneAndReplace":
            if (get(res, "lastErrorObject.updatedExisting") === false) {
              throw _orFailError(err, this);
            }
            break;
          case "deleteMany":
          case "deleteOne":
          case "remove":
            if (res.n === 0) {
              throw _orFailError(err, this);
            }
            break;
          default:
            break;
        }
        return res;
      });
      return this;
    };
    function _orFailError(err, query) {
      if (typeof err === "function") {
        err = err.call(query);
      }
      if (err == null) {
        err = new DocumentNotFoundError(query.getQuery(), query.model.modelName);
      }
      return err;
    }
    Query.prototype.exec = function exec(op, callback) {
      const _this = this;
      const castError = new CastError();
      if (typeof op === "function") {
        callback = op;
        op = null;
      } else if (typeof op === "string") {
        this.op = op;
      }
      callback = this.model.$handleCallbackError(callback);
      return promiseOrCallback(callback, (cb) => {
        cb = this.model.$wrapCallback(cb);
        if (!_this.op) {
          cb();
          return;
        }
        this._hooks.execPre("exec", this, [], (error) => {
          if (error != null) {
            return cb(_cleanCastErrorStack(castError, error));
          }
          let thunk = "_" + this.op;
          if (this.op === "update") {
            thunk = "_execUpdate";
          } else if (this.op === "distinct") {
            thunk = "__distinct";
          }
          this[thunk].call(this, (error2, res) => {
            if (error2) {
              return cb(_cleanCastErrorStack(castError, error2));
            }
            this._hooks.execPost("exec", this, [], {}, (error3) => {
              if (error3) {
                return cb(_cleanCastErrorStack(castError, error3));
              }
              cb(null, res);
            });
          });
        });
      }, this.model.events);
    };
    function _cleanCastErrorStack(castError, error) {
      if (error instanceof CastError) {
        castError.copy(error);
        return castError;
      }
      return error;
    }
    function _wrapThunkCallback(query, cb) {
      return function(error, res) {
        if (error != null) {
          return cb(error);
        }
        for (const fn of query._transforms) {
          try {
            res = fn(res);
          } catch (error2) {
            return cb(error2);
          }
        }
        return cb(null, res);
      };
    }
    Query.prototype.then = function(resolve, reject) {
      return this.exec().then(resolve, reject);
    };
    Query.prototype.catch = function(reject) {
      return this.exec().then(null, reject);
    };
    Query.prototype.pre = function(fn) {
      this._hooks.pre("exec", fn);
      return this;
    };
    Query.prototype.post = function(fn) {
      this._hooks.post("exec", fn);
      return this;
    };
    Query.prototype._castUpdate = function _castUpdate(obj2, overwrite) {
      let strict;
      let schema = this.schema;
      const discriminatorKey = schema.options.discriminatorKey;
      const baseSchema = schema._baseSchema ? schema._baseSchema : schema;
      if (this._mongooseOptions.overwriteDiscriminatorKey && obj2[discriminatorKey] != null && baseSchema.discriminators) {
        const _schema = baseSchema.discriminators[obj2[discriminatorKey]];
        if (_schema != null) {
          schema = _schema;
        }
      }
      if ("strict" in this._mongooseOptions) {
        strict = this._mongooseOptions.strict;
      } else if (this.schema && this.schema.options) {
        strict = this.schema.options.strict;
      } else {
        strict = true;
      }
      let omitUndefined = false;
      if ("omitUndefined" in this._mongooseOptions) {
        omitUndefined = this._mongooseOptions.omitUndefined;
      }
      let useNestedStrict;
      if ("useNestedStrict" in this.options) {
        useNestedStrict = this.options.useNestedStrict;
      }
      let upsert;
      if ("upsert" in this.options) {
        upsert = this.options.upsert;
      }
      const filter = this._conditions;
      if (schema != null && utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) && typeof filter[schema.options.discriminatorKey] !== "object" && schema.discriminators != null) {
        const discriminatorValue = filter[schema.options.discriminatorKey];
        const byValue = getDiscriminatorByValue(this.model.discriminators, discriminatorValue);
        schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;
      }
      return castUpdate(schema, obj2, {
        overwrite,
        strict,
        omitUndefined,
        useNestedStrict,
        upsert,
        arrayFilters: this.options.arrayFilters
      }, this, this._conditions);
    };
    function castQuery(query) {
      try {
        return query.cast(query.model);
      } catch (err) {
        return err;
      }
    }
    function castDoc(query, overwrite) {
      try {
        return query._castUpdate(query._update, overwrite);
      } catch (err) {
        return err;
      }
    }
    Query.prototype.populate = function() {
      if (!Array.from(arguments).some(Boolean)) {
        return this;
      }
      const res = utils.populate.apply(null, arguments);
      if (this.options != null) {
        const readConcern = this.options.readConcern;
        const readPref = this.options.readPreference;
        for (const populateOptions of res) {
          if (readConcern != null && get(populateOptions, "options.readConcern") == null) {
            populateOptions.options = populateOptions.options || {};
            populateOptions.options.readConcern = readConcern;
          }
          if (readPref != null && get(populateOptions, "options.readPreference") == null) {
            populateOptions.options = populateOptions.options || {};
            populateOptions.options.readPreference = readPref;
          }
        }
      }
      const opts = this._mongooseOptions;
      if (opts.lean != null) {
        const lean = opts.lean;
        for (const populateOptions of res) {
          if (get(populateOptions, "options.lean") == null) {
            populateOptions.options = populateOptions.options || {};
            populateOptions.options.lean = lean;
          }
        }
      }
      if (!utils.isObject(opts.populate)) {
        opts.populate = {};
      }
      const pop = opts.populate;
      for (const populateOptions of res) {
        const path3 = populateOptions.path;
        if (pop[path3] && pop[path3].populate && populateOptions.populate) {
          populateOptions.populate = pop[path3].populate.concat(populateOptions.populate);
        }
        pop[populateOptions.path] = populateOptions;
      }
      return this;
    };
    Query.prototype.getPopulatedPaths = function getPopulatedPaths() {
      const obj2 = this._mongooseOptions.populate || {};
      const ret2 = Object.keys(obj2);
      for (const path3 of Object.keys(obj2)) {
        const pop = obj2[path3];
        if (!Array.isArray(pop.populate)) {
          continue;
        }
        _getPopulatedPaths(ret2, pop.populate, path3 + ".");
      }
      return ret2;
    };
    function _getPopulatedPaths(list, arr, prefix) {
      for (const pop of arr) {
        list.push(prefix + pop.path);
        if (!Array.isArray(pop.populate)) {
          continue;
        }
        _getPopulatedPaths(list, pop.populate, prefix + pop.path + ".");
      }
    }
    Query.prototype.cast = function(model, obj2) {
      obj2 || (obj2 = this._conditions);
      model = model || this.model;
      const discriminatorKey = model.schema.options.discriminatorKey;
      if (obj2 != null && obj2.hasOwnProperty(discriminatorKey)) {
        model = getDiscriminatorByValue(model.discriminators, obj2[discriminatorKey]) || model;
      }
      try {
        return cast(model.schema, obj2, {
          upsert: this.options && this.options.upsert,
          strict: this.options && "strict" in this.options ? this.options.strict : get(model, "schema.options.strict", null),
          strictQuery: this.options && this.options.strictQuery || get(model, "schema.options.strictQuery", null)
        }, this);
      } catch (err) {
        if (typeof err.setModel === "function") {
          err.setModel(model);
        }
        throw err;
      }
    };
    Query.prototype._castFields = function _castFields(fields) {
      let selected, elemMatchKeys, keys, key, out, i;
      if (fields) {
        keys = Object.keys(fields);
        elemMatchKeys = [];
        i = keys.length;
        while (i--) {
          key = keys[i];
          if (fields[key].$elemMatch) {
            selected || (selected = {});
            selected[key] = fields[key];
            elemMatchKeys.push(key);
          }
        }
      }
      if (selected) {
        try {
          out = this.cast(this.model, selected);
        } catch (err) {
          return err;
        }
        i = elemMatchKeys.length;
        while (i--) {
          key = elemMatchKeys[i];
          fields[key] = out[key];
        }
      }
      return fields;
    };
    Query.prototype._applyPaths = function applyPaths() {
      this._fields = this._fields || {};
      helpers.applyPaths(this._fields, this.model.schema);
      let _selectPopulatedPaths = true;
      if ("selectPopulatedPaths" in this.model.base.options) {
        _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;
      }
      if ("selectPopulatedPaths" in this.model.schema.options) {
        _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;
      }
      if (_selectPopulatedPaths) {
        selectPopulatedFields(this._fields, this._userProvidedFields, this._mongooseOptions.populate);
      }
    };
    Query.prototype.cursor = function cursor(opts) {
      this._applyPaths();
      this._fields = this._castFields(this._fields);
      this.setOptions({ projection: this._fieldsForExec() });
      if (opts) {
        this.setOptions(opts);
      }
      const options = Object.assign({}, this._optionsForExec(), {
        projection: this.projection()
      });
      try {
        this.cast(this.model);
      } catch (err) {
        return new QueryCursor(this, options)._markError(err);
      }
      return new QueryCursor(this, options);
    };
    Query.prototype.maxscan = Query.base.maxScan;
    Query.prototype.tailable = function(val, opts) {
      if (val != null && typeof val.constructor === "function" && val.constructor.name === "Object") {
        opts = val;
        val = true;
      }
      if (val === void 0) {
        val = true;
      }
      if (opts && typeof opts === "object") {
        for (const key of Object.keys(opts)) {
          if (key === "awaitdata") {
            this.options[key] = !!opts[key];
          } else {
            this.options[key] = opts[key];
          }
        }
      }
      return Query.base.tailable.call(this, val);
    };
    Query.prototype.near = function() {
      const params = [];
      const sphere = this._mongooseOptions.nearSphere;
      if (arguments.length === 1) {
        if (Array.isArray(arguments[0])) {
          params.push({ center: arguments[0], spherical: sphere });
        } else if (typeof arguments[0] === "string") {
          params.push(arguments[0]);
        } else if (utils.isObject(arguments[0])) {
          if (typeof arguments[0].spherical !== "boolean") {
            arguments[0].spherical = sphere;
          }
          params.push(arguments[0]);
        } else {
          throw new TypeError("invalid argument");
        }
      } else if (arguments.length === 2) {
        if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
          params.push({ center: [arguments[0], arguments[1]], spherical: sphere });
        } else if (typeof arguments[0] === "string" && Array.isArray(arguments[1])) {
          params.push(arguments[0]);
          params.push({ center: arguments[1], spherical: sphere });
        } else if (typeof arguments[0] === "string" && utils.isObject(arguments[1])) {
          params.push(arguments[0]);
          if (typeof arguments[1].spherical !== "boolean") {
            arguments[1].spherical = sphere;
          }
          params.push(arguments[1]);
        } else {
          throw new TypeError("invalid argument");
        }
      } else if (arguments.length === 3) {
        if (typeof arguments[0] === "string" && typeof arguments[1] === "number" && typeof arguments[2] === "number") {
          params.push(arguments[0]);
          params.push({ center: [arguments[1], arguments[2]], spherical: sphere });
        } else {
          throw new TypeError("invalid argument");
        }
      } else {
        throw new TypeError("invalid argument");
      }
      return Query.base.near.apply(this, params);
    };
    Query.prototype.nearSphere = function() {
      this._mongooseOptions.nearSphere = true;
      this.near.apply(this, arguments);
      return this;
    };
    if (Symbol.asyncIterator != null) {
      Query.prototype[Symbol.asyncIterator] = function() {
        return this.cursor().transformNull()._transformForAsyncIterator();
      };
    }
    Query.prototype.box = function(ll, ur) {
      if (!Array.isArray(ll) && utils.isObject(ll)) {
        ur = ll.ur;
        ll = ll.ll;
      }
      return Query.base.box.call(this, ll, ur);
    };
    Query.prototype.center = Query.base.circle;
    Query.prototype.centerSphere = function() {
      if (arguments[0] != null && typeof arguments[0].constructor === "function" && arguments[0].constructor.name === "Object") {
        arguments[0].spherical = true;
      }
      if (arguments[1] != null && typeof arguments[1].constructor === "function" && arguments[1].constructor.name === "Object") {
        arguments[1].spherical = true;
      }
      Query.base.circle.apply(this, arguments);
    };
    Query.prototype.selectedInclusively = function selectedInclusively() {
      return isInclusive(this._fields);
    };
    Query.prototype.selectedExclusively = function selectedExclusively() {
      return isExclusive(this._fields);
    };
    Query.prototype.model;
    module2.exports = Query;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cursor/AggregationCursor.js
var require_AggregationCursor = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/cursor/AggregationCursor.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_mongooseError();
    var Readable = require("stream").Readable;
    var promiseOrCallback = require_promiseOrCallback();
    var eachAsync = require_eachAsync();
    var immediate = require_immediate();
    var util2 = require("util");
    var utils = require_utils2();
    function AggregationCursor(agg) {
      const streamOpts = { objectMode: true };
      if (utils.nodeMajorVersion() >= 12) {
        streamOpts.autoDestroy = true;
      }
      Readable.call(this, streamOpts);
      this.cursor = null;
      this.agg = agg;
      this._transforms = [];
      const model = agg._model;
      delete agg.options.cursor.useMongooseAggCursor;
      this._mongooseOptions = {};
      _init(model, this, agg);
    }
    util2.inherits(AggregationCursor, Readable);
    function _init(model, c, agg) {
      if (!model.collection.buffer) {
        model.hooks.execPre("aggregate", agg, function() {
          c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
          c.emit("cursor", c.cursor);
        });
      } else {
        model.collection.emitter.once("queue", function() {
          model.hooks.execPre("aggregate", agg, function() {
            c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
            c.emit("cursor", c.cursor);
          });
        });
      }
    }
    AggregationCursor.prototype._read = function() {
      const _this = this;
      _next(this, function(error, doc) {
        if (error) {
          return _this.emit("error", error);
        }
        if (!doc) {
          _this.push(null);
          _this.cursor.close(function(error2) {
            if (error2) {
              return _this.emit("error", error2);
            }
            if (utils.nodeMajorVersion() < 12) {
              _this.on("end", () => _this.emit("close"));
            }
          });
          return;
        }
        _this.push(doc);
      });
    };
    if (Symbol.asyncIterator != null) {
      const msg = "Mongoose does not support using async iterators with an existing aggregation cursor. See http://bit.ly/mongoose-async-iterate-aggregation";
      AggregationCursor.prototype[Symbol.asyncIterator] = function() {
        throw new MongooseError(msg);
      };
    }
    AggregationCursor.prototype.map = function(fn) {
      this._transforms.push(fn);
      return this;
    };
    AggregationCursor.prototype._markError = function(error) {
      this._error = error;
      return this;
    };
    AggregationCursor.prototype.close = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        this.cursor.close((error) => {
          if (error) {
            cb(error);
            return this.listeners("error").length > 0 && this.emit("error", error);
          }
          this.emit("close");
          cb(null);
        });
      });
    };
    AggregationCursor.prototype.next = function(callback) {
      return promiseOrCallback(callback, (cb) => {
        _next(this, cb);
      });
    };
    AggregationCursor.prototype.eachAsync = function(fn, opts, callback) {
      const _this = this;
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      opts = opts || {};
      return eachAsync(function(cb) {
        return _next(_this, cb);
      }, fn, opts, callback);
    };
    if (Symbol.asyncIterator != null) {
      AggregationCursor.prototype[Symbol.asyncIterator] = function() {
        return this.transformNull()._transformForAsyncIterator();
      };
    }
    AggregationCursor.prototype._transformForAsyncIterator = function() {
      if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
        this.map(_transformForAsyncIterator);
      }
      return this;
    };
    AggregationCursor.prototype.transformNull = function(val) {
      if (arguments.length === 0) {
        val = true;
      }
      this._mongooseOptions.transformNull = val;
      return this;
    };
    function _transformForAsyncIterator(doc) {
      return doc == null ? { done: true } : { value: doc, done: false };
    }
    AggregationCursor.prototype.addCursorFlag = function(flag, value) {
      const _this = this;
      _waitForCursor(this, function() {
        _this.cursor.addCursorFlag(flag, value);
      });
      return this;
    };
    function _waitForCursor(ctx, cb) {
      if (ctx.cursor) {
        return cb();
      }
      ctx.once("cursor", function() {
        cb();
      });
    }
    function _next(ctx, cb) {
      let callback = cb;
      if (ctx._transforms.length) {
        callback = function(err, doc) {
          if (err || doc === null && !ctx._mongooseOptions.transformNull) {
            return cb(err, doc);
          }
          cb(err, ctx._transforms.reduce(function(doc2, fn) {
            return fn(doc2);
          }, doc));
        };
      }
      if (ctx._error) {
        return immediate(function() {
          callback(ctx._error);
        });
      }
      if (ctx.cursor) {
        return ctx.cursor.next(function(error, doc) {
          if (error) {
            return callback(error);
          }
          if (!doc) {
            return callback(null, null);
          }
          callback(null, doc);
        });
      } else {
        ctx.once("cursor", function() {
          _next(ctx, cb);
        });
      }
    }
    module2.exports = AggregationCursor;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js
var require_stringifyFunctionOperators = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function stringifyFunctionOperators(pipeline) {
      if (!Array.isArray(pipeline)) {
        return;
      }
      for (const stage of pipeline) {
        if (stage == null) {
          continue;
        }
        const canHaveAccumulator = stage.$group || stage.$bucket || stage.$bucketAuto;
        if (canHaveAccumulator != null) {
          for (const key of Object.keys(canHaveAccumulator)) {
            handleAccumulator(canHaveAccumulator[key]);
          }
        }
        const stageType = Object.keys(stage)[0];
        if (stageType && typeof stage[stageType] === "object") {
          const stageOptions = stage[stageType];
          for (const key of Object.keys(stageOptions)) {
            if (stageOptions[key] != null && stageOptions[key].$function != null && typeof stageOptions[key].$function.body === "function") {
              stageOptions[key].$function.body = stageOptions[key].$function.body.toString();
            }
          }
        }
        if (stage.$facet != null) {
          for (const key of Object.keys(stage.$facet)) {
            stringifyFunctionOperators(stage.$facet[key]);
          }
        }
      }
    };
    function handleAccumulator(operator) {
      if (operator == null || operator.$accumulator == null) {
        return;
      }
      for (const key of ["init", "accumulate", "merge", "finalize"]) {
        if (typeof operator.$accumulator[key] === "function") {
          operator.$accumulator[key] = String(operator.$accumulator[key]);
        }
      }
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/aggregate.js
var require_aggregate = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/aggregate.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var AggregationCursor = require_AggregationCursor();
    var Query = require_query();
    var applyGlobalMaxTimeMS = require_applyGlobalMaxTimeMS();
    var getConstructorName = require_getConstructorName();
    var promiseOrCallback = require_promiseOrCallback();
    var stringifyFunctionOperators = require_stringifyFunctionOperators();
    var util2 = require("util");
    var utils = require_utils2();
    var read = Query.prototype.read;
    var readConcern = Query.prototype.readConcern;
    function Aggregate(pipeline) {
      this._pipeline = [];
      this._model = void 0;
      this.options = {};
      if (arguments.length === 1 && util2.isArray(pipeline)) {
        this.append.apply(this, pipeline);
      }
    }
    Aggregate.prototype.options;
    Aggregate.prototype.model = function(model) {
      if (arguments.length === 0) {
        return this._model;
      }
      this._model = model;
      if (model.schema != null) {
        if (this.options.readPreference == null && model.schema.options.read != null) {
          this.options.readPreference = model.schema.options.read;
        }
        if (this.options.collation == null && model.schema.options.collation != null) {
          this.options.collation = model.schema.options.collation;
        }
      }
      return this;
    };
    Aggregate.prototype.append = function() {
      const args = arguments.length === 1 && util2.isArray(arguments[0]) ? arguments[0] : utils.args(arguments);
      if (!args.every(isOperator)) {
        throw new Error("Arguments must be aggregate pipeline operators");
      }
      this._pipeline = this._pipeline.concat(args);
      return this;
    };
    Aggregate.prototype.addFields = function(arg) {
      const fields = {};
      if (typeof arg === "object" && !util2.isArray(arg)) {
        Object.keys(arg).forEach(function(field) {
          fields[field] = arg[field];
        });
      } else {
        throw new Error("Invalid addFields() argument. Must be an object");
      }
      return this.append({ $addFields: fields });
    };
    Aggregate.prototype.project = function(arg) {
      const fields = {};
      if (typeof arg === "object" && !util2.isArray(arg)) {
        Object.keys(arg).forEach(function(field) {
          fields[field] = arg[field];
        });
      } else if (arguments.length === 1 && typeof arg === "string") {
        arg.split(/\s+/).forEach(function(field) {
          if (!field) {
            return;
          }
          const include = field[0] === "-" ? 0 : 1;
          if (include === 0) {
            field = field.substring(1);
          }
          fields[field] = include;
        });
      } else {
        throw new Error("Invalid project() argument. Must be string or object");
      }
      return this.append({ $project: fields });
    };
    Aggregate.prototype.near = function(arg) {
      const op = {};
      op.$geoNear = arg;
      return this.append(op);
    };
    "group match skip limit out".split(" ").forEach(function($operator) {
      Aggregate.prototype[$operator] = function(arg) {
        const op = {};
        op["$" + $operator] = arg;
        return this.append(op);
      };
    });
    Aggregate.prototype.unwind = function() {
      const args = utils.args(arguments);
      const res = [];
      for (const arg of args) {
        if (arg && typeof arg === "object") {
          res.push({ $unwind: arg });
        } else if (typeof arg === "string") {
          res.push({
            $unwind: arg && arg.startsWith("$") ? arg : "$" + arg
          });
        } else {
          throw new Error('Invalid arg "' + arg + '" to unwind(), must be string or object');
        }
      }
      return this.append.apply(this, res);
    };
    Aggregate.prototype.replaceRoot = function(newRoot) {
      let ret2;
      if (typeof newRoot === "string") {
        ret2 = newRoot.startsWith("$") ? newRoot : "$" + newRoot;
      } else {
        ret2 = newRoot;
      }
      return this.append({
        $replaceRoot: {
          newRoot: ret2
        }
      });
    };
    Aggregate.prototype.count = function(countName) {
      return this.append({ $count: countName });
    };
    Aggregate.prototype.sortByCount = function(arg) {
      if (arg && typeof arg === "object") {
        return this.append({ $sortByCount: arg });
      } else if (typeof arg === "string") {
        return this.append({
          $sortByCount: arg && arg.startsWith("$") ? arg : "$" + arg
        });
      } else {
        throw new TypeError('Invalid arg "' + arg + '" to sortByCount(), must be string or object');
      }
    };
    Aggregate.prototype.lookup = function(options) {
      return this.append({ $lookup: options });
    };
    Aggregate.prototype.graphLookup = function(options) {
      const cloneOptions = {};
      if (options) {
        if (!utils.isObject(options)) {
          throw new TypeError("Invalid graphLookup() argument. Must be an object.");
        }
        utils.mergeClone(cloneOptions, options);
        const startWith = cloneOptions.startWith;
        if (startWith && typeof startWith === "string") {
          cloneOptions.startWith = cloneOptions.startWith.startsWith("$") ? cloneOptions.startWith : "$" + cloneOptions.startWith;
        }
      }
      return this.append({ $graphLookup: cloneOptions });
    };
    Aggregate.prototype.sample = function(size) {
      return this.append({ $sample: { size } });
    };
    Aggregate.prototype.sort = function(arg) {
      const sort = {};
      if (getConstructorName(arg) === "Object") {
        const desc = ["desc", "descending", -1];
        Object.keys(arg).forEach(function(field) {
          if (arg[field] instanceof Object && arg[field].$meta) {
            sort[field] = arg[field];
            return;
          }
          sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
        });
      } else if (arguments.length === 1 && typeof arg === "string") {
        arg.split(/\s+/).forEach(function(field) {
          if (!field) {
            return;
          }
          const ascend = field[0] === "-" ? -1 : 1;
          if (ascend === -1) {
            field = field.substring(1);
          }
          sort[field] = ascend;
        });
      } else {
        throw new TypeError("Invalid sort() argument. Must be a string or object.");
      }
      return this.append({ $sort: sort });
    };
    Aggregate.prototype.read = function(pref, tags) {
      if (!this.options) {
        this.options = {};
      }
      read.call(this, pref, tags);
      return this;
    };
    Aggregate.prototype.readConcern = function(level) {
      if (!this.options) {
        this.options = {};
      }
      readConcern.call(this, level);
      return this;
    };
    Aggregate.prototype.redact = function(expression, thenExpr, elseExpr) {
      if (arguments.length === 3) {
        if (typeof thenExpr === "string" && !thenExpr.startsWith("$$") || typeof elseExpr === "string" && !elseExpr.startsWith("$$")) {
          throw new Error("If thenExpr or elseExpr is string, it must start with $$. e.g. $$DESCEND, $$PRUNE, $$KEEP");
        }
        expression = {
          $cond: {
            if: expression,
            then: thenExpr,
            else: elseExpr
          }
        };
      } else if (arguments.length !== 1) {
        throw new TypeError("Invalid arguments");
      }
      return this.append({ $redact: expression });
    };
    Aggregate.prototype.explain = function(callback) {
      const model = this._model;
      return promiseOrCallback(callback, (cb) => {
        if (!this._pipeline.length) {
          const err = new Error("Aggregate has empty pipeline");
          return cb(err);
        }
        prepareDiscriminatorPipeline(this);
        model.hooks.execPre("aggregate", this, (error) => {
          if (error) {
            const _opts = { error };
            return model.hooks.execPost("aggregate", this, [null], _opts, (error2) => {
              cb(error2);
            });
          }
          this.options.explain = true;
          model.collection.aggregate(this._pipeline, this.options || {}).explain((error2, result) => {
            const _opts = { error: error2 };
            return model.hooks.execPost("aggregate", this, [result], _opts, (error3) => {
              if (error3) {
                return cb(error3);
              }
              return cb(null, result);
            });
          });
        });
      }, model.events);
    };
    Aggregate.prototype.allowDiskUse = function(value) {
      this.options.allowDiskUse = value;
      return this;
    };
    Aggregate.prototype.hint = function(value) {
      this.options.hint = value;
      return this;
    };
    Aggregate.prototype.session = function(session) {
      if (session == null) {
        delete this.options.session;
      } else {
        this.options.session = session;
      }
      return this;
    };
    Aggregate.prototype.option = function(value) {
      for (const key in value) {
        this.options[key] = value[key];
      }
      return this;
    };
    Aggregate.prototype.cursor = function(options) {
      if (!this.options) {
        this.options = {};
      }
      this.options.cursor = options || {};
      return this;
    };
    Aggregate.prototype.addCursorFlag = util2.deprecate(function(flag, value) {
      if (!this.options) {
        this.options = {};
      }
      this.options[flag] = value;
      return this;
    }, "Mongoose: `Aggregate#addCursorFlag()` is deprecated, use `option()` instead");
    Aggregate.prototype.collation = function(collation) {
      if (!this.options) {
        this.options = {};
      }
      this.options.collation = collation;
      return this;
    };
    Aggregate.prototype.facet = function(options) {
      return this.append({ $facet: options });
    };
    Aggregate.prototype.search = function(options) {
      return this.append({ $search: options });
    };
    Aggregate.prototype.pipeline = function() {
      return this._pipeline;
    };
    Aggregate.prototype.exec = function(callback) {
      if (!this._model) {
        throw new Error("Aggregate not bound to any Model");
      }
      const model = this._model;
      const collection = this._model.collection;
      applyGlobalMaxTimeMS(this.options, model);
      if (this.options && this.options.cursor) {
        return new AggregationCursor(this);
      }
      return promiseOrCallback(callback, (cb) => {
        prepareDiscriminatorPipeline(this);
        stringifyFunctionOperators(this._pipeline);
        model.hooks.execPre("aggregate", this, (error) => {
          if (error) {
            const _opts = { error };
            return model.hooks.execPost("aggregate", this, [null], _opts, (error2) => {
              cb(error2);
            });
          }
          if (!this._pipeline.length) {
            return cb(new Error("Aggregate has empty pipeline"));
          }
          const options = utils.clone(this.options || {});
          collection.aggregate(this._pipeline, options, (error2, cursor) => {
            if (error2) {
              const _opts = { error: error2 };
              return model.hooks.execPost("aggregate", this, [null], _opts, (error3) => {
                if (error3) {
                  return cb(error3);
                }
                return cb(null);
              });
            }
            cursor.toArray((error3, result) => {
              const _opts = { error: error3 };
              model.hooks.execPost("aggregate", this, [result], _opts, (error4, result2) => {
                if (error4) {
                  return cb(error4);
                }
                cb(null, result2);
              });
            });
          });
        });
      }, model.events);
    };
    Aggregate.prototype.then = function(resolve, reject) {
      return this.exec().then(resolve, reject);
    };
    Aggregate.prototype.catch = function(reject) {
      return this.exec().then(null, reject);
    };
    if (Symbol.asyncIterator != null) {
      Aggregate.prototype[Symbol.asyncIterator] = function() {
        return this.cursor({ useMongooseAggCursor: true }).exec().transformNull()._transformForAsyncIterator();
      };
    }
    function isOperator(obj2) {
      if (typeof obj2 !== "object") {
        return false;
      }
      const k = Object.keys(obj2);
      return k.length === 1 && k.some((key) => {
        return key[0] === "$";
      });
    }
    Aggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;
    function prepareDiscriminatorPipeline(aggregate) {
      const schema = aggregate._model.schema;
      const discriminatorMapping = schema && schema.discriminatorMapping;
      if (discriminatorMapping && !discriminatorMapping.isRoot) {
        const originalPipeline = aggregate._pipeline;
        const discriminatorKey = discriminatorMapping.key;
        const discriminatorValue = discriminatorMapping.value;
        if (originalPipeline[0] && originalPipeline[0].$match && !originalPipeline[0].$match[discriminatorKey]) {
          originalPipeline[0].$match[discriminatorKey] = discriminatorValue;
        } else if (originalPipeline[0] && originalPipeline[0].$geoNear) {
          originalPipeline[0].$geoNear.query = originalPipeline[0].$geoNear.query || {};
          originalPipeline[0].$geoNear.query[discriminatorKey] = discriminatorValue;
        } else if (originalPipeline[0] && originalPipeline[0].$search) {
          if (originalPipeline[1] && originalPipeline[1].$match != null) {
            originalPipeline[1].$match[discriminatorKey] = originalPipeline[1].$match[discriminatorKey] || discriminatorValue;
          } else {
            const match = {};
            match[discriminatorKey] = discriminatorValue;
            originalPipeline.splice(1, 0, { $match: match });
          }
        } else {
          const match = {};
          match[discriminatorKey] = discriminatorValue;
          aggregate._pipeline.unshift({ $match: match });
        }
      }
    }
    module2.exports = Aggregate;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/removeOptions.js
var require_removeOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/removeOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var clone = require_clone();
    var RemoveOptions = class {
      constructor(obj2) {
        if (obj2 == null) {
          return;
        }
        Object.assign(this, clone(obj2));
      }
    };
    module2.exports = RemoveOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/saveOptions.js
var require_saveOptions = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/options/saveOptions.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var clone = require_clone();
    var SaveOptions = class {
      constructor(obj2) {
        if (obj2 == null) {
          return;
        }
        Object.assign(this, clone(obj2));
      }
    };
    module2.exports = SaveOptions;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/model/applyMethods.js
var require_applyMethods = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/model/applyMethods.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var get = require_get();
    module2.exports = function applyMethods(model, schema) {
      function apply(method, schema2) {
        Object.defineProperty(model.prototype, method, {
          get: function() {
            const h = {};
            for (const k in schema2.methods[method]) {
              h[k] = schema2.methods[method][k].bind(this);
            }
            return h;
          },
          configurable: true
        });
      }
      for (const method of Object.keys(schema.methods)) {
        const fn = schema.methods[method];
        if (schema.tree.hasOwnProperty(method)) {
          throw new Error('You have a method and a property in your schema both named "' + method + '"');
        }
        if (schema.reserved[method] && !get(schema, `methodOptions.${method}.suppressWarning`, false)) {
          console.warn(`mongoose: the method name "${method}" is used by mongoose internally, overwriting it may cause bugs. If you're sure you know what you're doing, you can suppress this error by using \`schema.method('${method}', fn, { suppressWarning: true })\`.`);
        }
        if (typeof fn === "function") {
          model.prototype[method] = fn;
        } else {
          apply(method, schema);
        }
      }
      model.$appliedMethods = true;
      for (const key of Object.keys(schema.paths)) {
        const type = schema.paths[key];
        if (type.$isSingleNested && !type.caster.$appliedMethods) {
          applyMethods(type.caster, type.schema);
        }
        if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {
          applyMethods(type.Constructor, type.schema);
        }
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js
var require_applyStaticHooks = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var middlewareFunctions = require_applyQueryMiddleware().middlewareFunctions;
    var promiseOrCallback = require_promiseOrCallback();
    module2.exports = function applyStaticHooks(model, hooks, statics) {
      const kareemOptions = {
        useErrorHandlers: true,
        numCallbackParams: 1
      };
      hooks = hooks.filter((hook) => {
        if (middlewareFunctions.indexOf(hook.name) !== -1) {
          return !!hook.model;
        }
        return hook.model !== false;
      });
      model.$__insertMany = hooks.createWrapper(
        "insertMany",
        model.$__insertMany,
        model,
        kareemOptions
      );
      for (const key of Object.keys(statics)) {
        if (hooks.hasHooks(key)) {
          const original = model[key];
          model[key] = function() {
            const numArgs = arguments.length;
            const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;
            const cb = typeof lastArg === "function" ? lastArg : null;
            const args = Array.prototype.slice.call(arguments, 0, cb == null ? numArgs : numArgs - 1);
            return promiseOrCallback(cb, (callback) => {
              hooks.execPre(key, model, args, function(err) {
                if (err != null) {
                  return callback(err);
                }
                let postCalled = 0;
                const ret2 = original.apply(model, args.concat(post));
                if (ret2 != null && typeof ret2.then === "function") {
                  ret2.then((res) => post(null, res), (err2) => post(err2));
                }
                function post(error, res) {
                  if (postCalled++ > 0) {
                    return;
                  }
                  if (error != null) {
                    return callback(error);
                  }
                  hooks.execPost(key, model, [res], function(error2) {
                    if (error2 != null) {
                      return callback(error2);
                    }
                    callback(null, res);
                  });
                }
              });
            }, model.events);
          };
        }
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/model/applyStatics.js
var require_applyStatics = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/model/applyStatics.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function applyStatics(model, schema) {
      for (const i in schema.statics) {
        model[i] = schema.statics[i];
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js
var require_SkipPopulateValue = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/SkipPopulateValue.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function SkipPopulateValue(val) {
      if (!(this instanceof SkipPopulateValue)) {
        return new SkipPopulateValue(val);
      }
      this.val = val;
      return this;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js
var require_leanPopulateMap = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js
var require_assignRawDocsToIdStructure = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var leanPopulateMap = require_leanPopulateMap();
    var modelSymbol = require_symbols().modelSymbol;
    var utils = require_utils2();
    module2.exports = assignRawDocsToIdStructure;
    function assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {
      const newOrder = [];
      const sorting = options.sort && rawIds.length > 1;
      const nullIfNotFound = options.$nullIfNotFound;
      let doc;
      let sid;
      let id;
      for (let i = 0; i < rawIds.length; ++i) {
        id = rawIds[i];
        if (Array.isArray(id)) {
          assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);
          newOrder.push(id);
          continue;
        }
        if (id === null && !sorting) {
          newOrder.push(id);
          continue;
        }
        sid = String(id);
        doc = resultDocs[sid];
        if (options.clone && doc != null) {
          if (options.lean) {
            const _model = leanPopulateMap.get(doc);
            doc = utils.clone(doc);
            leanPopulateMap.set(doc, _model);
          } else {
            doc = doc.constructor.hydrate(doc._doc);
          }
        }
        if (recursed) {
          if (doc) {
            if (sorting) {
              const _resultOrder = resultOrder[sid];
              if (Array.isArray(_resultOrder) && Array.isArray(doc) && _resultOrder.length === doc.length) {
                newOrder.push(doc);
              } else {
                newOrder[_resultOrder] = doc;
              }
            } else {
              newOrder.push(doc);
            }
          } else if (id != null && id[modelSymbol] != null) {
            newOrder.push(id);
          } else {
            newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);
          }
        } else {
          newOrder[i] = doc || null;
        }
      }
      rawIds.length = 0;
      if (newOrder.length) {
        newOrder.forEach(function(doc2, i) {
          rawIds[i] = doc2;
        });
      }
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/getVirtual.js
var require_getVirtual = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/getVirtual.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = getVirtual;
    function getVirtual(schema, name) {
      if (schema.virtuals[name]) {
        return { virtual: schema.virtuals[name], path: void 0 };
      }
      const parts = name.split(".");
      let cur = "";
      let nestedSchemaPath = "";
      for (let i = 0; i < parts.length; ++i) {
        cur += (cur.length > 0 ? "." : "") + parts[i];
        if (schema.virtuals[cur]) {
          if (i === parts.length - 1) {
            return { virtual: schema.virtuals[cur], path: nestedSchemaPath };
          }
          continue;
        }
        if (schema.nested[cur]) {
          continue;
        }
        if (schema.paths[cur] && schema.paths[cur].schema) {
          schema = schema.paths[cur].schema;
          const rest = parts.slice(i + 1).join(".");
          if (schema.virtuals[rest]) {
            if (i === parts.length - 2) {
              return {
                virtual: schema.virtuals[rest],
                nestedSchemaPath: [nestedSchemaPath, cur].filter((v) => !!v).join(".")
              };
            }
            continue;
          }
          if (i + 1 < parts.length && schema.discriminators) {
            for (const key of Object.keys(schema.discriminators)) {
              const res = getVirtual(schema.discriminators[key], rest);
              if (res != null) {
                const _path = [nestedSchemaPath, cur, res.nestedSchemaPath].filter((v) => !!v).join(".");
                return {
                  virtual: res.virtual,
                  nestedSchemaPath: _path
                };
              }
            }
          }
          nestedSchemaPath += (nestedSchemaPath.length > 0 ? "." : "") + cur;
          cur = "";
          continue;
        }
        if (schema.discriminators) {
          for (const discriminatorKey of Object.keys(schema.discriminators)) {
            const virtualFromDiscriminator = getVirtual(schema.discriminators[discriminatorKey], name);
            if (virtualFromDiscriminator)
              return virtualFromDiscriminator;
          }
        }
        return null;
      }
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js
var require_lookupLocalFields = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function lookupLocalFields(cur, path3, val) {
      if (cur == null) {
        return cur;
      }
      if (cur._doc != null) {
        cur = cur._doc;
      }
      if (arguments.length >= 3) {
        if (typeof cur !== "object") {
          return void 0;
        }
        if (val === void 0) {
          return void 0;
        }
        cur[path3] = val;
        return val;
      }
      if (path3 === "$*") {
        return cur instanceof Map ? Array.from(cur.values()) : Object.keys(cur).map((key) => cur[key]);
      }
      return cur[path3];
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+sift@13.5.2/node_modules/sift/es5m/index.js
var es5m_exports = {};
__export(es5m_exports, {
  $Size: () => $Size,
  $all: () => $all,
  $and: () => $and,
  $elemMatch: () => $elemMatch,
  $eq: () => $eq,
  $exists: () => $exists,
  $gt: () => $gt,
  $gte: () => $gte,
  $in: () => $in,
  $lt: () => $lt,
  $lte: () => $lte,
  $mod: () => $mod,
  $ne: () => $ne,
  $nin: () => $nin,
  $nor: () => $nor,
  $not: () => $not,
  $options: () => $options,
  $or: () => $or,
  $regex: () => $regex,
  $size: () => $size,
  $type: () => $type,
  $where: () => $where,
  EqualsOperation: () => EqualsOperation,
  createDefaultQueryOperation: () => createDefaultQueryOperation,
  createEqualsOperation: () => createEqualsOperation,
  createOperationTester: () => createOperationTester,
  createQueryOperation: () => createQueryOperation,
  createQueryTester: () => createQueryTester,
  default: () => es5m_default
});
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var extendStatics, typeChecker, getClassName, comparable, isArray, isObject2, isFunction, isVanillaObject, equals, walkKeyPathValues, BaseOperation, NamedBaseOperation, GroupOperation, NamedGroupOperation, QueryOperation, NestedOperation, createTester, EqualsOperation, createEqualsOperation, NopeOperation, numericalOperationCreator, numericalOperation, createNamedOperation, containsOperation, createNestedOperation, createQueryOperation, createQueryOperations, createOperationTester, createQueryTester, $Ne, $ElemMatch, $Not, $Size, $Or, $Nor, $In, $Nin, $Exists, $And, $eq, $ne, $or, $nor, $elemMatch, $nin, $in, $lt, $lte, $gt, $gte, $mod, $exists, $regex, $not, typeAliases, $type, $and, $all, $size, $options, $where, defaultOperations, createDefaultQueryOperation, createDefaultQueryTester, es5m_default;
var init_es5m = __esm({
  "node_modules/.pnpm/registry.npmmirror.com+sift@13.5.2/node_modules/sift/es5m/index.js"() {
    init_cjs_shims();
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    typeChecker = function(type) {
      var typeString = "[object " + type + "]";
      return function(value) {
        return getClassName(value) === typeString;
      };
    };
    getClassName = function(value) {
      return Object.prototype.toString.call(value);
    };
    comparable = function(value) {
      if (value instanceof Date) {
        return value.getTime();
      } else if (isArray(value)) {
        return value.map(comparable);
      } else if (value && typeof value.toJSON === "function") {
        return value.toJSON();
      }
      return value;
    };
    isArray = typeChecker("Array");
    isObject2 = typeChecker("Object");
    isFunction = typeChecker("Function");
    isVanillaObject = function(value) {
      return value && (value.constructor === Object || value.constructor === Array || value.constructor.toString() === "function Object() { [native code] }" || value.constructor.toString() === "function Array() { [native code] }") && !value.toJSON;
    };
    equals = function(a, b) {
      if (a == null && a == b) {
        return true;
      }
      if (a === b) {
        return true;
      }
      if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {
        return false;
      }
      if (isArray(a)) {
        if (a.length !== b.length) {
          return false;
        }
        for (var i = 0, length_1 = a.length; i < length_1; i++) {
          if (!equals(a[i], b[i]))
            return false;
        }
        return true;
      } else if (isObject2(a)) {
        if (Object.keys(a).length !== Object.keys(b).length) {
          return false;
        }
        for (var key in a) {
          if (!equals(a[key], b[key]))
            return false;
        }
        return true;
      }
      return false;
    };
    walkKeyPathValues = function(item, keyPath, next, depth, key, owner) {
      var currentKey = keyPath[depth];
      if (isArray(item) && isNaN(Number(currentKey))) {
        for (var i = 0, length_1 = item.length; i < length_1; i++) {
          if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {
            return false;
          }
        }
      }
      if (depth === keyPath.length || item == null) {
        return next(item, key, owner);
      }
      return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);
    };
    BaseOperation = /** @class */
    function() {
      function BaseOperation2(params, owneryQuery, options) {
        this.params = params;
        this.owneryQuery = owneryQuery;
        this.options = options;
        this.init();
      }
      BaseOperation2.prototype.init = function() {
      };
      BaseOperation2.prototype.reset = function() {
        this.done = false;
        this.keep = false;
      };
      return BaseOperation2;
    }();
    NamedBaseOperation = /** @class */
    function(_super) {
      __extends(NamedBaseOperation2, _super);
      function NamedBaseOperation2(params, owneryQuery, options, name) {
        var _this = _super.call(this, params, owneryQuery, options) || this;
        _this.name = name;
        return _this;
      }
      return NamedBaseOperation2;
    }(BaseOperation);
    GroupOperation = /** @class */
    function(_super) {
      __extends(GroupOperation2, _super);
      function GroupOperation2(params, owneryQuery, options, children) {
        var _this = _super.call(this, params, owneryQuery, options) || this;
        _this.children = children;
        return _this;
      }
      GroupOperation2.prototype.reset = function() {
        this.keep = false;
        this.done = false;
        for (var i = 0, length_2 = this.children.length; i < length_2; i++) {
          this.children[i].reset();
        }
      };
      GroupOperation2.prototype.childrenNext = function(item, key, owner) {
        var done = true;
        var keep = true;
        for (var i = 0, length_3 = this.children.length; i < length_3; i++) {
          var childOperation = this.children[i];
          childOperation.next(item, key, owner);
          if (!childOperation.keep) {
            keep = false;
          }
          if (childOperation.done) {
            if (!childOperation.keep) {
              break;
            }
          } else {
            done = false;
          }
        }
        this.done = done;
        this.keep = keep;
      };
      return GroupOperation2;
    }(BaseOperation);
    NamedGroupOperation = /** @class */
    function(_super) {
      __extends(NamedGroupOperation2, _super);
      function NamedGroupOperation2(params, owneryQuery, options, children, name) {
        var _this = _super.call(this, params, owneryQuery, options, children) || this;
        _this.name = name;
        return _this;
      }
      return NamedGroupOperation2;
    }(GroupOperation);
    QueryOperation = /** @class */
    function(_super) {
      __extends(QueryOperation2, _super);
      function QueryOperation2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      QueryOperation2.prototype.next = function(item, key, parent) {
        this.childrenNext(item, key, parent);
      };
      return QueryOperation2;
    }(GroupOperation);
    NestedOperation = /** @class */
    function(_super) {
      __extends(NestedOperation2, _super);
      function NestedOperation2(keyPath, params, owneryQuery, options, children) {
        var _this = _super.call(this, params, owneryQuery, options, children) || this;
        _this.keyPath = keyPath;
        _this._nextNestedValue = function(value, key, owner) {
          _this.childrenNext(value, key, owner);
          return !_this.done;
        };
        return _this;
      }
      NestedOperation2.prototype.next = function(item, key, parent) {
        walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);
      };
      return NestedOperation2;
    }(GroupOperation);
    createTester = function(a, compare) {
      if (a instanceof Function) {
        return a;
      }
      if (a instanceof RegExp) {
        return function(b) {
          var result = typeof b === "string" && a.test(b);
          a.lastIndex = 0;
          return result;
        };
      }
      var comparableA = comparable(a);
      return function(b) {
        return compare(comparableA, comparable(b));
      };
    };
    EqualsOperation = /** @class */
    function(_super) {
      __extends(EqualsOperation2, _super);
      function EqualsOperation2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      EqualsOperation2.prototype.init = function() {
        this._test = createTester(this.params, this.options.compare);
      };
      EqualsOperation2.prototype.next = function(item, key, parent) {
        if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {
          if (this._test(item, key, parent)) {
            this.done = true;
            this.keep = true;
          }
        }
      };
      return EqualsOperation2;
    }(BaseOperation);
    createEqualsOperation = function(params, owneryQuery, options) {
      return new EqualsOperation(params, owneryQuery, options);
    };
    NopeOperation = /** @class */
    function(_super) {
      __extends(NopeOperation2, _super);
      function NopeOperation2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NopeOperation2.prototype.next = function() {
        this.done = true;
        this.keep = false;
      };
      return NopeOperation2;
    }(BaseOperation);
    numericalOperationCreator = function(createNumericalOperation) {
      return function(params, owneryQuery, options, name) {
        if (params == null) {
          return new NopeOperation(params, owneryQuery, options);
        }
        return createNumericalOperation(params, owneryQuery, options, name);
      };
    };
    numericalOperation = function(createTester2) {
      return numericalOperationCreator(function(params, owneryQuery, options) {
        var typeofParams = typeof comparable(params);
        var test = createTester2(params);
        return new EqualsOperation(function(b) {
          return typeof comparable(b) === typeofParams && test(b);
        }, owneryQuery, options);
      });
    };
    createNamedOperation = function(name, params, parentQuery, options) {
      var operationCreator = options.operations[name];
      if (!operationCreator) {
        throw new Error("Unsupported operation: " + name);
      }
      return operationCreator(params, parentQuery, options, name);
    };
    containsOperation = function(query) {
      for (var key in query) {
        if (key.charAt(0) === "$")
          return true;
      }
      return false;
    };
    createNestedOperation = function(keyPath, nestedQuery, owneryQuery, options) {
      if (containsOperation(nestedQuery)) {
        var _a = createQueryOperations(nestedQuery, options), selfOperations = _a[0], nestedOperations = _a[1];
        if (nestedOperations.length) {
          throw new Error("Property queries must contain only operations, or exact objects.");
        }
        return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, selfOperations);
      }
      return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [
        new EqualsOperation(nestedQuery, owneryQuery, options)
      ]);
    };
    createQueryOperation = function(query, owneryQuery, _a) {
      if (owneryQuery === void 0) {
        owneryQuery = null;
      }
      var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;
      var options = {
        compare: compare || equals,
        operations: Object.assign({}, operations || {})
      };
      var _c = createQueryOperations(query, options), selfOperations = _c[0], nestedOperations = _c[1];
      var ops = [];
      if (selfOperations.length) {
        ops.push(new NestedOperation([], query, owneryQuery, options, selfOperations));
      }
      ops.push.apply(ops, nestedOperations);
      if (ops.length === 1) {
        return ops[0];
      }
      return new QueryOperation(query, owneryQuery, options, ops);
    };
    createQueryOperations = function(query, options) {
      var selfOperations = [];
      var nestedOperations = [];
      if (!isVanillaObject(query)) {
        selfOperations.push(new EqualsOperation(query, query, options));
        return [selfOperations, nestedOperations];
      }
      for (var key in query) {
        if (key.charAt(0) === "$") {
          var op = createNamedOperation(key, query[key], query, options);
          if (op != null) {
            selfOperations.push(op);
          }
        } else {
          nestedOperations.push(createNestedOperation(key.split("."), query[key], query, options));
        }
      }
      return [selfOperations, nestedOperations];
    };
    createOperationTester = function(operation) {
      return function(item, key, owner) {
        operation.reset();
        operation.next(item, key, owner);
        return operation.keep;
      };
    };
    createQueryTester = function(query, options) {
      if (options === void 0) {
        options = {};
      }
      return createOperationTester(createQueryOperation(query, null, options));
    };
    $Ne = /** @class */
    function(_super) {
      __extends($Ne2, _super);
      function $Ne2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      $Ne2.prototype.init = function() {
        this._test = createTester(this.params, this.options.compare);
      };
      $Ne2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this.keep = true;
      };
      $Ne2.prototype.next = function(item) {
        if (this._test(item)) {
          this.done = true;
          this.keep = false;
        }
      };
      return $Ne2;
    }(NamedBaseOperation);
    $ElemMatch = /** @class */
    function(_super) {
      __extends($ElemMatch2, _super);
      function $ElemMatch2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      $ElemMatch2.prototype.init = function() {
        this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
      };
      $ElemMatch2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this._queryOperation.reset();
      };
      $ElemMatch2.prototype.next = function(item) {
        if (isArray(item)) {
          for (var i = 0, length_1 = item.length; i < length_1; i++) {
            this._queryOperation.reset();
            this._queryOperation.next(item[i], i, item);
            this.keep = this.keep || this._queryOperation.keep;
          }
          this.done = true;
        } else {
          this.done = false;
          this.keep = false;
        }
      };
      return $ElemMatch2;
    }(NamedBaseOperation);
    $Not = /** @class */
    function(_super) {
      __extends($Not2, _super);
      function $Not2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      $Not2.prototype.init = function() {
        this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
      };
      $Not2.prototype.reset = function() {
        this._queryOperation.reset();
      };
      $Not2.prototype.next = function(item, key, owner) {
        this._queryOperation.next(item, key, owner);
        this.done = this._queryOperation.done;
        this.keep = !this._queryOperation.keep;
      };
      return $Not2;
    }(NamedBaseOperation);
    $Size = /** @class */
    function(_super) {
      __extends($Size2, _super);
      function $Size2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      $Size2.prototype.init = function() {
      };
      $Size2.prototype.next = function(item) {
        if (isArray(item) && item.length === this.params) {
          this.done = true;
          this.keep = true;
        }
      };
      return $Size2;
    }(NamedBaseOperation);
    $Or = /** @class */
    function(_super) {
      __extends($Or2, _super);
      function $Or2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      $Or2.prototype.init = function() {
        var _this = this;
        this._ops = this.params.map(function(op) {
          return createQueryOperation(op, null, _this.options);
        });
      };
      $Or2.prototype.reset = function() {
        this.done = false;
        this.keep = false;
        for (var i = 0, length_2 = this._ops.length; i < length_2; i++) {
          this._ops[i].reset();
        }
      };
      $Or2.prototype.next = function(item, key, owner) {
        var done = false;
        var success = false;
        for (var i = 0, length_3 = this._ops.length; i < length_3; i++) {
          var op = this._ops[i];
          op.next(item, key, owner);
          if (op.keep) {
            done = true;
            success = op.keep;
            break;
          }
        }
        this.keep = success;
        this.done = done;
      };
      return $Or2;
    }(NamedBaseOperation);
    $Nor = /** @class */
    function(_super) {
      __extends($Nor2, _super);
      function $Nor2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      $Nor2.prototype.next = function(item, key, owner) {
        _super.prototype.next.call(this, item, key, owner);
        this.keep = !this.keep;
      };
      return $Nor2;
    }($Or);
    $In = /** @class */
    function(_super) {
      __extends($In2, _super);
      function $In2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      $In2.prototype.init = function() {
        var _this = this;
        this._testers = this.params.map(function(value) {
          if (containsOperation(value)) {
            throw new Error("cannot nest $ under " + _this.constructor.name.toLowerCase());
          }
          return createTester(value, _this.options.compare);
        });
      };
      $In2.prototype.next = function(item, key, owner) {
        var done = false;
        var success = false;
        for (var i = 0, length_4 = this._testers.length; i < length_4; i++) {
          var test = this._testers[i];
          if (test(item)) {
            done = true;
            success = true;
            break;
          }
        }
        this.keep = success;
        this.done = done;
      };
      return $In2;
    }(NamedBaseOperation);
    $Nin = /** @class */
    function(_super) {
      __extends($Nin2, _super);
      function $Nin2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      $Nin2.prototype.next = function(item, key, owner) {
        _super.prototype.next.call(this, item, key, owner);
        this.keep = !this.keep;
      };
      return $Nin2;
    }($In);
    $Exists = /** @class */
    function(_super) {
      __extends($Exists2, _super);
      function $Exists2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      $Exists2.prototype.next = function(item, key, owner) {
        if (owner.hasOwnProperty(key) === this.params) {
          this.done = true;
          this.keep = true;
        }
      };
      return $Exists2;
    }(NamedBaseOperation);
    $And = /** @class */
    function(_super) {
      __extends($And2, _super);
      function $And2(params, owneryQuery, options, name) {
        return _super.call(this, params, owneryQuery, options, params.map(function(query) {
          return createQueryOperation(query, owneryQuery, options);
        }), name) || this;
      }
      $And2.prototype.next = function(item, key, owner) {
        this.childrenNext(item, key, owner);
      };
      return $And2;
    }(NamedGroupOperation);
    $eq = function(params, owneryQuery, options) {
      return new EqualsOperation(params, owneryQuery, options);
    };
    $ne = function(params, owneryQuery, options, name) {
      return new $Ne(params, owneryQuery, options, name);
    };
    $or = function(params, owneryQuery, options, name) {
      return new $Or(params, owneryQuery, options, name);
    };
    $nor = function(params, owneryQuery, options, name) {
      return new $Nor(params, owneryQuery, options, name);
    };
    $elemMatch = function(params, owneryQuery, options, name) {
      return new $ElemMatch(params, owneryQuery, options, name);
    };
    $nin = function(params, owneryQuery, options, name) {
      return new $Nin(params, owneryQuery, options, name);
    };
    $in = function(params, owneryQuery, options, name) {
      return new $In(params, owneryQuery, options, name);
    };
    $lt = numericalOperation(function(params) {
      return function(b) {
        return b < params;
      };
    });
    $lte = numericalOperation(function(params) {
      return function(b) {
        return b <= params;
      };
    });
    $gt = numericalOperation(function(params) {
      return function(b) {
        return b > params;
      };
    });
    $gte = numericalOperation(function(params) {
      return function(b) {
        return b >= params;
      };
    });
    $mod = function(_a, owneryQuery, options) {
      var mod = _a[0], equalsValue = _a[1];
      return new EqualsOperation(function(b) {
        return comparable(b) % mod === equalsValue;
      }, owneryQuery, options);
    };
    $exists = function(params, owneryQuery, options, name) {
      return new $Exists(params, owneryQuery, options, name);
    };
    $regex = function(pattern, owneryQuery, options) {
      return new EqualsOperation(new RegExp(pattern, owneryQuery.$options), owneryQuery, options);
    };
    $not = function(params, owneryQuery, options, name) {
      return new $Not(params, owneryQuery, options, name);
    };
    typeAliases = {
      number: function(v) {
        return typeof v === "number";
      },
      string: function(v) {
        return typeof v === "string";
      },
      bool: function(v) {
        return typeof v === "boolean";
      },
      array: function(v) {
        return Array.isArray(v);
      },
      null: function(v) {
        return v === null;
      },
      timestamp: function(v) {
        return v instanceof Date;
      }
    };
    $type = function(clazz, owneryQuery, options) {
      return new EqualsOperation(function(b) {
        if (typeof clazz === "string") {
          if (!typeAliases[clazz]) {
            throw new Error("Type alias does not exist");
          }
          return typeAliases[clazz](b);
        }
        return b != null ? b instanceof clazz || b.constructor === clazz : false;
      }, owneryQuery, options);
    };
    $and = function(params, ownerQuery, options, name) {
      return new $And(params, ownerQuery, options, name);
    };
    $all = $and;
    $size = function(params, ownerQuery, options) {
      return new $Size(params, ownerQuery, options, "$size");
    };
    $options = function() {
      return null;
    };
    $where = function(params, ownerQuery, options) {
      var test;
      if (isFunction(params)) {
        test = params;
      } else if (!process.env.CSP_ENABLED) {
        test = new Function("obj", "return " + params);
      } else {
        throw new Error('In CSP mode, sift does not support strings in "$where" condition');
      }
      return new EqualsOperation(function(b) {
        return test.bind(b)(b);
      }, ownerQuery, options);
    };
    defaultOperations = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      $Size,
      $eq,
      $ne,
      $or,
      $nor,
      $elemMatch,
      $nin,
      $in,
      $lt,
      $lte,
      $gt,
      $gte,
      $mod,
      $exists,
      $regex,
      $not,
      $type,
      $and,
      $all,
      $size,
      $options,
      $where
    });
    createDefaultQueryOperation = function(query, ownerQuery, _a) {
      var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;
      return createQueryOperation(query, ownerQuery, {
        compare,
        operations: Object.assign({}, defaultOperations, operations || {})
      });
    };
    createDefaultQueryTester = function(query, options) {
      if (options === void 0) {
        options = {};
      }
      var op = createDefaultQueryOperation(query, null, options);
      return createOperationTester(op);
    };
    es5m_default = createDefaultQueryTester;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/assignVals.js
var require_assignVals = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/assignVals.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SkipPopulateValue = require_SkipPopulateValue();
    var assignRawDocsToIdStructure = require_assignRawDocsToIdStructure();
    var get = require_get();
    var getVirtual = require_getVirtual();
    var leanPopulateMap = require_leanPopulateMap();
    var lookupLocalFields = require_lookupLocalFields();
    var mpath = require_mpath();
    var sift = (init_es5m(), __toCommonJS(es5m_exports)).default;
    var utils = require_utils2();
    module2.exports = function assignVals(o) {
      const userOptions = Object.assign({}, get(o, "allOptions.options.options"), get(o, "allOptions.options"));
      const populateOptions = Object.assign({}, o.options, userOptions, {
        justOne: o.justOne
      });
      populateOptions.$nullIfNotFound = o.isVirtual;
      const populatedModel = o.populatedModel;
      const originalIds = [].concat(o.rawIds);
      o.allIds = [].concat(o.allIds);
      assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);
      const docs = o.docs;
      const rawIds = o.rawIds;
      const options = o.options;
      const count = o.count && o.isVirtual;
      let i;
      function setValue(val) {
        if (count) {
          return val;
        }
        if (val instanceof SkipPopulateValue) {
          return val.val;
        }
        if (val === void 0) {
          return val;
        }
        const _allIds = o.allIds[i];
        if (o.justOne === true && Array.isArray(val)) {
          const ret2 = [];
          for (const doc of val) {
            const _docPopulatedModel = leanPopulateMap.get(doc);
            if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {
              ret2.push(doc);
            }
          }
          while (val.length > ret2.length) {
            Array.prototype.pop.apply(val, []);
          }
          for (let i2 = 0; i2 < ret2.length; ++i2) {
            val[i2] = ret2[i2];
          }
          return valueFilter(val[0], options, populateOptions, _allIds);
        } else if (o.justOne === false && !Array.isArray(val)) {
          return valueFilter([val], options, populateOptions, _allIds);
        }
        return valueFilter(val, options, populateOptions, _allIds);
      }
      for (i = 0; i < docs.length; ++i) {
        const _path = o.path.endsWith(".$*") ? o.path.slice(0, -3) : o.path;
        const existingVal = mpath.get(_path, docs[i], lookupLocalFields);
        if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {
          continue;
        }
        let valueToSet;
        if (count) {
          valueToSet = numDocs(rawIds[i]);
        } else if (Array.isArray(o.match)) {
          valueToSet = Array.isArray(rawIds[i]) ? rawIds[i].filter(sift(o.match[i])) : [rawIds[i]].filter(sift(o.match[i]))[0];
        } else {
          valueToSet = rawIds[i];
        }
        const originalSchema = o.originalModel.schema;
        const isDoc = get(docs[i], "$__", null) != null;
        let isMap = isDoc ? existingVal instanceof Map : utils.isPOJO(existingVal);
        isMap = isMap && get(originalSchema._getSchema(_path), "$isSchemaMap");
        if (!o.isVirtual && isMap) {
          const _keys = existingVal instanceof Map ? Array.from(existingVal.keys()) : Object.keys(existingVal);
          valueToSet = valueToSet.reduce((cur2, v, i2) => {
            cur2.set(_keys[i2], v);
            return cur2;
          }, /* @__PURE__ */ new Map());
        }
        if (isDoc && Array.isArray(valueToSet)) {
          for (const val of valueToSet) {
            if (val != null && val.$__ != null) {
              val.$__.parent = docs[i];
            }
          }
        } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {
          valueToSet.$__.parent = docs[i];
        }
        if (o.isVirtual && isDoc) {
          docs[i].populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);
          mpath.set(_path, valueToSet, docs[i], setValue);
          continue;
        }
        const parts = _path.split(".");
        let cur = docs[i];
        const curPath = parts[0];
        for (let j = 0; j < parts.length - 1; ++j) {
          if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {
            break;
          }
          if (parts[j] === "$*") {
            break;
          }
          if (cur[parts[j]] == null) {
            const schematype = originalSchema._getSchema(curPath);
            if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {
              break;
            }
            cur[parts[j]] = {};
          }
          cur = cur[parts[j]];
          if (typeof cur !== "object") {
            break;
          }
        }
        if (docs[i].$__) {
          docs[i].populated(_path, o.allIds[i], o.allOptions);
        }
        mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);
      }
    };
    function numDocs(v) {
      if (Array.isArray(v)) {
        if (v.some((el) => Array.isArray(el))) {
          return v.map((el) => numDocs(el));
        }
        return v.length;
      }
      return v == null ? 0 : 1;
    }
    function valueFilter(val, assignmentOpts, populateOptions, allIds) {
      const userSpecifiedTransform = typeof populateOptions.transform === "function";
      const transform = userSpecifiedTransform ? populateOptions.transform : noop;
      if (Array.isArray(val)) {
        const ret2 = [];
        const numValues = val.length;
        for (let i = 0; i < numValues; ++i) {
          let subdoc = val[i];
          const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;
          if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {
            continue;
          } else if (userSpecifiedTransform) {
            subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);
          }
          maybeRemoveId(subdoc, assignmentOpts);
          ret2.push(subdoc);
          if (assignmentOpts.originalLimit && ret2.length >= assignmentOpts.originalLimit) {
            break;
          }
        }
        while (val.length > ret2.length) {
          Array.prototype.pop.apply(val, []);
        }
        for (let i = 0; i < ret2.length; ++i) {
          val[i] = ret2[i];
        }
        return val;
      }
      if (isPopulatedObject(val) || utils.isPOJO(val)) {
        maybeRemoveId(val, assignmentOpts);
        return transform(val, allIds);
      }
      if (val instanceof Map) {
        return val;
      }
      if (populateOptions.justOne === false) {
        return [];
      }
      return val == null ? transform(val, allIds) : transform(null, allIds);
    }
    function maybeRemoveId(subdoc, assignmentOpts) {
      if (subdoc != null && assignmentOpts.excludeId) {
        if (typeof subdoc.$__setValue === "function") {
          delete subdoc._doc._id;
        } else {
          delete subdoc._id;
        }
      }
    }
    function isPopulatedObject(obj2) {
      if (obj2 == null) {
        return false;
      }
      return Array.isArray(obj2) || obj2.$isMongooseMap || obj2.$__ != null || leanPopulateMap.has(obj2);
    }
    function noop(v) {
      return v;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/model/castBulkWrite.js
var require_castBulkWrite = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/model/castBulkWrite.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var applyTimestampsToChildren = require_applyTimestampsToChildren();
    var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
    var cast = require_cast2();
    var castUpdate = require_castUpdate();
    var setDefaultsOnInsert = require_setDefaultsOnInsert();
    module2.exports = function castBulkWrite(originalModel, op, options) {
      const now = originalModel.base.now();
      if (op["insertOne"]) {
        return (callback) => {
          const model = decideModelByObject(originalModel, op["insertOne"]["document"]);
          const doc = new model(op["insertOne"]["document"]);
          if (model.schema.options.timestamps) {
            doc.initializeTimestamps();
          }
          if (options.session != null) {
            doc.$session(options.session);
          }
          op["insertOne"]["document"] = doc;
          op["insertOne"]["document"].validate({ __noPromise: true }, function(error) {
            if (error) {
              return callback(error, null);
            }
            callback(null);
          });
        };
      } else if (op["updateOne"]) {
        return (callback) => {
          try {
            if (!op["updateOne"]["filter"]) {
              throw new Error("Must provide a filter object.");
            }
            if (!op["updateOne"]["update"]) {
              throw new Error("Must provide an update object.");
            }
            const model = decideModelByObject(originalModel, op["updateOne"]["filter"]);
            const schema = model.schema;
            const strict = options.strict != null ? options.strict : model.schema.options.strict;
            _addDiscriminatorToObject(schema, op["updateOne"]["filter"]);
            if (model.schema.$timestamps != null && op["updateOne"].timestamps !== false) {
              const createdAt = model.schema.$timestamps.createdAt;
              const updatedAt = model.schema.$timestamps.updatedAt;
              applyTimestampsToUpdate(now, createdAt, updatedAt, op["updateOne"]["update"], {});
            }
            applyTimestampsToChildren(now, op["updateOne"]["update"], model.schema);
            if (op["updateOne"].setDefaultsOnInsert) {
              setDefaultsOnInsert(op["updateOne"]["filter"], model.schema, op["updateOne"]["update"], {
                setDefaultsOnInsert: true,
                upsert: op["updateOne"].upsert
              });
            }
            op["updateOne"]["filter"] = cast(model.schema, op["updateOne"]["filter"], {
              strict,
              upsert: op["updateOne"].upsert
            });
            op["updateOne"]["update"] = castUpdate(model.schema, op["updateOne"]["update"], {
              strict,
              overwrite: false,
              upsert: op["updateOne"].upsert
            }, model, op["updateOne"]["filter"]);
          } catch (error) {
            return callback(error, null);
          }
          callback(null);
        };
      } else if (op["updateMany"]) {
        return (callback) => {
          try {
            if (!op["updateMany"]["filter"]) {
              throw new Error("Must provide a filter object.");
            }
            if (!op["updateMany"]["update"]) {
              throw new Error("Must provide an update object.");
            }
            const model = decideModelByObject(originalModel, op["updateMany"]["filter"]);
            const schema = model.schema;
            const strict = options.strict != null ? options.strict : model.schema.options.strict;
            if (op["updateMany"].setDefaultsOnInsert) {
              setDefaultsOnInsert(op["updateMany"]["filter"], model.schema, op["updateMany"]["update"], {
                setDefaultsOnInsert: true,
                upsert: op["updateMany"].upsert
              });
            }
            if (model.schema.$timestamps != null && op["updateMany"].timestamps !== false) {
              const createdAt = model.schema.$timestamps.createdAt;
              const updatedAt = model.schema.$timestamps.updatedAt;
              applyTimestampsToUpdate(now, createdAt, updatedAt, op["updateMany"]["update"], {});
            }
            applyTimestampsToChildren(now, op["updateMany"]["update"], model.schema);
            _addDiscriminatorToObject(schema, op["updateMany"]["filter"]);
            op["updateMany"]["filter"] = cast(model.schema, op["updateMany"]["filter"], {
              strict,
              upsert: op["updateMany"].upsert
            });
            op["updateMany"]["update"] = castUpdate(model.schema, op["updateMany"]["update"], {
              strict,
              overwrite: false,
              upsert: op["updateMany"].upsert
            }, model, op["updateMany"]["filter"]);
          } catch (error) {
            return callback(error, null);
          }
          callback(null);
        };
      } else if (op["replaceOne"]) {
        return (callback) => {
          const model = decideModelByObject(originalModel, op["replaceOne"]["filter"]);
          const schema = model.schema;
          const strict = options.strict != null ? options.strict : model.schema.options.strict;
          _addDiscriminatorToObject(schema, op["replaceOne"]["filter"]);
          try {
            op["replaceOne"]["filter"] = cast(model.schema, op["replaceOne"]["filter"], {
              strict,
              upsert: op["replaceOne"].upsert
            });
          } catch (error) {
            return callback(error, null);
          }
          const doc = new model(op["replaceOne"]["replacement"], strict, true);
          if (model.schema.options.timestamps) {
            doc.initializeTimestamps();
          }
          if (options.session != null) {
            doc.$session(options.session);
          }
          op["replaceOne"]["replacement"] = doc;
          op["replaceOne"]["replacement"].validate({ __noPromise: true }, function(error) {
            if (error) {
              return callback(error, null);
            }
            op["replaceOne"]["replacement"] = op["replaceOne"]["replacement"].toBSON();
            callback(null);
          });
        };
      } else if (op["deleteOne"]) {
        return (callback) => {
          const model = decideModelByObject(originalModel, op["deleteOne"]["filter"]);
          const schema = model.schema;
          _addDiscriminatorToObject(schema, op["deleteOne"]["filter"]);
          try {
            op["deleteOne"]["filter"] = cast(
              model.schema,
              op["deleteOne"]["filter"]
            );
          } catch (error) {
            return callback(error, null);
          }
          callback(null);
        };
      } else if (op["deleteMany"]) {
        return (callback) => {
          const model = decideModelByObject(originalModel, op["deleteMany"]["filter"]);
          const schema = model.schema;
          _addDiscriminatorToObject(schema, op["deleteMany"]["filter"]);
          try {
            op["deleteMany"]["filter"] = cast(
              model.schema,
              op["deleteMany"]["filter"]
            );
          } catch (error) {
            return callback(error, null);
          }
          callback(null);
        };
      } else {
        return (callback) => {
          callback(new Error("Invalid op passed to `bulkWrite()`"), null);
        };
      }
    };
    function _addDiscriminatorToObject(schema, obj2) {
      if (schema == null) {
        return;
      }
      if (schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
        obj2[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
      }
    }
    function decideModelByObject(model, object) {
      const discriminatorKey = model.schema.options.discriminatorKey;
      if (object != null && object.hasOwnProperty(discriminatorKey)) {
        model = getDiscriminatorByValue(model.discriminators, object[discriminatorKey]) || model;
      }
      return model;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/path/parentPaths.js
var require_parentPaths = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/path/parentPaths.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function parentPaths(path3) {
      const pieces = path3.split(".");
      let cur = "";
      const ret2 = [];
      for (let i = 0; i < pieces.length; ++i) {
        cur += (cur.length > 0 ? "." : "") + pieces[i];
        ret2.push(cur);
      }
      return ret2;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js
var require_createPopulateQueryFilter = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var SkipPopulateValue = require_SkipPopulateValue();
    var parentPaths = require_parentPaths();
    module2.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {
      const match = _formatMatch(_match);
      if (_foreignField.size === 1) {
        const foreignField = Array.from(_foreignField)[0];
        const foreignSchemaType = model.schema.path(foreignField);
        if (foreignField !== "_id" || !match["_id"]) {
          ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
          match[foreignField] = { $in: ids };
        }
        const _parentPaths = parentPaths(foreignField);
        for (let i = 0; i < _parentPaths.length - 1; ++i) {
          const cur = _parentPaths[i];
          if (match[cur] != null && match[cur].$elemMatch != null) {
            match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = { $in: ids };
            delete match[foreignField];
            break;
          }
        }
      } else {
        const $or2 = [];
        if (Array.isArray(match.$or)) {
          match.$and = [{ $or: match.$or }, { $or: $or2 }];
          delete match.$or;
        } else {
          match.$or = $or2;
        }
        for (const foreignField of _foreignField) {
          if (foreignField !== "_id" || !match["_id"]) {
            const foreignSchemaType = model.schema.path(foreignField);
            ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
            $or2.push({ [foreignField]: { $in: ids } });
          }
        }
      }
      return match;
    };
    function _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {
      ids = ids.filter((v) => !(v instanceof SkipPopulateValue));
      if (!skipInvalidIds) {
        return ids;
      }
      return ids.filter((id) => {
        try {
          foreignSchemaType.cast(id);
          return true;
        } catch (err) {
          return false;
        }
      });
    }
    function _formatMatch(match) {
      if (Array.isArray(match)) {
        if (match.length > 1) {
          return { $or: [].concat(match.map((m) => Object.assign({}, m))) };
        }
        return Object.assign({}, match[0]);
      }
      return Object.assign({}, match);
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js
var require_getDefaultBulkwriteResult = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    function getDefaultBulkwriteResult() {
      return {
        result: {
          ok: 1,
          writeErrors: [],
          writeConcernErrors: [],
          insertedIds: [],
          nInserted: 0,
          nUpserted: 0,
          nMatched: 0,
          nModified: 0,
          nRemoved: 0,
          upserted: []
        },
        insertedCount: 0,
        matchedCount: 0,
        modifiedCount: 0,
        deletedCount: 0,
        upsertedCount: 0,
        upsertedIds: {},
        insertedIds: {},
        n: 0
      };
    }
    module2.exports = getDefaultBulkwriteResult;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/each.js
var require_each2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/each.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function each(arr, cb, done) {
      if (arr.length === 0) {
        return done();
      }
      let remaining = arr.length;
      let err = null;
      for (const v of arr) {
        cb(v, function(_err) {
          if (err != null) {
            return;
          }
          if (_err != null) {
            err = _err;
            return done(err);
          }
          if (--remaining <= 0) {
            return done();
          }
        });
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js
var require_isPathExcluded = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var isDefiningProjection = require_isDefiningProjection();
    module2.exports = function isPathExcluded(projection, path3) {
      if (path3 === "_id") {
        return projection._id === 0;
      }
      const paths = Object.keys(projection);
      let type = null;
      for (const _path of paths) {
        if (isDefiningProjection(projection[_path])) {
          type = projection[path3] === 1 ? "inclusive" : "exclusive";
          break;
        }
      }
      if (type === "inclusive") {
        return projection[path3] !== 1;
      }
      if (type === "exclusive") {
        return projection[path3] === 0;
      }
      return false;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js
var require_getSchemaTypes = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Mixed = require_mixed();
    var get = require_get();
    var leanPopulateMap = require_leanPopulateMap();
    var mpath = require_mpath();
    var populateModelSymbol = require_symbols().populateModelSymbol;
    module2.exports = function getSchemaTypes(schema, doc, path3) {
      const pathschema = schema.path(path3);
      const topLevelDoc = doc;
      if (pathschema) {
        return pathschema;
      }
      function search(parts2, schema2, subdoc, nestedPath) {
        let p = parts2.length + 1;
        let foundschema;
        let trypath;
        while (p--) {
          trypath = parts2.slice(0, p).join(".");
          foundschema = schema2.path(trypath);
          if (foundschema == null) {
            continue;
          }
          if (foundschema.caster) {
            if (foundschema.caster instanceof Mixed) {
              return foundschema.caster;
            }
            let schemas = null;
            if (foundschema.schema != null && foundschema.schema.discriminators != null) {
              const discriminators = foundschema.schema.discriminators;
              const discriminatorKeyPath = trypath + "." + foundschema.schema.options.discriminatorKey;
              const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];
              schemas = Object.keys(discriminators).reduce(function(cur, discriminator) {
                const tiedValue = discriminators[discriminator].discriminatorMapping.value;
                if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {
                  cur.push(discriminators[discriminator]);
                }
                return cur;
              }, []);
            }
            if (p !== parts2.length && foundschema.schema) {
              let ret2;
              if (parts2[p] === "$") {
                if (p + 1 === parts2.length) {
                  return foundschema;
                }
                ret2 = search(
                  parts2.slice(p + 1),
                  schema2,
                  subdoc ? mpath.get(trypath, subdoc) : null,
                  nestedPath.concat(parts2.slice(0, p))
                );
                if (ret2) {
                  ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                }
                return ret2;
              }
              if (schemas != null && schemas.length > 0) {
                ret2 = [];
                for (const schema3 of schemas) {
                  const _ret = search(
                    parts2.slice(p),
                    schema3,
                    subdoc ? mpath.get(trypath, subdoc) : null,
                    nestedPath.concat(parts2.slice(0, p))
                  );
                  if (_ret != null) {
                    _ret.$isUnderneathDocArray = _ret.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                    if (_ret.$isUnderneathDocArray) {
                      ret2.$isUnderneathDocArray = true;
                    }
                    ret2.push(_ret);
                  }
                }
                return ret2;
              } else {
                ret2 = search(
                  parts2.slice(p),
                  foundschema.schema,
                  subdoc ? mpath.get(trypath, subdoc) : null,
                  nestedPath.concat(parts2.slice(0, p))
                );
                if (ret2) {
                  ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !foundschema.schema.$isSingleNested;
                }
                return ret2;
              }
            } else if (p !== parts2.length && foundschema.$isMongooseArray && foundschema.casterConstructor.$isMongooseArray) {
              let type = foundschema;
              while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {
                type = type.casterConstructor;
              }
              const ret2 = search(
                parts2.slice(p),
                type.schema,
                null,
                nestedPath.concat(parts2.slice(0, p))
              );
              if (ret2 != null) {
                return ret2;
              }
              if (type.schema.discriminators) {
                const discriminatorPaths = [];
                for (const discriminatorName of Object.keys(type.schema.discriminators)) {
                  const _schema = type.schema.discriminators[discriminatorName] || type.schema;
                  const ret3 = search(parts2.slice(p), _schema, null, nestedPath.concat(parts2.slice(0, p)));
                  if (ret3 != null) {
                    discriminatorPaths.push(ret3);
                  }
                }
                if (discriminatorPaths.length > 0) {
                  return discriminatorPaths;
                }
              }
            }
          }
          const fullPath = nestedPath.concat([trypath]).join(".");
          if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.populated(fullPath) && p < parts2.length) {
            const model = doc.$__.populated[fullPath].options[populateModelSymbol];
            if (model != null) {
              const ret2 = search(
                parts2.slice(p),
                model.schema,
                subdoc ? mpath.get(trypath, subdoc) : null,
                nestedPath.concat(parts2.slice(0, p))
              );
              if (ret2) {
                ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !model.schema.$isSingleNested;
              }
              return ret2;
            }
          }
          const _val = get(topLevelDoc, trypath);
          if (_val != null) {
            const model = Array.isArray(_val) && _val.length > 0 ? leanPopulateMap.get(_val[0]) : leanPopulateMap.get(_val);
            const schema3 = model != null ? model.schema : null;
            if (schema3 != null) {
              const ret2 = search(
                parts2.slice(p),
                schema3,
                subdoc ? mpath.get(trypath, subdoc) : null,
                nestedPath.concat(parts2.slice(0, p))
              );
              if (ret2 != null) {
                ret2.$isUnderneathDocArray = ret2.$isUnderneathDocArray || !schema3.$isSingleNested;
                return ret2;
              }
            }
          }
          return foundschema;
        }
      }
      const parts = path3.split(".");
      for (let i = 0; i < parts.length; ++i) {
        if (parts[i] === "$") {
          parts[i] = "0";
        }
      }
      return search(parts, schema, doc, []);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/normalizeRefPath.js
var require_normalizeRefPath = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/normalizeRefPath.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function normalizeRefPath(refPath, doc, populatedPath) {
      if (refPath == null) {
        return refPath;
      }
      if (typeof refPath === "function") {
        refPath = refPath.call(doc, doc, populatedPath);
      }
      const hasNumericProp = /(\.\d+$|\.\d+\.)/g;
      if (hasNumericProp.test(populatedPath)) {
        const chunks = populatedPath.split(hasNumericProp);
        if (chunks[chunks.length - 1] === "") {
          throw new Error("Can't populate individual element in an array");
        }
        let _refPath = "";
        let _remaining = refPath;
        for (let i = 0; i < chunks.length; i += 2) {
          const chunk = chunks[i];
          if (_remaining.startsWith(chunk + ".")) {
            _refPath += _remaining.substr(0, chunk.length) + chunks[i + 1];
            _remaining = _remaining.substr(chunk.length + 1);
          } else if (i === chunks.length - 1) {
            _refPath += _remaining;
            _remaining = "";
            break;
          } else {
            throw new Error("Could not normalize ref path, chunk " + chunk + " not in populated path");
          }
        }
        return _refPath;
      }
      return refPath;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js
var require_getModelsMapForPopulate = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var MongooseError = require_error();
    var SkipPopulateValue = require_SkipPopulateValue();
    var get = require_get();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var isPathExcluded = require_isPathExcluded();
    var getConstructorName = require_getConstructorName();
    var getSchemaTypes = require_getSchemaTypes();
    var getVirtual = require_getVirtual();
    var lookupLocalFields = require_lookupLocalFields();
    var mpath = require_mpath();
    var normalizeRefPath = require_normalizeRefPath();
    var util2 = require("util");
    var utils = require_utils2();
    var modelSymbol = require_symbols().modelSymbol;
    var populateModelSymbol = require_symbols().populateModelSymbol;
    var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
    module2.exports = function getModelsMapForPopulate(model, docs, options) {
      let i;
      let doc;
      const len = docs.length;
      const available = {};
      const map = [];
      const modelNameFromQuery = options.model && options.model.modelName || options.model;
      let schema;
      let refPath;
      let Model6;
      let currentOptions;
      let modelNames;
      let modelName;
      const originalModel = options.model;
      let isVirtual = false;
      const modelSchema = model.schema;
      let allSchemaTypes = getSchemaTypes(modelSchema, null, options.path);
      allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter((v) => v != null);
      const _firstWithRefPath = allSchemaTypes.find((schematype) => get(schematype, "options.refPath", null) != null);
      for (i = 0; i < len; i++) {
        doc = docs[i];
        let justOne = null;
        schema = getSchemaTypes(modelSchema, doc, options.path);
        if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {
          continue;
        }
        if (options._localModel != null && options._localModel.schema.nested[options.path]) {
          continue;
        }
        const isUnderneathDocArray = schema && schema.$isUnderneathDocArray;
        if (isUnderneathDocArray && get(options, "options.sort") != null) {
          return new MongooseError("Cannot populate with `sort` on path " + options.path + " because it is a subproperty of a document array");
        }
        modelNames = null;
        let isRefPath = !!_firstWithRefPath;
        let normalizedRefPath = _firstWithRefPath ? get(_firstWithRefPath, "options.refPath", null) : null;
        let schemaOptions = null;
        if (Array.isArray(schema)) {
          const schemasArray = schema;
          for (const _schema of schemasArray) {
            let _modelNames;
            let res;
            try {
              res = _getModelNames(doc, _schema);
              _modelNames = res.modelNames;
              isRefPath = isRefPath || res.isRefPath;
              normalizedRefPath = normalizeRefPath(normalizedRefPath, doc, options.path) || res.refPath;
              justOne = res.justOne;
            } catch (error) {
              return error;
            }
            if (isRefPath && !res.isRefPath) {
              continue;
            }
            if (!_modelNames) {
              continue;
            }
            modelNames = modelNames || [];
            for (const modelName2 of _modelNames) {
              if (modelNames.indexOf(modelName2) === -1) {
                modelNames.push(modelName2);
              }
            }
          }
        } else {
          try {
            const res = _getModelNames(doc, schema);
            modelNames = res.modelNames;
            isRefPath = res.isRefPath;
            normalizedRefPath = res.refPath;
            justOne = res.justOne;
            schemaOptions = get(schema, "options.populate", null);
          } catch (error) {
            return error;
          }
          if (!modelNames) {
            continue;
          }
        }
        const _virtualRes = getVirtual(model.schema, options.path);
        const virtual = _virtualRes == null ? null : _virtualRes.virtual;
        let localField;
        let count = false;
        if (virtual && virtual.options) {
          const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + "." : "";
          if (typeof virtual.options.localField === "function") {
            localField = virtualPrefix + virtual.options.localField.call(doc, doc);
          } else if (Array.isArray(virtual.options.localField)) {
            localField = virtual.options.localField.map((field) => virtualPrefix + field);
          } else {
            localField = virtualPrefix + virtual.options.localField;
          }
          count = virtual.options.count;
          if (virtual.options.skip != null && !options.hasOwnProperty("skip")) {
            options.skip = virtual.options.skip;
          }
          if (virtual.options.limit != null && !options.hasOwnProperty("limit")) {
            options.limit = virtual.options.limit;
          }
          if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty("perDocumentLimit")) {
            options.perDocumentLimit = virtual.options.perDocumentLimit;
          }
        } else {
          localField = options.path;
        }
        let foreignField = virtual && virtual.options ? virtual.options.foreignField : "_id";
        if ("justOne" in options && options.justOne !== void 0) {
          justOne = options.justOne;
        } else if (virtual && virtual.options && virtual.options.refPath) {
          const normalizedRefPath2 = normalizeRefPath(virtual.options.refPath, doc, options.path);
          justOne = !!virtual.options.justOne;
          isVirtual = true;
          const refValue = utils.getValue(normalizedRefPath2, doc);
          modelNames = Array.isArray(refValue) ? refValue : [refValue];
        } else if (virtual && virtual.options && virtual.options.ref) {
          let normalizedRef;
          if (typeof virtual.options.ref === "function") {
            normalizedRef = virtual.options.ref.call(doc, doc);
          } else {
            normalizedRef = virtual.options.ref;
          }
          justOne = !!virtual.options.justOne;
          isVirtual = true;
          if (!modelNames) {
            modelNames = [].concat(normalizedRef);
          }
        } else if (schema && !schema[schemaMixedSymbol]) {
          if (options.path.endsWith("." + schema.path)) {
            justOne = Array.isArray(schema) ? schema.every((schema2) => !schema2.$isMongooseArray) : !schema.$isMongooseArray;
          }
        }
        if (!modelNames) {
          continue;
        }
        if (virtual && (!localField || !foreignField)) {
          return new MongooseError("If you are populating a virtual, you must set the localField and foreignField options");
        }
        options.isVirtual = isVirtual;
        options.virtual = virtual;
        if (typeof localField === "function") {
          localField = localField.call(doc, doc);
        }
        if (typeof foreignField === "function") {
          foreignField = foreignField.call(doc);
        }
        let match = get(options, "match", null) || get(currentOptions, "match", null) || get(options, "virtual.options.match", null) || get(options, "virtual.options.options.match", null);
        let hasMatchFunction = typeof match === "function";
        if (hasMatchFunction) {
          match = match.call(doc, doc);
        }
        if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {
          match = Object.assign({}, match);
          for (let i2 = 1; i2 < localField.length; ++i2) {
            match[foreignField[i2]] = convertTo_id(mpath.get(localField[i2], doc, lookupLocalFields), schema);
            hasMatchFunction = true;
          }
          localField = localField[0];
          foreignField = foreignField[0];
        }
        const localFieldPathType = modelSchema._getPathType(localField);
        const localFieldPath = localFieldPathType === "real" ? modelSchema.path(localField) : localFieldPathType.schema;
        const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];
        let ret2;
        const _populateOptions = get(options, "options", {});
        const getters = "getters" in _populateOptions ? _populateOptions.getters : options.isVirtual && get(virtual, "options.getters", false);
        if (localFieldGetters.length > 0 && getters) {
          const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);
          const localFieldValue = mpath.get(localField, doc, lookupLocalFields);
          if (Array.isArray(localFieldValue)) {
            const localFieldHydratedValue = mpath.get(localField.split(".").slice(0, -1), hydratedDoc, lookupLocalFields);
            ret2 = localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));
          } else {
            ret2 = localFieldPath.applyGetters(localFieldValue, hydratedDoc);
          }
        } else {
          ret2 = convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);
        }
        const id = String(utils.getValue(foreignField, doc));
        options._docs[id] = Array.isArray(ret2) ? ret2.slice() : ret2;
        if (isRefPath && normalizedRefPath != null) {
          const pieces = normalizedRefPath.split(".");
          let cur = "";
          for (let j = 0; j < pieces.length; ++j) {
            const piece = pieces[j];
            cur = cur + (cur.length === 0 ? "" : ".") + piece;
            const schematype = modelSchema.path(cur);
            if (schematype != null && schematype.$isMongooseArray && schematype.caster.discriminators != null && Object.keys(schematype.caster.discriminators).length > 0) {
              const subdocs = utils.getValue(cur, doc);
              const remnant = options.path.substr(cur.length + 1);
              const discriminatorKey = schematype.caster.schema.options.discriminatorKey;
              modelNames = [];
              for (const subdoc of subdocs) {
                const discriminatorName = utils.getValue(discriminatorKey, subdoc);
                const discriminator = schematype.caster.discriminators[discriminatorName];
                const discriminatorSchema = discriminator && discriminator.schema;
                if (discriminatorSchema == null) {
                  continue;
                }
                const _path = discriminatorSchema.path(remnant);
                if (_path == null || _path.options.refPath == null) {
                  const docValue = utils.getValue(localField.substr(cur.length + 1), subdoc);
                  ret2 = ret2.map((v) => v === docValue ? SkipPopulateValue(v) : v);
                  continue;
                }
                const modelName2 = utils.getValue(pieces.slice(j + 1).join("."), subdoc);
                modelNames.push(modelName2);
              }
            }
          }
        }
        let k = modelNames.length;
        while (k--) {
          modelName = modelNames[k];
          if (modelName == null) {
            continue;
          }
          const connection = options.connection != null ? options.connection : model.db;
          try {
            Model6 = originalModel && originalModel[modelSymbol] ? originalModel : modelName[modelSymbol] ? modelName : connection.model(modelName);
          } catch (error) {
            if (ret2 !== void 0) {
              return error;
            }
          }
          let ids = ret2;
          const flat = Array.isArray(ret2) ? utils.array.flatten(ret2) : [];
          if (isRefPath && Array.isArray(ret2) && flat.length === modelNames.length) {
            ids = flat.filter((val, i2) => modelNames[i2] === modelName);
          }
          if (!available[modelName] || currentOptions.perDocumentLimit != null || get(currentOptions, "options.perDocumentLimit") != null) {
            currentOptions = {
              model: Model6
            };
            if (isVirtual && get(virtual, "options.options")) {
              currentOptions.options = utils.clone(virtual.options.options);
            } else if (schemaOptions != null) {
              currentOptions.options = Object.assign({}, schemaOptions);
            }
            utils.merge(currentOptions, options);
            options[populateModelSymbol] = Model6;
            available[modelName] = {
              model: Model6,
              options: currentOptions,
              match: hasMatchFunction ? [match] : match,
              docs: [doc],
              ids: [ids],
              allIds: [ret2],
              localField: /* @__PURE__ */ new Set([localField]),
              foreignField: /* @__PURE__ */ new Set([foreignField]),
              justOne,
              isVirtual,
              virtual,
              count,
              [populateModelSymbol]: Model6
            };
            map.push(available[modelName]);
          } else {
            available[modelName].localField.add(localField);
            available[modelName].foreignField.add(foreignField);
            available[modelName].docs.push(doc);
            available[modelName].ids.push(ids);
            available[modelName].allIds.push(ret2);
            if (hasMatchFunction) {
              available[modelName].match.push(match);
            }
          }
        }
      }
      return map;
      function _getModelNames(doc2, schema2) {
        let modelNames2;
        let discriminatorKey;
        let isRefPath = false;
        let justOne = null;
        if (schema2 && schema2.caster) {
          schema2 = schema2.caster;
        }
        if (schema2 && schema2.$isSchemaMap) {
          schema2 = schema2.$__schemaType;
        }
        if (!schema2 && model.discriminators) {
          discriminatorKey = model.schema.discriminatorMapping.key;
        }
        refPath = schema2 && schema2.options && schema2.options.refPath;
        const normalizedRefPath = normalizeRefPath(refPath, doc2, options.path);
        if (modelNameFromQuery) {
          modelNames2 = [modelNameFromQuery];
        } else if (normalizedRefPath) {
          if (options._queryProjection != null && isPathExcluded(options._queryProjection, normalizedRefPath)) {
            throw new MongooseError("refPath `" + normalizedRefPath + "` must not be excluded in projection, got " + util2.inspect(options._queryProjection));
          }
          if (modelSchema.virtuals.hasOwnProperty(normalizedRefPath) && doc2.$__ == null) {
            modelNames2 = [modelSchema.virtuals[normalizedRefPath].applyGetters(void 0, doc2)];
          } else {
            modelNames2 = utils.getValue(normalizedRefPath, doc2);
          }
          if (Array.isArray(modelNames2)) {
            modelNames2 = utils.array.flatten(modelNames2);
          }
          isRefPath = true;
        } else {
          let modelForCurrentDoc = model;
          let schemaForCurrentDoc;
          let discriminatorValue;
          if (!schema2 && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc2))) {
            const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;
            if (discriminatorModel != null) {
              modelForCurrentDoc = discriminatorModel;
            } else {
              try {
                modelForCurrentDoc = model.db.model(discriminatorValue);
              } catch (error) {
                return error;
              }
            }
            schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);
            if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {
              schemaForCurrentDoc = schemaForCurrentDoc.caster;
            }
          } else {
            schemaForCurrentDoc = schema2;
          }
          const _virtualRes = getVirtual(modelForCurrentDoc.schema, options.path);
          const virtual = _virtualRes == null ? null : _virtualRes.virtual;
          if (schemaForCurrentDoc != null) {
            justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;
          }
          let ref;
          let refPath2;
          if ((ref = get(schemaForCurrentDoc, "options.ref")) != null) {
            ref = handleRefFunction(ref, doc2);
            modelNames2 = [ref];
          } else if ((ref = get(virtual, "options.ref")) != null) {
            ref = handleRefFunction(ref, doc2);
            if (Array.isArray(ref)) {
              modelNames2 = ref;
            } else {
              modelNames2 = [ref];
            }
            isVirtual = true;
          } else if ((refPath2 = get(schemaForCurrentDoc, "options.refPath")) != null) {
            isRefPath = true;
            refPath2 = normalizeRefPath(refPath2, doc2, options.path);
            modelNames2 = utils.getValue(refPath2, doc2);
            if (Array.isArray(modelNames2)) {
              modelNames2 = utils.array.flatten(modelNames2);
            }
          } else {
            modelNames2 = discriminatorKey ? null : [model.modelName];
          }
        }
        if (!modelNames2) {
          return { modelNames: modelNames2, isRefPath, refPath: normalizedRefPath, justOne };
        }
        if (!Array.isArray(modelNames2)) {
          modelNames2 = [modelNames2];
        }
        return { modelNames: modelNames2, isRefPath, refPath: normalizedRefPath, justOne };
      }
    };
    function handleRefFunction(ref, doc) {
      if (typeof ref === "function" && !ref[modelSymbol]) {
        return ref.call(doc, doc);
      }
      return ref;
    }
    function convertTo_id(val, schema) {
      if (val != null && val.$__ != null) {
        return val._id;
      }
      if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {
        return val._id;
      }
      if (Array.isArray(val)) {
        for (let i = 0; i < val.length; ++i) {
          if (val[i] != null && val[i].$__ != null) {
            val[i] = val[i]._id;
          }
        }
        if (val.isMongooseArray && val.$schema()) {
          return val.$schema()._castForPopulate(val, val.$parent());
        }
        return [].concat(val);
      }
      if (getConstructorName(val) === "Object" && // The intent here is we should only flatten the object if we expect
      // to get a Map in the end. Avoid doing this for mixed types.
      (schema == null || schema[schemaMixedSymbol] == null)) {
        const ret2 = [];
        for (const key of Object.keys(val)) {
          ret2.push(val[key]);
        }
        return ret2;
      }
      if (val instanceof Map) {
        return Array.from(val.values());
      }
      return val;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js
var require_isDefaultIdIndex = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var get = require_get();
    module2.exports = function isDefaultIdIndex(index) {
      if (Array.isArray(index)) {
        const keys = Object.keys(index[0]);
        return keys.length === 1 && keys[0] === "_id" && index[0]._id !== "hashed";
      }
      if (typeof index !== "object") {
        return false;
      }
      const key = get(index, "key", {});
      return Object.keys(key).length === 1 && key.hasOwnProperty("_id");
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js
var require_isIndexEqual = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var get = require_get();
    var utils = require_utils2();
    module2.exports = function isIndexEqual(key, options, dbIndex) {
      if (dbIndex.textIndexVersion != null) {
        const weights = dbIndex.weights;
        if (Object.keys(weights).length !== Object.keys(key).length) {
          return false;
        }
        for (const prop of Object.keys(weights)) {
          if (!(prop in key)) {
            return false;
          }
          const weight = weights[prop];
          if (weight !== get(options, "weights." + prop) && !(weight === 1 && get(options, "weights." + prop) == null)) {
            return false;
          }
        }
        if (options["default_language"] !== dbIndex["default_language"]) {
          return dbIndex["default_language"] === "english" && options["default_language"] == null;
        }
        return true;
      }
      const optionKeys = [
        "unique",
        "partialFilterExpression",
        "sparse",
        "expireAfterSeconds",
        "collation"
      ];
      for (const key2 of optionKeys) {
        if (!(key2 in options) && !(key2 in dbIndex)) {
          continue;
        }
        if (key2 === "collation") {
          if (options[key2] == null || dbIndex[key2] == null) {
            return options[key2] == null && dbIndex[key2] == null;
          }
          const definedKeys = Object.keys(options.collation);
          const schemaCollation = options.collation;
          const dbCollation = dbIndex.collation;
          for (const opt of definedKeys) {
            if (get(schemaCollation, opt) !== get(dbCollation, opt)) {
              return false;
            }
          }
        } else if (!utils.deepEqual(options[key2], dbIndex[key2])) {
          return false;
        }
      }
      const schemaIndexKeys = Object.keys(key);
      const dbIndexKeys = Object.keys(dbIndex.key);
      if (schemaIndexKeys.length !== dbIndexKeys.length) {
        return false;
      }
      for (let i = 0; i < schemaIndexKeys.length; ++i) {
        if (schemaIndexKeys[i] !== dbIndexKeys[i]) {
          return false;
        }
        if (!utils.deepEqual(key[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js
var require_isPathSelectedInclusive = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function isPathSelectedInclusive(fields, path3) {
      const chunks = path3.split(".");
      let cur = "";
      let j;
      let keys;
      let numKeys;
      for (let i = 0; i < chunks.length; ++i) {
        cur += cur.length ? "." : "" + chunks[i];
        if (fields[cur]) {
          keys = Object.keys(fields);
          numKeys = keys.length;
          for (j = 0; j < numKeys; ++j) {
            if (keys[i].indexOf(cur + ".") === 0 && keys[i].indexOf(path3) !== 0) {
              continue;
            }
          }
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/parallelLimit.js
var require_parallelLimit = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/parallelLimit.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = parallelLimit;
    function parallelLimit(fns, limit, callback) {
      let numInProgress = 0;
      let numFinished = 0;
      let error = null;
      if (limit <= 0) {
        throw new Error("Limit must be positive");
      }
      if (fns.length === 0) {
        return callback(null, []);
      }
      for (let i = 0; i < fns.length && i < limit; ++i) {
        _start();
      }
      function _start() {
        fns[numFinished + numInProgress](_done(numFinished + numInProgress));
        ++numInProgress;
      }
      const results = [];
      function _done(index) {
        return (err, res) => {
          --numInProgress;
          ++numFinished;
          if (error != null) {
            return;
          }
          if (err != null) {
            error = err;
            return callback(error);
          }
          results[index] = res;
          if (numFinished === fns.length) {
            return callback(null, results);
          } else if (numFinished + numInProgress < fns.length) {
            _start();
          }
        };
      }
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js
var require_removeDeselectedForeignField = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var get = require_get();
    var mpath = require_mpath();
    var parseProjection = require_parseProjection();
    module2.exports = function removeDeselectedForeignField(foreignFields, options, docs) {
      const projection = parseProjection(get(options, "select", null), true) || parseProjection(get(options, "options.select", null), true);
      if (projection == null) {
        return;
      }
      for (const foreignField of foreignFields) {
        if (!projection.hasOwnProperty("-" + foreignField)) {
          continue;
        }
        for (const val of docs) {
          if (val.$__ != null) {
            mpath.unset(foreignField, val._doc);
          } else {
            mpath.unset(foreignField, val);
          }
        }
      }
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/model.js
var require_model = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/model.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var Aggregate = require_aggregate();
    var ChangeStream = require_ChangeStream();
    var Document6 = require_document();
    var DocumentNotFoundError = require_notFound();
    var DivergentArrayError = require_divergentArray();
    var EventEmitter = require("events").EventEmitter;
    var MongooseBuffer = require_buffer();
    var MongooseError = require_error();
    var OverwriteModelError = require_overwriteModel();
    var PromiseProvider = require_promise_provider();
    var Query = require_query();
    var RemoveOptions = require_removeOptions();
    var SaveOptions = require_saveOptions();
    var Schema6 = require_schema2();
    var ServerSelectionError = require_serverSelection();
    var ValidationError = require_validation();
    var VersionError = require_version();
    var ParallelSaveError = require_parallelSave();
    var applyQueryMiddleware = require_applyQueryMiddleware();
    var applyHooks = require_applyHooks();
    var applyMethods = require_applyMethods();
    var applyStaticHooks = require_applyStaticHooks();
    var applyStatics = require_applyStatics();
    var applyWriteConcern = require_applyWriteConcern();
    var assignVals = require_assignVals();
    var castBulkWrite = require_castBulkWrite();
    var createPopulateQueryFilter = require_createPopulateQueryFilter();
    var getDefaultBulkwriteResult = require_getDefaultBulkwriteResult();
    var discriminator = require_discriminator();
    var each = require_each2();
    var get = require_get();
    var getConstructorName = require_getConstructorName();
    var getDiscriminatorByValue = require_getDiscriminatorByValue();
    var getModelsMapForPopulate = require_getModelsMapForPopulate();
    var immediate = require_immediate();
    var internalToObjectOptions = require_options().internalToObjectOptions;
    var isDefaultIdIndex = require_isDefaultIdIndex();
    var isIndexEqual = require_isIndexEqual();
    var isPathSelectedInclusive = require_isPathSelectedInclusive();
    var leanPopulateMap = require_leanPopulateMap();
    var modifiedPaths = require_modifiedPaths();
    var parallelLimit = require_parallelLimit();
    var removeDeselectedForeignField = require_removeDeselectedForeignField();
    var util2 = require("util");
    var utils = require_utils2();
    var VERSION_WHERE = 1;
    var VERSION_INC = 2;
    var VERSION_ALL = VERSION_WHERE | VERSION_INC;
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var modelCollectionSymbol = Symbol("mongoose#Model#collection");
    var modelDbSymbol = Symbol("mongoose#Model#db");
    var modelSymbol = require_symbols().modelSymbol;
    var subclassedSymbol = Symbol("mongoose#Model#subclassed");
    var saveToObjectOptions = Object.assign({}, internalToObjectOptions, {
      bson: true
    });
    function Model6(doc, fields, skipId) {
      if (fields instanceof Schema6) {
        throw new TypeError("2nd argument to `Model` must be a POJO or string, **not** a schema. Make sure you're calling `mongoose.model()`, not `mongoose.Model()`.");
      }
      Document6.call(this, doc, fields, skipId);
    }
    Model6.prototype.__proto__ = Document6.prototype;
    Model6.prototype.$isMongooseModelPrototype = true;
    Model6.prototype.db;
    Model6.prototype.collection;
    Model6.prototype.$__collection;
    Model6.prototype.modelName;
    Model6.prototype.$where;
    Model6.prototype.baseModelName;
    Model6.events;
    Model6._middleware;
    function _applyCustomWhere(doc, where) {
      if (doc.$where == null) {
        return;
      }
      for (const key of Object.keys(doc.$where)) {
        where[key] = doc.$where[key];
      }
    }
    Model6.prototype.$__handleSave = function(options, callback) {
      const _this = this;
      let saveOptions = {};
      if ("safe" in options) {
        _handleSafe(options);
      }
      applyWriteConcern(this.$__schema, options);
      if (typeof options.writeConcern != "undefined") {
        saveOptions.writeConcern = {};
        if ("w" in options.writeConcern) {
          saveOptions.writeConcern.w = options.writeConcern.w;
        }
        if ("j" in options.writeConcern) {
          saveOptions.writeConcern.j = options.writeConcern.j;
        }
        if ("wtimeout" in options.writeConcern) {
          saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;
        }
      } else {
        if ("w" in options) {
          saveOptions.w = options.w;
        }
        if ("j" in options) {
          saveOptions.j = options.j;
        }
        if ("wtimeout" in options) {
          saveOptions.wtimeout = options.wtimeout;
        }
      }
      if ("checkKeys" in options) {
        saveOptions.checkKeys = options.checkKeys;
      }
      const session = this.$session();
      if (!saveOptions.hasOwnProperty("session")) {
        saveOptions.session = session;
      }
      if (Object.keys(saveOptions).length === 0) {
        saveOptions = null;
      }
      if (this.isNew) {
        const obj2 = this.toObject(saveToObjectOptions);
        if ((obj2 || {})._id === void 0) {
          immediate(function() {
            callback(new MongooseError("document must have an _id before saving"));
          });
          return;
        }
        this.$__version(true, obj2);
        this[modelCollectionSymbol].insertOne(obj2, saveOptions, function(err, ret2) {
          if (err) {
            _setIsNew(_this, true);
            callback(err, null);
            return;
          }
          callback(null, ret2);
        });
        this.$__reset();
        _setIsNew(this, false);
        this.$__.inserting = true;
      } else {
        this.$__.inserting = false;
        const delta = this.$__delta();
        if (delta) {
          if (delta instanceof MongooseError) {
            callback(delta);
            return;
          }
          const where = this.$__where(delta[0]);
          if (where instanceof MongooseError) {
            callback(where);
            return;
          }
          _applyCustomWhere(this, where);
          this[modelCollectionSymbol].updateOne(where, delta[1], saveOptions, (err, ret2) => {
            if (err) {
              this.$__undoReset();
              callback(err);
              return;
            }
            ret2.$where = where;
            callback(null, ret2);
          });
        } else {
          const optionsWithCustomValues = Object.assign({}, options, saveOptions);
          const where = this.$__where();
          if (this.$__schema.options.optimisticConcurrency) {
            const key = this.$__schema.options.versionKey;
            const val = this.$__getValue(key);
            if (val != null) {
              where[key] = val;
            }
          }
          this.constructor.exists(where, optionsWithCustomValues).then((documentExists) => {
            if (!documentExists) {
              throw new DocumentNotFoundError(this.$__where(), this.constructor.modelName);
            }
            callback();
          }).catch(callback);
          return;
        }
        this.$__.modifiedPaths = this.modifiedPaths();
        this.$__reset();
        _setIsNew(this, false);
      }
    };
    Model6.prototype.$__save = function(options, callback) {
      this.$__handleSave(options, (error, result) => {
        const hooks = this.$__schema.s.hooks;
        if (error) {
          return hooks.execPost("save:error", this, [this], { error }, (error2) => {
            callback(error2, this);
          });
        }
        let numAffected = 0;
        if (get(options, "safe.w") !== 0 && get(options, "w") !== 0) {
          if (result) {
            if (Array.isArray(result)) {
              numAffected = result.length;
            } else if (result.result && result.result.n !== void 0) {
              numAffected = result.result.n;
            } else if (result.result && result.result.nModified !== void 0) {
              numAffected = result.result.nModified;
            } else {
              numAffected = result;
            }
          }
          if (this.$__.version && !this.$__.inserting) {
            const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);
            this.$__.version = void 0;
            const key = this.$__schema.options.versionKey;
            const version = this.$__getValue(key) || 0;
            if (numAffected <= 0) {
              this.$__undoReset();
              const err = this.$__.$versionError || new VersionError(this, version, this.$__.modifiedPaths);
              return callback(err);
            }
            if (doIncrement) {
              this.$__setValue(key, version + 1);
            }
          }
          if (result != null && numAffected <= 0) {
            this.$__undoReset();
            error = new DocumentNotFoundError(
              result.$where,
              this.constructor.modelName,
              numAffected,
              result
            );
            return hooks.execPost("save:error", this, [this], { error }, (error2) => {
              callback(error2, this);
            });
          }
        }
        this.$__.saving = void 0;
        this.$__.savedState = {};
        this.emit("save", this, numAffected);
        this.constructor.emit("save", this, numAffected);
        callback(null, this);
      });
    };
    function generateVersionError(doc, modifiedPaths2) {
      const key = doc.$__schema.options.versionKey;
      if (!key) {
        return null;
      }
      const version = doc.$__getValue(key) || 0;
      return new VersionError(doc, version, modifiedPaths2);
    }
    Model6.prototype.save = function(options, fn) {
      let parallelSave;
      this.$op = "save";
      if (this.$__.saving) {
        parallelSave = new ParallelSaveError(this);
      } else {
        this.$__.saving = new ParallelSaveError(this);
      }
      if (typeof options === "function") {
        fn = options;
        options = void 0;
      }
      options = new SaveOptions(options);
      if (options.hasOwnProperty("session")) {
        this.$session(options.session);
      }
      this.$__.$versionError = generateVersionError(this, this.modifiedPaths());
      fn = this.constructor.$handleCallbackError(fn);
      return this.constructor.db.base._promiseOrCallback(fn, (cb) => {
        cb = this.constructor.$wrapCallback(cb);
        if (parallelSave) {
          this.$__handleReject(parallelSave);
          return cb(parallelSave);
        }
        this.$__.saveOptions = options;
        this.$__save(options, (error) => {
          this.$__.saving = void 0;
          delete this.$__.saveOptions;
          delete this.$__.$versionError;
          this.$op = null;
          if (error) {
            this.$__handleReject(error);
            return cb(error);
          }
          cb(null, this);
        });
      }, this.constructor.events);
    };
    function shouldSkipVersioning(self2, path3) {
      const skipVersioning = self2.$__schema.options.skipVersioning;
      if (!skipVersioning)
        return false;
      path3 = path3.replace(/\.\d+\./, ".");
      return skipVersioning[path3];
    }
    function operand(self2, where, delta, data, val, op) {
      op || (op = "$set");
      if (!delta[op])
        delta[op] = {};
      delta[op][data.path] = val;
      if (self2.$__schema.options.versionKey === false)
        return;
      if (shouldSkipVersioning(self2, data.path))
        return;
      if (VERSION_ALL === (VERSION_ALL & self2.$__.version))
        return;
      if (self2.$__schema.options.optimisticConcurrency) {
        self2.$__.version = VERSION_ALL;
        return;
      }
      switch (op) {
        case "$set":
        case "$unset":
        case "$pop":
        case "$pull":
        case "$pullAll":
        case "$push":
        case "$addToSet":
          break;
        default:
          return;
      }
      if (op === "$push" || op === "$addToSet" || op === "$pullAll" || op === "$pull") {
        self2.$__.version = VERSION_INC;
      } else if (/^\$p/.test(op)) {
        increment.call(self2);
      } else if (Array.isArray(val)) {
        increment.call(self2);
      } else if (/\.\d+\.|\.\d+$/.test(data.path)) {
        self2.$__.version = VERSION_WHERE;
      }
    }
    function handleAtomics(self2, where, delta, data, value) {
      if (delta.$set && delta.$set[data.path]) {
        return;
      }
      if (typeof value.$__getAtomics === "function") {
        value.$__getAtomics().forEach(function(atomic) {
          const op2 = atomic[0];
          const val2 = atomic[1];
          operand(self2, where, delta, data, val2, op2);
        });
        return;
      }
      const atomics = value[arrayAtomicsSymbol];
      const ops = Object.keys(atomics);
      let i = ops.length;
      let val;
      let op;
      if (i === 0) {
        if (utils.isMongooseObject(value)) {
          value = value.toObject({ depopulate: 1, _isNested: true });
        } else if (value.valueOf) {
          value = value.valueOf();
        }
        return operand(self2, where, delta, data, value);
      }
      function iter(mem) {
        return utils.isMongooseObject(mem) ? mem.toObject({ depopulate: 1, _isNested: true }) : mem;
      }
      while (i--) {
        op = ops[i];
        val = atomics[op];
        if (utils.isMongooseObject(val)) {
          val = val.toObject({ depopulate: true, transform: false, _isNested: true });
        } else if (Array.isArray(val)) {
          val = val.map(iter);
        } else if (val.valueOf) {
          val = val.valueOf();
        }
        if (op === "$addToSet") {
          val = { $each: val };
        }
        operand(self2, where, delta, data, val, op);
      }
    }
    Model6.prototype.$__delta = function() {
      const dirty = this.$__dirty();
      if (!dirty.length && VERSION_ALL !== this.$__.version) {
        return;
      }
      const where = {};
      const delta = {};
      const len = dirty.length;
      const divergent = [];
      let d = 0;
      where._id = this._doc._id;
      if (get(where, "_id.$__", null) != null) {
        where._id = where._id.toObject({ transform: false, depopulate: true });
      }
      for (; d < len; ++d) {
        const data = dirty[d];
        let value = data.value;
        const match = checkDivergentArray(this, data.path, value);
        if (match) {
          divergent.push(match);
          continue;
        }
        const pop = this.populated(data.path, true);
        if (!pop && this.$__.selected) {
          const pathSplit = data.path.split(".");
          const top = pathSplit[0];
          if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {
            if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === "undefined") {
              where[top] = this.$__.selected[top];
              pathSplit[1] = "$";
              data.path = pathSplit.join(".");
            } else {
              divergent.push(data.path);
              continue;
            }
          }
        }
        if (divergent.length)
          continue;
        if (value === void 0) {
          operand(this, where, delta, data, 1, "$unset");
        } else if (value === null) {
          operand(this, where, delta, data, null);
        } else if (value.isMongooseArray && value.$path() && value[arrayAtomicsSymbol]) {
          handleAtomics(this, where, delta, data, value);
        } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {
          value = value.toObject();
          operand(this, where, delta, data, value);
        } else {
          value = utils.clone(value, {
            depopulate: true,
            transform: false,
            virtuals: false,
            getters: false,
            _isNested: true
          });
          operand(this, where, delta, data, value);
        }
      }
      if (divergent.length) {
        return new DivergentArrayError(divergent);
      }
      if (this.$__.version) {
        this.$__version(where, delta);
      }
      return [where, delta];
    };
    function checkDivergentArray(doc, path3, array) {
      const pop = doc.populated(path3, true);
      if (!pop && doc.$__.selected) {
        const top = path3.split(".")[0];
        if (doc.$__.selected[top + ".$"]) {
          return top;
        }
      }
      if (!(pop && array && array.isMongooseArray))
        return;
      const check = pop.options.match || pop.options.options && utils.object.hasOwnProperty(pop.options.options, "limit") || // 0 is not permitted
      pop.options.options && pop.options.options.skip || // 0 is permitted
      pop.options.select && // deselected _id?
      (pop.options.select._id === 0 || /\s?-_id\s?/.test(pop.options.select));
      if (check) {
        const atomics = array[arrayAtomicsSymbol];
        if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {
          return path3;
        }
      }
    }
    Model6.prototype.$__version = function(where, delta) {
      const key = this.$__schema.options.versionKey;
      if (where === true) {
        if (key) {
          this.$__setValue(key, delta[key] = 0);
        }
        return;
      }
      if (!this.$__isSelected(key)) {
        return;
      }
      if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {
        const value = this.$__getValue(key);
        if (value != null)
          where[key] = value;
      }
      if (VERSION_INC === (VERSION_INC & this.$__.version)) {
        if (get(delta.$set, key, null) != null) {
          ++delta.$set[key];
        } else {
          delta.$inc = delta.$inc || {};
          delta.$inc[key] = 1;
        }
      }
    };
    function increment() {
      this.$__.version = VERSION_ALL;
      return this;
    }
    Model6.prototype.increment = increment;
    Model6.prototype.$__where = function _where(where) {
      where || (where = {});
      if (!where._id) {
        where._id = this._doc._id;
      }
      if (this._doc._id === void 0) {
        return new MongooseError("No _id found on document!");
      }
      return where;
    };
    Model6.prototype.remove = function remove(options, fn) {
      if (typeof options === "function") {
        fn = options;
        options = void 0;
      }
      options = new RemoveOptions(options);
      if (options.hasOwnProperty("session")) {
        this.$session(options.session);
      }
      this.$op = "remove";
      fn = this.constructor.$handleCallbackError(fn);
      return this.constructor.db.base._promiseOrCallback(fn, (cb) => {
        cb = this.constructor.$wrapCallback(cb);
        this.$__remove(options, (err, res) => {
          this.$op = null;
          cb(err, res);
        });
      }, this.constructor.events);
    };
    Model6.prototype.delete = Model6.prototype.remove;
    Model6.prototype.deleteOne = function deleteOne(options, fn) {
      if (typeof options === "function") {
        fn = options;
        options = void 0;
      }
      if (!options) {
        options = {};
      }
      fn = this.constructor.$handleCallbackError(fn);
      return this.constructor.db.base._promiseOrCallback(fn, (cb) => {
        cb = this.constructor.$wrapCallback(cb);
        this.$__deleteOne(options, cb);
      }, this.constructor.events);
    };
    Model6.prototype.$__remove = function $__remove(options, cb) {
      if (this.$__.isDeleted) {
        return immediate(() => cb(null, this));
      }
      const where = this.$__where();
      if (where instanceof MongooseError) {
        return cb(where);
      }
      _applyCustomWhere(this, where);
      const session = this.$session();
      if (!options.hasOwnProperty("session")) {
        options.session = session;
      }
      this[modelCollectionSymbol].deleteOne(where, options, (err) => {
        if (!err) {
          this.$__.isDeleted = true;
          this.emit("remove", this);
          this.constructor.emit("remove", this);
          return cb(null, this);
        }
        this.$__.isDeleted = false;
        cb(err);
      });
    };
    Model6.prototype.$__deleteOne = Model6.prototype.$__remove;
    Model6.prototype.model = function model(name) {
      return this[modelDbSymbol].model(name);
    };
    Model6.exists = function exists(filter, options, callback) {
      _checkContext(this, "exists");
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const query = this.findOne(filter).select({ _id: 1 }).lean().setOptions(options);
      if (typeof callback === "function") {
        query.exec(function(err, doc) {
          if (err != null) {
            return callback(err);
          }
          callback(null, !!doc);
        });
        return;
      }
      options = options || {};
      if (!options.explain) {
        return query.then((doc) => !!doc);
      }
      return query.exec();
    };
    Model6.discriminator = function(name, schema, value) {
      let model;
      if (typeof name === "function") {
        model = name;
        name = utils.getFunctionName(model);
        if (!(model.prototype instanceof Model6)) {
          throw new MongooseError("The provided class " + name + " must extend Model");
        }
      }
      _checkContext(this, "discriminator");
      if (utils.isObject(schema) && !schema.instanceOfSchema) {
        schema = new Schema6(schema);
      }
      schema = discriminator(this, name, schema, value, true);
      if (this.db.models[name]) {
        throw new OverwriteModelError(name);
      }
      schema.$isRootDiscriminator = true;
      schema.$globalPluginsApplied = true;
      model = this.db.model(model || name, schema, this.$__collection.name);
      this.discriminators[name] = model;
      const d = this.discriminators[name];
      d.prototype.__proto__ = this.prototype;
      Object.defineProperty(d, "baseModelName", {
        value: this.modelName,
        configurable: true,
        writable: false
      });
      applyMethods(d, schema);
      applyStatics(d, schema);
      if (this[subclassedSymbol] != null) {
        for (const submodel of this[subclassedSymbol]) {
          submodel.discriminators = submodel.discriminators || {};
          submodel.discriminators[name] = model.__subclass(model.db, schema, submodel.collection.name);
        }
      }
      return d;
    };
    function _checkContext(ctx, fnName) {
      if (ctx == null || ctx === global) {
        throw new MongooseError("`Model." + fnName + "()` cannot run without a model as `this`. Make sure you are calling `MyModel." + fnName + "()` where `MyModel` is a Mongoose model.");
      } else if (ctx[modelSymbol] == null) {
        throw new MongooseError("`Model." + fnName + "()` cannot run without a model as `this`. Make sure you are not calling `new Model." + fnName + "()`");
      }
    }
    for (const i in EventEmitter.prototype) {
      Model6[i] = EventEmitter.prototype[i];
    }
    Model6.init = function init(callback) {
      _checkContext(this, "init");
      this.schema.emit("init", this);
      if (this.$init != null) {
        if (callback) {
          this.$init.then(() => callback(), (err) => callback(err));
          return null;
        }
        return this.$init;
      }
      const Promise2 = PromiseProvider.get();
      const autoIndex = utils.getOption(
        "autoIndex",
        this.schema.options,
        this.db.config,
        this.db.base.options
      );
      const autoCreate = utils.getOption(
        "autoCreate",
        this.schema.options,
        this.db.config,
        this.db.base.options
      );
      const _ensureIndexes2 = autoIndex ? (cb) => this.ensureIndexes({ _automatic: true }, cb) : (cb) => cb();
      const _createCollection = autoCreate ? (cb) => this.createCollection({}, cb) : (cb) => cb();
      this.$init = new Promise2((resolve, reject) => {
        _createCollection((error) => {
          if (error) {
            return reject(error);
          }
          _ensureIndexes2((error2) => {
            if (error2) {
              return reject(error2);
            }
            resolve(this);
          });
        });
      });
      if (callback) {
        this.$init.then(() => callback(), (err) => callback(err));
        this.$caught = true;
        return null;
      } else {
        const _catch = this.$init.catch;
        const _this = this;
        this.$init.catch = function() {
          this.$caught = true;
          return _catch.apply(_this.$init, arguments);
        };
      }
      return this.$init;
    };
    Model6.createCollection = function createCollection(options, callback) {
      _checkContext(this, "createCollection");
      if (typeof options === "string") {
        throw new MongooseError("You can't specify a new collection name in Model.createCollection.This is not like Connection.createCollection. Only options are accepted here.");
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const schemaCollation = get(this, "schema.options.collation", null);
      if (schemaCollation != null) {
        options = Object.assign({ collation: schemaCollation }, options);
      }
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        this.db.createCollection(this.$__collection.collectionName, options, utils.tick((err) => {
          if (err != null && (err.name !== "MongoError" || err.code !== 48)) {
            return cb(err);
          }
          this.$__collection = this.db.collection(this.$__collection.collectionName, options);
          cb(null, this.$__collection);
        }));
      }, this.events);
    };
    Model6.syncIndexes = function syncIndexes(options, callback) {
      _checkContext(this, "syncIndexes");
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        this.createCollection((err) => {
          if (err != null && (err.name !== "MongoError" || err.code !== 48)) {
            return cb(err);
          }
          this.cleanIndexes((err2, dropped) => {
            if (err2 != null) {
              return cb(err2);
            }
            this.createIndexes(options, (err3) => {
              if (err3 != null) {
                return cb(err3);
              }
              cb(null, dropped);
            });
          });
        });
      }, this.events);
    };
    Model6.diffIndexes = function diffIndexes(options, callback) {
      const toDrop = [];
      const toCreate = [];
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        this.listIndexes((err, indexes) => {
          if (err) {
            if (err.codeName === "NamespaceNotFound") {
              indexes = [];
            } else {
              return cb(err, { toDrop, toCreate });
            }
          }
          const schemaIndexes = this.schema.indexes();
          for (const index of indexes) {
            let found = false;
            if (isDefaultIdIndex(index)) {
              continue;
            }
            for (const schemaIndex of schemaIndexes) {
              const key = schemaIndex[0];
              const options2 = _decorateDiscriminatorIndexOptions(
                this,
                utils.clone(schemaIndex[1])
              );
              if (isIndexEqual(key, options2, index)) {
                found = true;
              }
            }
            if (!found) {
              toDrop.push(index.name);
            }
          }
          for (const schemaIndex of schemaIndexes) {
            const key = schemaIndex[0];
            let found = false;
            const options2 = _decorateDiscriminatorIndexOptions(
              this,
              utils.clone(schemaIndex[1])
            );
            for (const index of indexes) {
              if (isDefaultIdIndex(index)) {
                continue;
              }
              if (isIndexEqual(key, options2, index)) {
                found = true;
              }
            }
            if (!found) {
              toCreate.push(key);
            }
          }
          cb(null, { toDrop, toCreate });
        });
      });
    };
    Model6.cleanIndexes = function cleanIndexes(callback) {
      _checkContext(this, "cleanIndexes");
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        const collection = this.$__collection;
        this.listIndexes((err, indexes) => {
          if (err != null) {
            return cb(err);
          }
          const schemaIndexes = this.schema.indexes();
          const toDrop = [];
          for (const index of indexes) {
            let found = false;
            if (isDefaultIdIndex(index)) {
              continue;
            }
            for (const schemaIndex of schemaIndexes) {
              const key = schemaIndex[0];
              const options = _decorateDiscriminatorIndexOptions(
                this,
                utils.clone(schemaIndex[1])
              );
              if (isIndexEqual(key, options, index)) {
                found = true;
              }
            }
            if (!found) {
              toDrop.push(index.name);
            }
          }
          if (toDrop.length === 0) {
            return cb(null, []);
          }
          dropIndexes(toDrop, cb);
        });
        function dropIndexes(toDrop, cb2) {
          let remaining = toDrop.length;
          let error = false;
          toDrop.forEach((indexName) => {
            collection.dropIndex(indexName, (err) => {
              if (err != null) {
                error = true;
                return cb2(err);
              }
              if (!error) {
                --remaining || cb2(null, toDrop);
              }
            });
          });
        }
      });
    };
    Model6.listIndexes = function init(callback) {
      _checkContext(this, "listIndexes");
      const _listIndexes = (cb) => {
        this.$__collection.listIndexes().toArray(cb);
      };
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        if (this.$__collection.buffer) {
          this.$__collection.addQueue(_listIndexes, [cb]);
        } else {
          _listIndexes(cb);
        }
      }, this.events);
    };
    Model6.ensureIndexes = function ensureIndexes(options, callback) {
      _checkContext(this, "ensureIndexes");
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        _ensureIndexes(this, options || {}, (error) => {
          if (error) {
            return cb(error);
          }
          cb(null);
        });
      }, this.events);
    };
    Model6.createIndexes = function createIndexes(options, callback) {
      _checkContext(this, "createIndexes");
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      options.createIndex = true;
      return this.ensureIndexes(options, callback);
    };
    function _ensureIndexes(model, options, callback) {
      const indexes = model.schema.indexes();
      let indexError;
      options = options || {};
      const done = function(err) {
        if (err && !model.$caught) {
          model.emit("error", err);
        }
        model.emit("index", err || indexError);
        callback && callback(err || indexError);
      };
      for (const index of indexes) {
        if (isDefaultIdIndex(index)) {
          console.warn('mongoose: Cannot specify a custom index on `_id` for model name "' + model.modelName + '", MongoDB does not allow overwriting the default `_id` index. See http://bit.ly/mongodb-id-index');
        }
      }
      if (!indexes.length) {
        immediate(function() {
          done();
        });
        return;
      }
      const indexSingleDone = function(err, fields, options2, name) {
        model.emit("index-single-done", err, fields, options2, name);
      };
      const indexSingleStart = function(fields, options2) {
        model.emit("index-single-start", fields, options2);
      };
      const baseSchema = model.schema._baseSchema;
      const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];
      const create = function() {
        if (options._automatic) {
          if (model.schema.options.autoIndex === false || model.schema.options.autoIndex == null && model.db.config.autoIndex === false) {
            return done();
          }
        }
        const index = indexes.shift();
        if (!index) {
          return done();
        }
        if (options._automatic && index[1]._autoIndex === false) {
          return create();
        }
        if (baseSchemaIndexes.find((i) => utils.deepEqual(i, index))) {
          return create();
        }
        const indexFields = utils.clone(index[0]);
        const indexOptions = utils.clone(index[1]);
        let isTextIndex = false;
        for (const key of Object.keys(indexFields)) {
          if (indexFields[key] === "text") {
            isTextIndex = true;
          }
        }
        delete indexOptions._autoIndex;
        _decorateDiscriminatorIndexOptions(model, indexOptions);
        if ("safe" in options) {
          _handleSafe(options);
        }
        applyWriteConcern(model.schema, indexOptions);
        indexSingleStart(indexFields, options);
        let useCreateIndex = !!model.base.options.useCreateIndex;
        if ("useCreateIndex" in model.db.config) {
          useCreateIndex = !!model.db.config.useCreateIndex;
        }
        if ("createIndex" in options) {
          useCreateIndex = !!options.createIndex;
        }
        if ("background" in options) {
          indexOptions.background = options.background;
        }
        if (model.schema.options.hasOwnProperty("collation") && !indexOptions.hasOwnProperty("collation") && !isTextIndex) {
          indexOptions.collation = model.schema.options.collation;
        }
        const methodName = useCreateIndex ? "createIndex" : "ensureIndex";
        model.collection[methodName](indexFields, indexOptions, utils.tick(function(err, name) {
          indexSingleDone(err, indexFields, indexOptions, name);
          if (err) {
            if (!indexError) {
              indexError = err;
            }
            if (!model.$caught) {
              model.emit("error", err);
            }
          }
          create();
        }));
      };
      immediate(function() {
        if (options._automatic && !model.collection.collection) {
          model.collection.addQueue(create, []);
        } else {
          create();
        }
      });
    }
    function _decorateDiscriminatorIndexOptions(model, indexOptions) {
      if (model.baseModelName != null && !("partialFilterExpression" in indexOptions) && !("sparse" in indexOptions)) {
        const value = model.schema.discriminatorMapping && model.schema.discriminatorMapping.value || model.modelName;
        const discriminatorKey = model.schema.options.discriminatorKey;
        indexOptions.partialFilterExpression = { [discriminatorKey]: value };
      }
      return indexOptions;
    }
    var safeDeprecationWarning = "Mongoose: the `safe` option for `save()` is deprecated. Use the `w` option instead: http://bit.ly/mongoose-save";
    var _handleSafe = util2.deprecate(function _handleSafe2(options) {
      if (options.safe) {
        if (typeof options.safe === "boolean") {
          options.w = options.safe;
          delete options.safe;
        }
        if (typeof options.safe === "object") {
          options.w = options.safe.w;
          options.j = options.safe.j;
          options.wtimeout = options.safe.wtimeout;
          delete options.safe;
        }
      }
    }, safeDeprecationWarning);
    Model6.schema;
    Model6.db;
    Model6.collection;
    Model6.$__collection;
    Model6.base;
    Model6.discriminators;
    Model6.translateAliases = function translateAliases(fields) {
      _checkContext(this, "translateAliases");
      const translate = (key, value) => {
        let alias;
        const translated = [];
        const fieldKeys = key.split(".");
        let currentSchema = this.schema;
        for (const i in fieldKeys) {
          const name = fieldKeys[i];
          if (currentSchema && currentSchema.aliases[name]) {
            alias = currentSchema.aliases[name];
            translated.push(alias);
          } else {
            translated.push(name);
          }
          if (currentSchema && currentSchema.paths[alias]) {
            currentSchema = currentSchema.paths[alias].schema;
          } else
            currentSchema = null;
        }
        const translatedKey = translated.join(".");
        if (fields instanceof Map)
          fields.set(translatedKey, value);
        else
          fields[translatedKey] = value;
        if (translatedKey !== key) {
          if (fields instanceof Map) {
            fields.delete(key);
          } else {
            delete fields[key];
          }
        }
        return fields;
      };
      if (typeof fields === "object") {
        if (fields instanceof Map) {
          for (const field of new Map(fields)) {
            fields = translate(field[0], field[1]);
          }
        } else {
          for (const key of Object.keys(fields)) {
            fields = translate(key, fields[key]);
            if (key[0] === "$") {
              if (Array.isArray(fields[key])) {
                for (const i in fields[key]) {
                  fields[key][i] = this.translateAliases(fields[key][i]);
                }
              }
            }
          }
        }
        return fields;
      } else {
        return fields;
      }
    };
    Model6.remove = function remove(conditions, options, callback) {
      _checkContext(this, "remove");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.setOptions(options);
      callback = this.$handleCallbackError(callback);
      return mq.remove(conditions, callback);
    };
    Model6.deleteOne = function deleteOne(conditions, options, callback) {
      _checkContext(this, "deleteOne");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.setOptions(options);
      callback = this.$handleCallbackError(callback);
      return mq.deleteOne(conditions, callback);
    };
    Model6.deleteMany = function deleteMany(conditions, options, callback) {
      _checkContext(this, "deleteMany");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.setOptions(options);
      callback = this.$handleCallbackError(callback);
      return mq.deleteMany(conditions, callback);
    };
    Model6.find = function find(conditions, projection, options, callback) {
      _checkContext(this, "find");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        projection = null;
        options = null;
      } else if (typeof projection === "function") {
        callback = projection;
        projection = null;
        options = null;
      } else if (typeof options === "function") {
        callback = options;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(projection);
      mq.setOptions(options);
      if (this.schema.discriminatorMapping && this.schema.discriminatorMapping.isRoot && mq.selectedInclusively()) {
        mq.select(this.schema.options.discriminatorKey);
      }
      callback = this.$handleCallbackError(callback);
      return mq.find(conditions, callback);
    };
    Model6.findById = function findById(id, projection, options, callback) {
      _checkContext(this, "findById");
      if (typeof id === "undefined") {
        id = null;
      }
      callback = this.$handleCallbackError(callback);
      return this.findOne({ _id: id }, projection, options, callback);
    };
    Model6.findOne = function findOne(conditions, projection, options, callback) {
      _checkContext(this, "findOne");
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (typeof projection === "function") {
        callback = projection;
        projection = null;
        options = null;
      } else if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
        projection = null;
        options = null;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(projection);
      mq.setOptions(options);
      if (this.schema.discriminatorMapping && this.schema.discriminatorMapping.isRoot && mq.selectedInclusively()) {
        mq.select(this.schema.options.discriminatorKey);
      }
      callback = this.$handleCallbackError(callback);
      return mq.findOne(conditions, callback);
    };
    Model6.estimatedDocumentCount = function estimatedDocumentCount(options, callback) {
      _checkContext(this, "estimatedDocumentCount");
      const mq = new this.Query({}, {}, this, this.$__collection);
      callback = this.$handleCallbackError(callback);
      return mq.estimatedDocumentCount(options, callback);
    };
    Model6.countDocuments = function countDocuments(conditions, callback) {
      _checkContext(this, "countDocuments");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      callback = this.$handleCallbackError(callback);
      return mq.countDocuments(conditions, callback);
    };
    Model6.count = function count(conditions, callback) {
      _checkContext(this, "count");
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      callback = this.$handleCallbackError(callback);
      return mq.count(conditions, callback);
    };
    Model6.distinct = function distinct(field, conditions, callback) {
      _checkContext(this, "distinct");
      const mq = new this.Query({}, {}, this, this.$__collection);
      if (typeof conditions === "function") {
        callback = conditions;
        conditions = {};
      }
      callback = this.$handleCallbackError(callback);
      return mq.distinct(field, conditions, callback);
    };
    Model6.where = function where(path3, val) {
      _checkContext(this, "where");
      const mq = new this.Query({}, {}, this, this.$__collection).find({});
      return mq.where.apply(mq, arguments);
    };
    Model6.$where = function $where2() {
      _checkContext(this, "$where");
      const mq = new this.Query({}, {}, this, this.$__collection).find({});
      return mq.$where.apply(mq, arguments);
    };
    Model6.findOneAndUpdate = function(conditions, update, options, callback) {
      _checkContext(this, "findOneAndUpdate");
      if (typeof options === "function") {
        callback = options;
        options = null;
      } else if (arguments.length === 1) {
        if (typeof conditions === "function") {
          const msg = "Model.findOneAndUpdate(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndUpdate(conditions, update, options, callback)\n  " + this.modelName + ".findOneAndUpdate(conditions, update, options)\n  " + this.modelName + ".findOneAndUpdate(conditions, update)\n  " + this.modelName + ".findOneAndUpdate(update)\n  " + this.modelName + ".findOneAndUpdate()\n";
          throw new TypeError(msg);
        }
        update = conditions;
        conditions = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options) {
        fields = options.fields || options.projection;
      }
      update = utils.clone(update, {
        depopulate: true,
        _isNested: true
      });
      _decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndUpdate(conditions, update, options, callback);
    };
    function _decorateUpdateWithVersionKey(update, options, versionKey) {
      if (!versionKey || !get(options, "upsert", false)) {
        return;
      }
      const updatedPaths = modifiedPaths(update);
      if (!updatedPaths[versionKey]) {
        if (options.overwrite) {
          update[versionKey] = 0;
        } else {
          if (!update.$setOnInsert) {
            update.$setOnInsert = {};
          }
          update.$setOnInsert[versionKey] = 0;
        }
      }
    }
    Model6.findByIdAndUpdate = function(id, update, options, callback) {
      _checkContext(this, "findByIdAndUpdate");
      callback = this.$handleCallbackError(callback);
      if (arguments.length === 1) {
        if (typeof id === "function") {
          const msg = "Model.findByIdAndUpdate(): First argument must not be a function.\n\n  " + this.modelName + ".findByIdAndUpdate(id, callback)\n  " + this.modelName + ".findByIdAndUpdate(id)\n  " + this.modelName + ".findByIdAndUpdate()\n";
          throw new TypeError(msg);
        }
        return this.findOneAndUpdate({ _id: id }, void 0);
      }
      if (id instanceof Document6) {
        id = id._id;
      }
      return this.findOneAndUpdate.call(this, { _id: id }, update, options, callback);
    };
    Model6.findOneAndDelete = function(conditions, options, callback) {
      _checkContext(this, "findOneAndDelete");
      if (arguments.length === 1 && typeof conditions === "function") {
        const msg = "Model.findOneAndDelete(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndDelete(conditions, callback)\n  " + this.modelName + ".findOneAndDelete(conditions)\n  " + this.modelName + ".findOneAndDelete()\n";
        throw new TypeError(msg);
      }
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options) {
        fields = options.select;
        options.select = void 0;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndDelete(conditions, options, callback);
    };
    Model6.findByIdAndDelete = function(id, options, callback) {
      _checkContext(this, "findByIdAndDelete");
      if (arguments.length === 1 && typeof id === "function") {
        const msg = "Model.findByIdAndDelete(): First argument must not be a function.\n\n  " + this.modelName + ".findByIdAndDelete(id, callback)\n  " + this.modelName + ".findByIdAndDelete(id)\n  " + this.modelName + ".findByIdAndDelete()\n";
        throw new TypeError(msg);
      }
      callback = this.$handleCallbackError(callback);
      return this.findOneAndDelete({ _id: id }, options, callback);
    };
    Model6.findOneAndReplace = function(filter, replacement, options, callback) {
      _checkContext(this, "findOneAndReplace");
      if (arguments.length === 1 && typeof filter === "function") {
        const msg = "Model.findOneAndReplace(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndReplace(conditions, callback)\n  " + this.modelName + ".findOneAndReplace(conditions)\n  " + this.modelName + ".findOneAndReplace()\n";
        throw new TypeError(msg);
      }
      if (arguments.length === 3 && typeof options === "function") {
        callback = options;
        options = replacement;
        replacement = void 0;
      }
      if (arguments.length === 2 && typeof replacement === "function") {
        callback = replacement;
        replacement = void 0;
        options = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options) {
        fields = options.select;
        options.select = void 0;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndReplace(filter, replacement, options, callback);
    };
    Model6.findOneAndRemove = function(conditions, options, callback) {
      _checkContext(this, "findOneAndRemove");
      if (arguments.length === 1 && typeof conditions === "function") {
        const msg = "Model.findOneAndRemove(): First argument must not be a function.\n\n  " + this.modelName + ".findOneAndRemove(conditions, callback)\n  " + this.modelName + ".findOneAndRemove(conditions)\n  " + this.modelName + ".findOneAndRemove()\n";
        throw new TypeError(msg);
      }
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      callback = this.$handleCallbackError(callback);
      let fields;
      if (options) {
        fields = options.select;
        options.select = void 0;
      }
      const mq = new this.Query({}, {}, this, this.$__collection);
      mq.select(fields);
      return mq.findOneAndRemove(conditions, options, callback);
    };
    Model6.findByIdAndRemove = function(id, options, callback) {
      _checkContext(this, "findByIdAndRemove");
      if (arguments.length === 1 && typeof id === "function") {
        const msg = "Model.findByIdAndRemove(): First argument must not be a function.\n\n  " + this.modelName + ".findByIdAndRemove(id, callback)\n  " + this.modelName + ".findByIdAndRemove(id)\n  " + this.modelName + ".findByIdAndRemove()\n";
        throw new TypeError(msg);
      }
      callback = this.$handleCallbackError(callback);
      return this.findOneAndRemove({ _id: id }, options, callback);
    };
    Model6.create = function create(doc, options, callback) {
      _checkContext(this, "create");
      let args;
      let cb;
      const discriminatorKey = this.schema.options.discriminatorKey;
      if (Array.isArray(doc)) {
        args = doc;
        cb = typeof options === "function" ? options : callback;
        options = options != null && typeof options === "object" ? options : {};
      } else {
        const last = arguments[arguments.length - 1];
        options = {};
        if (typeof last === "function" || arguments.length > 1 && !last) {
          cb = last;
          args = utils.args(arguments, 0, arguments.length - 1);
        } else {
          args = utils.args(arguments);
        }
        if (args.length === 2 && args[0] != null && args[1] != null && args[0].session == null && getConstructorName(last.session) === "ClientSession" && !this.schema.path("session")) {
          console.warn("WARNING: to pass a `session` to `Model.create()` in Mongoose, you **must** pass an array as the first argument. See: https://mongoosejs.com/docs/api.html#model_Model.create");
        }
      }
      return this.db.base._promiseOrCallback(cb, (cb2) => {
        cb2 = this.$wrapCallback(cb2);
        if (args.length === 0) {
          return cb2(null);
        }
        const toExecute = [];
        let firstError;
        args.forEach((doc2) => {
          toExecute.push((callback2) => {
            const Model7 = this.discriminators && doc2[discriminatorKey] != null ? this.discriminators[doc2[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc2[discriminatorKey]) : this;
            if (Model7 == null) {
              throw new MongooseError(`Discriminator "${doc2[discriminatorKey]}" not found for model "${this.modelName}"`);
            }
            let toSave = doc2;
            const callbackWrapper = (error, doc3) => {
              if (error) {
                if (!firstError) {
                  firstError = error;
                }
                return callback2(null, { error });
              }
              callback2(null, { doc: doc3 });
            };
            if (!(toSave instanceof Model7)) {
              try {
                toSave = new Model7(toSave);
              } catch (error) {
                return callbackWrapper(error);
              }
            }
            toSave.save(options, callbackWrapper);
          });
        });
        let numFns = toExecute.length;
        if (numFns === 0) {
          return cb2(null, []);
        }
        const _done = (error, res) => {
          const savedDocs = [];
          const len = res.length;
          for (let i = 0; i < len; ++i) {
            if (res[i].doc) {
              savedDocs.push(res[i].doc);
            }
          }
          if (firstError) {
            return cb2(firstError, savedDocs);
          }
          if (doc instanceof Array) {
            cb2(null, savedDocs);
          } else {
            cb2.apply(this, [null].concat(savedDocs));
          }
        };
        const _res = [];
        toExecute.forEach((fn, i) => {
          fn((err, res) => {
            _res[i] = res;
            if (--numFns <= 0) {
              return _done(null, _res);
            }
          });
        });
      }, this.events);
    };
    Model6.watch = function(pipeline, options) {
      _checkContext(this, "watch");
      const changeStreamThunk = (cb) => {
        if (this.$__collection.buffer) {
          this.$__collection.addQueue(() => {
            if (this.closed) {
              return;
            }
            const driverChangeStream = this.$__collection.watch(pipeline, options);
            cb(null, driverChangeStream);
          });
        } else {
          const driverChangeStream = this.$__collection.watch(pipeline, options);
          cb(null, driverChangeStream);
        }
      };
      return new ChangeStream(changeStreamThunk, pipeline, options);
    };
    Model6.startSession = function() {
      _checkContext(this, "startSession");
      return this.db.startSession.apply(this.db, arguments);
    };
    Model6.insertMany = function(arr, options, callback) {
      _checkContext(this, "insertMany");
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      return this.db.base._promiseOrCallback(callback, (cb) => {
        this.$__insertMany(arr, options, cb);
      }, this.events);
    };
    Model6.$__insertMany = function(arr, options, callback) {
      const _this = this;
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (callback) {
        callback = this.$handleCallbackError(callback);
        callback = this.$wrapCallback(callback);
      }
      callback = callback || utils.noop;
      options = options || {};
      const limit = get(options, "limit", 1e3);
      const rawResult = get(options, "rawResult", false);
      const ordered = get(options, "ordered", true);
      const lean = get(options, "lean", false);
      if (!Array.isArray(arr)) {
        arr = [arr];
      }
      const validationErrors = [];
      const toExecute = arr.map((doc) => (callback2) => {
        if (!(doc instanceof _this)) {
          try {
            doc = new _this(doc);
          } catch (err) {
            return callback2(err);
          }
        }
        if (options.session != null) {
          doc.$session(options.session);
        }
        if (lean) {
          return immediate(() => callback2(null, doc));
        }
        doc.validate({ __noPromise: true }, function(error) {
          if (error) {
            if (ordered === false) {
              validationErrors.push(error);
              return callback2(null, null);
            }
            return callback2(error);
          }
          callback2(null, doc);
        });
      });
      parallelLimit(toExecute, limit, function(error, docs) {
        if (error) {
          callback(error, null);
          return;
        }
        const docAttributes = docs.filter(function(doc) {
          return doc != null;
        });
        if (docAttributes.length < 1) {
          if (rawResult) {
            const res = {
              mongoose: {
                validationErrors
              }
            };
            return callback(null, res);
          }
          callback(null, []);
          return;
        }
        const docObjects = docAttributes.map(function(doc) {
          if (doc.$__schema.options.versionKey) {
            doc[doc.$__schema.options.versionKey] = 0;
          }
          if (doc.initializeTimestamps) {
            return doc.initializeTimestamps().toObject(internalToObjectOptions);
          }
          return doc.toObject(internalToObjectOptions);
        });
        _this.$__collection.insertMany(docObjects, options, function(error2, res) {
          if (error2) {
            if (error2.writeErrors == null && get(error2, "result.result.writeErrors") != null) {
              error2.writeErrors = error2.result.result.writeErrors;
            }
            const erroredIndexes = new Set(get(error2, "writeErrors", []).map((err) => err.index));
            let firstErroredIndex = -1;
            error2.insertedDocs = docAttributes.filter((doc, i) => {
              const isErrored = erroredIndexes.has(i);
              if (ordered) {
                if (firstErroredIndex > -1) {
                  return i < firstErroredIndex;
                }
                if (isErrored) {
                  firstErroredIndex = i;
                }
              }
              return !isErrored;
            }).map(function setIsNewForInsertedDoc(doc) {
              doc.$__reset();
              _setIsNew(doc, false);
              return doc;
            });
            callback(error2, null);
            return;
          }
          for (const attribute of docAttributes) {
            attribute.$__reset();
            _setIsNew(attribute, false);
          }
          if (rawResult) {
            if (ordered === false) {
              res.mongoose = {
                validationErrors
              };
            }
            return callback(null, res);
          }
          if (options.populate != null) {
            return _this.populate(docAttributes, options.populate, (err) => {
              if (err != null) {
                error2.insertedDocs = docAttributes;
                return callback(err);
              }
              callback(null, docs);
            });
          }
          callback(null, docAttributes);
        });
      });
    };
    function _setIsNew(doc, val) {
      doc.isNew = val;
      doc.emit("isNew", val);
      doc.constructor.emit("isNew", val);
      const subdocs = doc.$getAllSubdocs();
      for (const subdoc of subdocs) {
        subdoc.isNew = val;
      }
    }
    Model6.bulkWrite = function(ops, options, callback) {
      _checkContext(this, "bulkWrite");
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      options = options || {};
      const validations = ops.map((op) => castBulkWrite(this, op, options));
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        each(validations, (fn, cb2) => fn(cb2), (error) => {
          if (error) {
            return cb(error);
          }
          if (ops.length === 0) {
            return cb(null, getDefaultBulkwriteResult());
          }
          this.$__collection.bulkWrite(ops, options, (error2, res) => {
            if (error2) {
              return cb(error2);
            }
            cb(null, res);
          });
        });
      }, this.events);
    };
    Model6.bulkSave = function(documents) {
      const preSavePromises = documents.map(buildPreSavePromise);
      const writeOperations = this.buildBulkWriteOperations(documents, { skipValidation: true });
      let bulkWriteResultPromise;
      return Promise.all(preSavePromises).then(() => bulkWriteResultPromise = this.bulkWrite(writeOperations)).then(() => documents.map(buildSuccessfulWriteHandlerPromise)).then(() => bulkWriteResultPromise).catch((err) => {
        if (!get(err, "writeErrors.length")) {
          throw err;
        }
        return Promise.all(
          documents.map((document2) => {
            const documentError = err.writeErrors.find((writeError) => {
              const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;
              return writeErrorDocumentId.toString() === document2._id.toString();
            });
            if (documentError == null) {
              return buildSuccessfulWriteHandlerPromise(document2);
            }
          })
        ).then(() => {
          throw err;
        });
      });
    };
    function buildPreSavePromise(document2) {
      return new Promise((resolve, reject) => {
        document2.schema.s.hooks.execPre("save", document2, (err) => {
          if (err) {
            reject(err);
            return;
          }
          resolve();
        });
      });
    }
    function buildSuccessfulWriteHandlerPromise(document2) {
      return new Promise((resolve, reject) => {
        handleSuccessfulWrite(document2, resolve, reject);
      });
    }
    function handleSuccessfulWrite(document2, resolve, reject) {
      if (document2.isNew) {
        _setIsNew(document2, false);
      }
      document2.$__reset();
      document2.schema.s.hooks.execPost("save", document2, {}, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    }
    Model6.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {
      if (!Array.isArray(documents)) {
        throw new Error(`bulkSave expects an array of documents to be passed, received \`${documents}\` instead`);
      }
      setDefaultOptions();
      const writeOperations = documents.reduce((accumulator, document2, i) => {
        if (!options.skipValidation) {
          if (!(document2 instanceof Document6)) {
            throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);
          }
          const validationError = document2.validateSync();
          if (validationError) {
            throw validationError;
          }
        }
        const isANewDocument = document2.isNew;
        if (isANewDocument) {
          accumulator.push({
            insertOne: { document: document2 }
          });
          return accumulator;
        }
        const delta = document2.$__delta();
        const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);
        if (isDocumentWithChanges) {
          const where = document2.$__where(delta[0]);
          const changes = delta[1];
          _applyCustomWhere(document2, where);
          document2.$__version(where, delta);
          accumulator.push({
            updateOne: {
              filter: where,
              update: changes
            }
          });
          return accumulator;
        }
        return accumulator;
      }, []);
      return writeOperations;
      function setDefaultOptions() {
        options = options || {};
        if (options.skipValidation == null) {
          options.skipValidation = false;
        }
      }
    };
    Model6.hydrate = function(obj2, projection) {
      _checkContext(this, "hydrate");
      const model = require_queryhelpers().createModel(this, obj2, projection);
      model.init(obj2);
      return model;
    };
    Model6.update = function update(conditions, doc, options, callback) {
      _checkContext(this, "update");
      return _update(this, "update", conditions, doc, options, callback);
    };
    Model6.updateMany = function updateMany(conditions, doc, options, callback) {
      _checkContext(this, "updateMany");
      return _update(this, "updateMany", conditions, doc, options, callback);
    };
    Model6.updateOne = function updateOne(conditions, doc, options, callback) {
      _checkContext(this, "updateOne");
      return _update(this, "updateOne", conditions, doc, options, callback);
    };
    Model6.replaceOne = function replaceOne(conditions, doc, options, callback) {
      _checkContext(this, "replaceOne");
      const versionKey = get(this, "schema.options.versionKey", null);
      if (versionKey && !doc[versionKey]) {
        doc[versionKey] = 0;
      }
      return _update(this, "replaceOne", conditions, doc, options, callback);
    };
    function _update(model, op, conditions, doc, options, callback) {
      const mq = new model.Query({}, {}, model, model.collection);
      callback = model.$handleCallbackError(callback);
      if (conditions instanceof Document6) {
        conditions = conditions.toObject();
      } else {
        conditions = utils.clone(conditions);
      }
      options = typeof options === "function" ? options : utils.clone(options);
      const versionKey = get(model, "schema.options.versionKey", null);
      _decorateUpdateWithVersionKey(doc, options, versionKey);
      return mq[op](conditions, doc, options, callback);
    }
    Model6.mapReduce = function mapReduce(o, callback) {
      _checkContext(this, "mapReduce");
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        if (!Model6.mapReduce.schema) {
          const opts = { noId: true, noVirtualId: true, strict: false };
          Model6.mapReduce.schema = new Schema6({}, opts);
        }
        if (!o.out)
          o.out = { inline: 1 };
        if (o.verbose !== false)
          o.verbose = true;
        o.map = String(o.map);
        o.reduce = String(o.reduce);
        if (o.query) {
          let q = new this.Query(o.query);
          q.cast(this);
          o.query = q._conditions;
          q = void 0;
        }
        this.$__collection.mapReduce(null, null, o, (err, res) => {
          if (err) {
            return cb(err);
          }
          if (res.collection) {
            const model = Model6.compile(
              "_mapreduce_" + res.collection.collectionName,
              Model6.mapReduce.schema,
              res.collection.collectionName,
              this.db,
              this.base
            );
            model._mapreduce = true;
            res.model = model;
            return cb(null, res);
          }
          cb(null, res);
        });
      }, this.events);
    };
    Model6.aggregate = function aggregate(pipeline, callback) {
      _checkContext(this, "aggregate");
      if (arguments.length > 2 || get(pipeline, "constructor.name") === "Object") {
        throw new MongooseError("Mongoose 5.x disallows passing a spread of operators to `Model.aggregate()`. Instead of `Model.aggregate({ $match }, { $skip })`, do `Model.aggregate([{ $match }, { $skip }])`");
      }
      if (typeof pipeline === "function") {
        callback = pipeline;
        pipeline = [];
      }
      const aggregate2 = new Aggregate(pipeline || []);
      aggregate2.model(this);
      if (typeof callback === "undefined") {
        return aggregate2;
      }
      callback = this.$handleCallbackError(callback);
      callback = this.$wrapCallback(callback);
      aggregate2.exec(callback);
      return aggregate2;
    };
    Model6.validate = function validate(obj2, pathsToValidate, context, callback) {
      if (arguments.length < 3 || arguments.length === 3 && typeof arguments[2] === "function") {
        context = obj2;
      }
      return this.db.base._promiseOrCallback(callback, (cb) => {
        const schema = this.schema;
        let paths = Object.keys(schema.paths);
        if (pathsToValidate != null) {
          const _pathsToValidate = new Set(pathsToValidate);
          paths = paths.filter((p) => {
            const pieces = p.split(".");
            let cur = pieces[0];
            for (const piece of pieces) {
              if (_pathsToValidate.has(cur)) {
                return true;
              }
              cur += "." + piece;
            }
            return _pathsToValidate.has(p);
          });
        }
        for (const path3 of paths) {
          const schemaType = schema.path(path3);
          if (!schemaType || !schemaType.$isMongooseArray) {
            continue;
          }
          const val = get(obj2, path3);
          pushNestedArrayPaths(val, path3);
        }
        let remaining = paths.length;
        let error = null;
        for (const path3 of paths) {
          const schemaType = schema.path(path3);
          if (schemaType == null) {
            _checkDone();
            continue;
          }
          const pieces = path3.split(".");
          let cur = obj2;
          for (let i = 0; i < pieces.length - 1; ++i) {
            cur = cur[pieces[i]];
          }
          let val = get(obj2, path3, void 0);
          if (val != null) {
            try {
              val = schemaType.cast(val);
              cur[pieces[pieces.length - 1]] = val;
            } catch (err) {
              error = error || new ValidationError();
              error.addError(path3, err);
              _checkDone();
              continue;
            }
          }
          schemaType.doValidate(val, (err) => {
            if (err) {
              error = error || new ValidationError();
              if (err instanceof ValidationError) {
                for (const _err of Object.keys(err.errors)) {
                  error.addError(`${path3}.${err.errors[_err].path}`, _err);
                }
              } else {
                error.addError(err.path, err);
              }
            }
            _checkDone();
          }, context, { path: path3 });
        }
        function pushNestedArrayPaths(nestedArray, path3) {
          if (nestedArray == null) {
            return;
          }
          for (let i = 0; i < nestedArray.length; ++i) {
            if (Array.isArray(nestedArray[i])) {
              pushNestedArrayPaths(nestedArray[i], path3 + "." + i);
            } else {
              paths.push(path3 + "." + i);
            }
          }
        }
        function _checkDone() {
          if (--remaining <= 0) {
            return cb(error);
          }
        }
      });
    };
    Model6.geoSearch = function(conditions, options, callback) {
      _checkContext(this, "geoSearch");
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        let error;
        if (conditions === void 0 || !utils.isObject(conditions)) {
          error = new MongooseError("Must pass conditions to geoSearch");
        } else if (!options.near) {
          error = new MongooseError("Must specify the near option in geoSearch");
        } else if (!Array.isArray(options.near)) {
          error = new MongooseError("near option must be an array [x, y]");
        }
        if (error) {
          return cb(error);
        }
        options.search = conditions;
        this.$__collection.geoHaystackSearch(options.near[0], options.near[1], options, (err, res) => {
          if (err) {
            return cb(err);
          }
          let count = res.results.length;
          if (options.lean || count === 0) {
            return cb(null, res.results);
          }
          const errSeen = false;
          function init(err2) {
            if (err2 && !errSeen) {
              return cb(err2);
            }
            if (!--count && !errSeen) {
              cb(null, res.results);
            }
          }
          for (let i = 0; i < res.results.length; ++i) {
            const temp = res.results[i];
            res.results[i] = new this();
            res.results[i].init(temp, {}, init);
          }
        });
      }, this.events);
    };
    Model6.populate = function(docs, paths, callback) {
      _checkContext(this, "populate");
      const _this = this;
      paths = utils.populate(paths);
      const cache = {};
      callback = this.$handleCallbackError(callback);
      return this.db.base._promiseOrCallback(callback, (cb) => {
        cb = this.$wrapCallback(cb);
        _populate(_this, docs, paths, cache, cb);
      }, this.events);
    };
    function _populate(model, docs, paths, cache, callback) {
      let pending = paths.length;
      if (paths.length === 0) {
        return callback(null, docs);
      }
      for (const path3 of paths) {
        populate(model, docs, path3, next);
      }
      function next(err) {
        if (err) {
          return callback(err, null);
        }
        if (--pending) {
          return;
        }
        callback(null, docs);
      }
    }
    var excludeIdReg = /\s?-_id\s?/;
    var excludeIdRegGlobal = /\s?-_id\s?/g;
    function populate(model, docs, options, callback) {
      if (!Array.isArray(docs)) {
        docs = [docs];
      }
      if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {
        return callback();
      }
      const modelsMap = getModelsMapForPopulate(model, docs, options);
      if (modelsMap instanceof MongooseError) {
        return immediate(function() {
          callback(modelsMap);
        });
      }
      const len = modelsMap.length;
      let vals = [];
      function flatten(item) {
        return void 0 !== item;
      }
      let _remaining = len;
      let hasOne = false;
      const params = [];
      for (let i = 0; i < len; ++i) {
        const mod = modelsMap[i];
        let select = mod.options.select;
        let ids = utils.array.flatten(mod.ids, flatten);
        ids = utils.array.unique(ids);
        const assignmentOpts = {};
        assignmentOpts.sort = get(mod, "options.options.sort", void 0);
        assignmentOpts.excludeId = excludeIdReg.test(select) || select && select._id === 0;
        if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {
          --_remaining;
          if (mod.count || mod.isVirtual) {
            _assign(model, [], mod, assignmentOpts);
          }
          continue;
        }
        hasOne = true;
        const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);
        if (assignmentOpts.excludeId) {
          if (typeof select === "string") {
            select = select.replace(excludeIdRegGlobal, " ");
          } else {
            select = utils.object.shallowCopy(select);
            delete select._id;
          }
        }
        if (mod.options.options && mod.options.options.limit != null) {
          assignmentOpts.originalLimit = mod.options.options.limit;
        } else if (mod.options.limit != null) {
          assignmentOpts.originalLimit = mod.options.limit;
        }
        params.push([mod, match, select, assignmentOpts, _next]);
      }
      if (!hasOne) {
        if (options.populate != null) {
          const opts = utils.populate(options.populate).map((pop) => Object.assign({}, pop, {
            path: options.path + "." + pop.path
          }));
          return model.populate(docs, opts, callback);
        }
        return callback();
      }
      for (const arr of params) {
        _execPopulateQuery.apply(null, arr);
      }
      function _next(err, valsFromDb) {
        if (err != null) {
          return callback(err, null);
        }
        vals = vals.concat(valsFromDb);
        if (--_remaining === 0) {
          _done();
        }
      }
      function _done() {
        for (const arr of params) {
          const mod = arr[0];
          const assignmentOpts = arr[3];
          for (const val of vals) {
            mod.options._childDocs.push(val);
          }
          _assign(model, vals, mod, assignmentOpts);
        }
        for (const arr of params) {
          removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);
        }
        callback();
      }
    }
    function _execPopulateQuery(mod, match, select, assignmentOpts, callback) {
      const subPopulate = utils.clone(mod.options.populate);
      const queryOptions = Object.assign({
        skip: mod.options.skip,
        limit: mod.options.limit,
        perDocumentLimit: mod.options.perDocumentLimit
      }, mod.options.options);
      if (mod.count) {
        delete queryOptions.skip;
      }
      if (queryOptions.perDocumentLimit != null) {
        queryOptions.limit = queryOptions.perDocumentLimit;
        delete queryOptions.perDocumentLimit;
      } else if (queryOptions.limit != null) {
        queryOptions.limit = queryOptions.limit * mod.ids.length;
      }
      const query = mod.model.find(match, select, queryOptions);
      for (const foreignField of mod.foreignField) {
        if (foreignField !== "_id" && query.selectedInclusively() && !isPathSelectedInclusive(query._fields, foreignField)) {
          query.select(foreignField);
        }
      }
      if (mod.count) {
        for (const foreignField of mod.foreignField) {
          query.select(foreignField);
        }
      }
      if (subPopulate) {
        query.populate(subPopulate);
      }
      query.exec((err, docs) => {
        if (err != null) {
          return callback(err);
        }
        for (const val of docs) {
          leanPopulateMap.set(val, mod.model);
        }
        callback(null, docs);
      });
    }
    function _assign(model, vals, mod, assignmentOpts) {
      const options = mod.options;
      const isVirtual = mod.isVirtual;
      const justOne = mod.justOne;
      let _val;
      const lean = get(options, "options.lean", false);
      const len = vals.length;
      const rawOrder = {};
      const rawDocs = {};
      let key;
      let val;
      const allIds = utils.clone(mod.allIds);
      for (let i = 0; i < len; i++) {
        val = vals[i];
        if (val == null) {
          continue;
        }
        for (const foreignField of mod.foreignField) {
          _val = utils.getValue(foreignField, val);
          if (Array.isArray(_val)) {
            _val = utils.array.unique(utils.array.flatten(_val));
            for (let __val of _val) {
              if (__val instanceof Document6) {
                __val = __val._id;
              }
              key = String(__val);
              if (rawDocs[key]) {
                if (Array.isArray(rawDocs[key])) {
                  rawDocs[key].push(val);
                  rawOrder[key].push(i);
                } else {
                  rawDocs[key] = [rawDocs[key], val];
                  rawOrder[key] = [rawOrder[key], i];
                }
              } else {
                if (isVirtual && !justOne) {
                  rawDocs[key] = [val];
                  rawOrder[key] = [i];
                } else {
                  rawDocs[key] = val;
                  rawOrder[key] = i;
                }
              }
            }
          } else {
            if (_val instanceof Document6) {
              _val = _val._id;
            }
            key = String(_val);
            if (rawDocs[key]) {
              if (Array.isArray(rawDocs[key])) {
                rawDocs[key].push(val);
                rawOrder[key].push(i);
              } else if (isVirtual || rawDocs[key].constructor !== val.constructor || String(rawDocs[key]._id) !== String(val._id)) {
                rawDocs[key] = [rawDocs[key], val];
                rawOrder[key] = [rawOrder[key], i];
              }
            } else {
              rawDocs[key] = val;
              rawOrder[key] = i;
            }
          }
          if (!lean) {
            val.$__.wasPopulated = true;
          }
        }
      }
      assignVals({
        originalModel: model,
        // If virtual, make sure to not mutate original field
        rawIds: mod.isVirtual ? allIds : mod.allIds,
        allIds,
        foreignField: mod.foreignField,
        rawDocs,
        rawOrder,
        docs: mod.docs,
        path: options.path,
        options: assignmentOpts,
        justOne: mod.justOne,
        isVirtual: mod.isVirtual,
        allOptions: mod,
        populatedModel: mod.model,
        lean,
        virtual: mod.virtual,
        count: mod.count,
        match: mod.match
      });
    }
    Model6.compile = function compile(name, schema, collectionName, connection, base) {
      const versioningEnabled = schema.options.versionKey !== false;
      if (versioningEnabled && !schema.paths[schema.options.versionKey]) {
        const o = {};
        o[schema.options.versionKey] = Number;
        schema.add(o);
      }
      let model;
      if (typeof name === "function" && name.prototype instanceof Model6) {
        model = name;
        name = model.name;
        schema.loadClass(model, false);
        model.prototype.$isMongooseModelPrototype = true;
      } else {
        model = function model2(doc, fields, skipId) {
          model2.hooks.execPreSync("createModel", doc);
          if (!(this instanceof model2)) {
            return new model2(doc, fields, skipId);
          }
          const discriminatorKey = model2.schema.options.discriminatorKey;
          if (model2.discriminators == null || doc == null || doc[discriminatorKey] == null) {
            Model6.call(this, doc, fields, skipId);
            return;
          }
          const Discriminator = model2.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(model2.discriminators, doc[discriminatorKey]);
          if (Discriminator != null) {
            return new Discriminator(doc, fields, skipId);
          }
          Model6.call(this, doc, fields, skipId);
        };
      }
      model.hooks = schema.s.hooks.clone();
      model.base = base;
      model.modelName = name;
      if (!(model.prototype instanceof Model6)) {
        model.__proto__ = Model6;
        model.prototype.__proto__ = Model6.prototype;
      }
      model.model = function model2(name2) {
        return this.db.model(name2);
      };
      model.db = connection;
      model.prototype.db = connection;
      model.prototype[modelDbSymbol] = connection;
      model.discriminators = model.prototype.discriminators = void 0;
      model[modelSymbol] = true;
      model.events = new EventEmitter();
      model.prototype.$__setSchema(schema);
      const _userProvidedOptions = schema._userProvidedOptions || {};
      const collectionOptions = {
        schemaUserProvidedOptions: _userProvidedOptions,
        capped: schema.options.capped,
        Promise: model.base.Promise,
        modelName: name
      };
      if (schema.options.autoCreate !== void 0) {
        collectionOptions.autoCreate = schema.options.autoCreate;
      }
      model.prototype.collection = connection.collection(
        collectionName,
        collectionOptions
      );
      model.prototype[modelCollectionSymbol] = model.prototype.collection;
      applyMethods(model, schema);
      applyStatics(model, schema);
      applyHooks(model, schema);
      applyStaticHooks(model, schema.s.hooks, schema.statics);
      model.schema = model.prototype.$__schema;
      model.collection = model.prototype.collection;
      model.$__collection = model.collection;
      model.Query = function() {
        Query.apply(this, arguments);
      };
      model.Query.prototype = Object.create(Query.prototype);
      model.Query.base = Query.base;
      applyQueryMiddleware(model.Query, model);
      applyQueryMethods(model, schema.query);
      return model;
    };
    function applyQueryMethods(model, methods) {
      for (const i in methods) {
        model.Query.prototype[i] = methods[i];
      }
    }
    Model6.__subclass = function subclass(conn, schema, collection) {
      const _this = this;
      const Model7 = function Model8(doc, fields, skipId) {
        if (!(this instanceof Model8)) {
          return new Model8(doc, fields, skipId);
        }
        _this.call(this, doc, fields, skipId);
      };
      Model7.__proto__ = _this;
      Model7.prototype.__proto__ = _this.prototype;
      Model7.db = conn;
      Model7.prototype.db = conn;
      Model7.prototype[modelDbSymbol] = conn;
      _this[subclassedSymbol] = _this[subclassedSymbol] || [];
      _this[subclassedSymbol].push(Model7);
      if (_this.discriminators != null) {
        Model7.discriminators = {};
        for (const key of Object.keys(_this.discriminators)) {
          Model7.discriminators[key] = _this.discriminators[key].__subclass(_this.db, _this.discriminators[key].schema, collection);
        }
      }
      const s = schema && typeof schema !== "string" ? schema : _this.prototype.$__schema;
      const options = s.options || {};
      const _userProvidedOptions = s._userProvidedOptions || {};
      if (!collection) {
        collection = _this.prototype.$__schema.get("collection") || utils.toCollectionName(_this.modelName, this.base.pluralize());
      }
      const collectionOptions = {
        schemaUserProvidedOptions: _userProvidedOptions,
        capped: s && options.capped
      };
      Model7.prototype.collection = conn.collection(collection, collectionOptions);
      Model7.prototype[modelCollectionSymbol] = Model7.prototype.collection;
      Model7.collection = Model7.prototype.collection;
      Model7.$__collection = Model7.collection;
      Model7.init(() => {
      });
      return Model7;
    };
    Model6.$handleCallbackError = function(callback) {
      if (callback == null) {
        return callback;
      }
      if (typeof callback !== "function") {
        throw new MongooseError("Callback must be a function, got " + callback);
      }
      const _this = this;
      return function() {
        immediate(() => {
          try {
            callback.apply(null, arguments);
          } catch (error) {
            _this.emit("error", error);
          }
        });
      };
    };
    Model6.$wrapCallback = function(callback) {
      const serverSelectionError = new ServerSelectionError();
      const _this = this;
      return function(err) {
        if (err != null && err.name === "MongoServerSelectionError") {
          arguments[0] = serverSelectionError.assimilateError(err);
        }
        if (err != null && err.name === "MongoNetworkTimeoutError" && err.message.endsWith("timed out")) {
          _this.db.emit("timeout");
        }
        return callback.apply(null, arguments);
      };
    };
    Model6.inspect = function() {
      return `Model { ${this.modelName} }`;
    };
    if (util2.inspect.custom) {
      Model6[util2.inspect.custom] = Model6.inspect;
    }
    module2.exports = exports2 = Model6;
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose-legacy-pluralize@1.0.2_mongoose@5.13.16/node_modules/mongoose-legacy-pluralize/index.js
var require_mongoose_legacy_pluralize = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose-legacy-pluralize@1.0.2_mongoose@5.13.16/node_modules/mongoose-legacy-pluralize/index.js"(exports2, module2) {
    init_cjs_shims();
    module2.exports = pluralize;
    exports2.pluralization = [
      [/(m)an$/gi, "$1en"],
      [/(pe)rson$/gi, "$1ople"],
      [/(child)$/gi, "$1ren"],
      [/^(ox)$/gi, "$1en"],
      [/(ax|test)is$/gi, "$1es"],
      [/(octop|vir)us$/gi, "$1i"],
      [/(alias|status)$/gi, "$1es"],
      [/(bu)s$/gi, "$1ses"],
      [/(buffal|tomat|potat)o$/gi, "$1oes"],
      [/([ti])um$/gi, "$1a"],
      [/sis$/gi, "ses"],
      [/(?:([^f])fe|([lr])f)$/gi, "$1$2ves"],
      [/(hive)$/gi, "$1s"],
      [/([^aeiouy]|qu)y$/gi, "$1ies"],
      [/(x|ch|ss|sh)$/gi, "$1es"],
      [/(matr|vert|ind)ix|ex$/gi, "$1ices"],
      [/([m|l])ouse$/gi, "$1ice"],
      [/(kn|w|l)ife$/gi, "$1ives"],
      [/(quiz)$/gi, "$1zes"],
      [/s$/gi, "s"],
      [/([^a-z])$/, "$1"],
      [/$/gi, "s"]
    ];
    var rules = exports2.pluralization;
    exports2.uncountables = [
      "advice",
      "energy",
      "excretion",
      "digestion",
      "cooperation",
      "health",
      "justice",
      "labour",
      "machinery",
      "equipment",
      "information",
      "pollution",
      "sewage",
      "paper",
      "money",
      "species",
      "series",
      "rain",
      "rice",
      "fish",
      "sheep",
      "moose",
      "deer",
      "news",
      "expertise",
      "status",
      "media"
    ];
    var uncountables = exports2.uncountables;
    function pluralize(str) {
      var found;
      str = str.toLowerCase();
      if (!~uncountables.indexOf(str)) {
        found = rules.filter(function(rule) {
          return str.match(rule[0]);
        });
        if (found[0]) {
          return str.replace(found[0][0], found[0][1]);
        }
      }
      return str;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/plugins/removeSubdocs.js
var require_removeSubdocs = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/plugins/removeSubdocs.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var each = require_each2();
    module2.exports = function(schema) {
      const unshift = true;
      schema.s.hooks.pre("remove", false, function(next) {
        if (this.ownerDocument) {
          next();
          return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        each(subdocs, function(subdoc, cb) {
          subdoc.$__remove(cb);
        }, function(error) {
          if (error) {
            return _this.$__schema.s.hooks.execPost("remove:error", _this, [_this], { error }, function(error2) {
              next(error2);
            });
          }
          next();
        });
      }, null, unshift);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/plugins/saveSubdocs.js
var require_saveSubdocs = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/plugins/saveSubdocs.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var each = require_each2();
    module2.exports = function(schema) {
      const unshift = true;
      schema.s.hooks.pre("save", false, function(next) {
        if (this.ownerDocument) {
          next();
          return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        if (!subdocs.length) {
          next();
          return;
        }
        each(subdocs, function(subdoc, cb) {
          subdoc.$__schema.s.hooks.execPre("save", subdoc, function(err) {
            cb(err);
          });
        }, function(error) {
          if (error) {
            return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
              next(error2);
            });
          }
          next();
        });
      }, null, unshift);
      schema.s.hooks.post("save", function(doc, next) {
        if (this.ownerDocument) {
          next();
          return;
        }
        const _this = this;
        const subdocs = this.$getAllSubdocs();
        if (!subdocs.length) {
          next();
          return;
        }
        each(subdocs, function(subdoc, cb) {
          subdoc.$__schema.s.hooks.execPost("save", subdoc, [subdoc], function(err) {
            cb(err);
          });
        }, function(error) {
          if (error) {
            return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
              next(error2);
            });
          }
          next();
        });
      }, null, unshift);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/plugins/trackTransaction.js
var require_trackTransaction = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/plugins/trackTransaction.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
    var sessionNewDocuments = require_symbols().sessionNewDocuments;
    module2.exports = function trackTransaction(schema) {
      schema.pre("save", function() {
        const session = this.$session();
        if (session == null) {
          return;
        }
        if (session.transaction == null || session[sessionNewDocuments] == null) {
          return;
        }
        if (!session[sessionNewDocuments].has(this)) {
          const initialState = {};
          if (this.isNew) {
            initialState.isNew = true;
          }
          if (this.$__schema.options.versionKey) {
            initialState.versionKey = this.get(this.$__schema.options.versionKey);
          }
          initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.states.modify));
          initialState.atomics = _getAtomics(this);
          session[sessionNewDocuments].set(this, initialState);
        } else {
          const state = session[sessionNewDocuments].get(this);
          for (const path3 of Object.keys(this.$__.activePaths.states.modify)) {
            state.modifiedPaths.add(path3);
          }
          state.atomics = _getAtomics(this, state.atomics);
        }
      });
    };
    function _getAtomics(doc, previous) {
      const pathToAtomics = /* @__PURE__ */ new Map();
      previous = previous || /* @__PURE__ */ new Map();
      const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));
      for (const path3 of pathsToCheck) {
        const val = doc.$__getValue(path3);
        if (val != null && val instanceof Array && val.isMongooseDocumentArray && val.length && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length > 0) {
          const existing = previous.get(path3) || {};
          pathToAtomics.set(path3, mergeAtomics(existing, val[arrayAtomicsSymbol]));
        }
      }
      const dirty = doc.$__dirty();
      for (const dirt of dirty) {
        const path3 = dirt.path;
        const val = dirt.value;
        if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length > 0) {
          const existing = previous.get(path3) || {};
          pathToAtomics.set(path3, mergeAtomics(existing, val[arrayAtomicsSymbol]));
        }
      }
      return pathToAtomics;
    }
    function mergeAtomics(destination, source) {
      destination = destination || {};
      if (source.$pullAll != null) {
        destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);
      }
      if (source.$push != null) {
        destination.$push = destination.$push || {};
        destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);
      }
      if (source.$addToSet != null) {
        destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);
      }
      if (source.$set != null) {
        destination.$set = Object.assign(destination.$set || {}, source.$set);
      }
      return destination;
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/plugins/validateBeforeSave.js
var require_validateBeforeSave = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/plugins/validateBeforeSave.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function(schema) {
      const unshift = true;
      schema.pre("save", false, function validateBeforeSave(next, options) {
        const _this = this;
        if (this.ownerDocument) {
          return next();
        }
        const hasValidateBeforeSaveOption = options && typeof options === "object" && "validateBeforeSave" in options;
        let shouldValidate;
        if (hasValidateBeforeSaveOption) {
          shouldValidate = !!options.validateBeforeSave;
        } else {
          shouldValidate = this.$__schema.options.validateBeforeSave;
        }
        if (shouldValidate) {
          const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
          const validateOptions = hasValidateModifiedOnlyOption ? { validateModifiedOnly: options.validateModifiedOnly } : null;
          this.validate(validateOptions, function(error) {
            return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
              _this.$op = "save";
              next(error2);
            });
          });
        } else {
          next();
        }
      }, null, unshift);
    };
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/plugins/sharding.js
var require_sharding = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/plugins/sharding.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var objectIdSymbol = require_symbols().objectIdSymbol;
    var utils = require_utils2();
    module2.exports = function shardingPlugin(schema) {
      schema.post("init", function() {
        storeShard.call(this);
        return this;
      });
      schema.pre("save", function(next) {
        applyWhere.call(this);
        next();
      });
      schema.pre("remove", function(next) {
        applyWhere.call(this);
        next();
      });
      schema.post("save", function() {
        storeShard.call(this);
      });
    };
    function applyWhere() {
      let paths;
      let len;
      if (this.$__.shardval) {
        paths = Object.keys(this.$__.shardval);
        len = paths.length;
        this.$where = this.$where || {};
        for (let i = 0; i < len; ++i) {
          this.$where[paths[i]] = this.$__.shardval[paths[i]];
        }
      }
    }
    module2.exports.storeShard = storeShard;
    function storeShard() {
      const key = this.$__schema.options.shardKey || this.$__schema.options.shardkey;
      if (!utils.isPOJO(key)) {
        return;
      }
      const orig = this.$__.shardval = {};
      const paths = Object.keys(key);
      const len = paths.length;
      let val;
      for (let i = 0; i < len; ++i) {
        val = this.$__getValue(paths[i]);
        if (val == null) {
          orig[paths[i]] = val;
        } else if (utils.isMongooseObject(val)) {
          orig[paths[i]] = val.toObject({ depopulate: true, _isNested: true });
        } else if (val instanceof Date || val[objectIdSymbol]) {
          orig[paths[i]] = val;
        } else if (typeof val.valueOf === "function") {
          orig[paths[i]] = val.valueOf();
        } else {
          orig[paths[i]] = val;
        }
      }
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/printJestWarning.js
var require_printJestWarning = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/helpers/printJestWarning.js"() {
    "use strict";
    init_cjs_shims();
    if (typeof jest !== "undefined" && typeof window !== "undefined") {
      console.warn("Mongoose: looks like you're trying to test a Mongoose app with Jest's default jsdom test environment. Please make sure you read Mongoose's docs on configuring Jest to test Node.js apps: http://mongoosejs.com/docs/jest.html");
    }
    if (typeof jest !== "undefined" && process.nextTick.toString().indexOf("nextTick") === -1) {
      console.warn("Mongoose: looks like you're trying to test a Mongoose app with Jest's mock timers enabled. Please make sure you read Mongoose's docs on configuring Jest to test Node.js apps: http://mongoosejs.com/docs/jest.html");
    }
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/lib/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    if (global.MONGOOSE_DRIVER_PATH) {
      const deprecationWarning = "The `MONGOOSE_DRIVER_PATH` global property is deprecated. Use `mongoose.driver.set()` instead.";
      const setDriver = require("util").deprecate(function() {
        require_driver().set(require(global.MONGOOSE_DRIVER_PATH));
      }, deprecationWarning);
      setDriver();
    } else {
      require_driver().set(require_node_mongodb_native());
    }
    var Document6 = require_document();
    var EventEmitter = require("events").EventEmitter;
    var Schema6 = require_schema2();
    var SchemaType = require_schematype();
    var SchemaTypes = require_schema();
    var VirtualType = require_virtualtype();
    var STATES = require_connectionstate();
    var VALID_OPTIONS = require_validoptions();
    var Types2 = require_types();
    var Query = require_query();
    var Model6 = require_model();
    var applyPlugins = require_applyPlugins();
    var driver = require_driver();
    var get = require_get();
    var promiseOrCallback = require_promiseOrCallback();
    var legacyPluralize = require_mongoose_legacy_pluralize();
    var utils = require_utils2();
    var pkg = require_package();
    var cast = require_cast2();
    var removeSubdocs = require_removeSubdocs();
    var saveSubdocs = require_saveSubdocs();
    var trackTransaction = require_trackTransaction();
    var validateBeforeSave = require_validateBeforeSave();
    var Aggregate = require_aggregate();
    var PromiseProvider = require_promise_provider();
    var shardingPlugin = require_sharding();
    var defaultMongooseSymbol = Symbol.for("mongoose:default");
    require_printJestWarning();
    function Mongoose(options) {
      this.connections = [];
      this.models = {};
      this.modelSchemas = {};
      this.events = new EventEmitter();
      this.options = Object.assign({
        pluralization: true,
        autoIndex: true,
        useCreateIndex: false
      }, options);
      const conn = this.createConnection();
      conn.models = this.models;
      if (this.options.pluralization) {
        this._pluralize = legacyPluralize;
      }
      if (!options || !options[defaultMongooseSymbol]) {
        const _this = this;
        this.Schema = function() {
          this.base = _this;
          return Schema6.apply(this, arguments);
        };
        this.Schema.prototype = Object.create(Schema6.prototype);
        Object.assign(this.Schema, Schema6);
        this.Schema.base = this;
        this.Schema.Types = Object.assign({}, Schema6.Types);
      } else {
        for (const key of ["Schema", "model"]) {
          this[key] = Mongoose.prototype[key];
        }
      }
      this.Schema.prototype.base = this;
      Object.defineProperty(this, "plugins", {
        configurable: false,
        enumerable: true,
        writable: false,
        value: [
          [saveSubdocs, { deduplicate: true }],
          [validateBeforeSave, { deduplicate: true }],
          [shardingPlugin, { deduplicate: true }],
          [removeSubdocs, { deduplicate: true }],
          [trackTransaction, { deduplicate: true }]
        ]
      });
    }
    Mongoose.prototype.cast = cast;
    Mongoose.prototype.STATES = STATES;
    Mongoose.prototype.driver = driver;
    Mongoose.prototype.set = function(key, value) {
      const _mongoose = this instanceof Mongoose ? this : mongoose7;
      if (VALID_OPTIONS.indexOf(key) === -1)
        throw new Error(`\`${key}\` is an invalid option.`);
      if (arguments.length === 1) {
        return _mongoose.options[key];
      }
      _mongoose.options[key] = value;
      if (key === "objectIdGetter") {
        if (value) {
          Object.defineProperty(mongoose7.Types.ObjectId.prototype, "_id", {
            enumerable: false,
            configurable: true,
            get: function() {
              return this;
            }
          });
        } else {
          delete mongoose7.Types.ObjectId.prototype._id;
        }
      }
      return _mongoose;
    };
    Mongoose.prototype.get = Mongoose.prototype.set;
    Mongoose.prototype.createConnection = function(uri, options, callback) {
      const _mongoose = this instanceof Mongoose ? this : mongoose7;
      const conn = new Connection4(_mongoose);
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      _mongoose.connections.push(conn);
      _mongoose.events.emit("createConnection", conn);
      if (arguments.length > 0) {
        return conn.openUri(uri, options, callback);
      }
      return conn;
    };
    Mongoose.prototype.connect = function(uri, options, callback) {
      const _mongoose = this instanceof Mongoose ? this : mongoose7;
      const conn = _mongoose.connection;
      return _mongoose._promiseOrCallback(callback, (cb) => {
        conn.openUri(uri, options, (err) => {
          if (err != null) {
            return cb(err);
          }
          return cb(null, _mongoose);
        });
      });
    };
    Mongoose.prototype.disconnect = function(callback) {
      const _mongoose = this instanceof Mongoose ? this : mongoose7;
      return _mongoose._promiseOrCallback(callback, (cb) => {
        let remaining = _mongoose.connections.length;
        if (remaining <= 0) {
          return cb(null);
        }
        _mongoose.connections.forEach((conn) => {
          conn.close(function(error) {
            if (error) {
              return cb(error);
            }
            if (!--remaining) {
              cb(null);
            }
          });
        });
      });
    };
    Mongoose.prototype.startSession = function() {
      const _mongoose = this instanceof Mongoose ? this : mongoose7;
      return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);
    };
    Mongoose.prototype.pluralize = function(fn) {
      const _mongoose = this instanceof Mongoose ? this : mongoose7;
      if (arguments.length > 0) {
        _mongoose._pluralize = fn;
      }
      return _mongoose._pluralize;
    };
    Mongoose.prototype.model = function(name, schema, collection, skipInit) {
      const _mongoose = this instanceof Mongoose ? this : mongoose7;
      let model;
      if (typeof name === "function") {
        model = name;
        name = model.name;
        if (!(model.prototype instanceof Model6)) {
          throw new _mongoose.Error("The provided class " + name + " must extend Model");
        }
      }
      if (typeof schema === "string") {
        collection = schema;
        schema = false;
      }
      if (utils.isObject(schema) && !(schema instanceof Schema6)) {
        schema = new Schema6(schema);
      }
      if (schema && !(schema instanceof Schema6)) {
        throw new Error("The 2nd parameter to `mongoose.model()` should be a schema or a POJO");
      }
      if (typeof collection === "boolean") {
        skipInit = collection;
        collection = null;
      }
      let options;
      if (skipInit && utils.isObject(skipInit)) {
        options = skipInit;
        skipInit = true;
      } else {
        options = {};
      }
      if (!_mongoose.modelSchemas[name]) {
        if (schema) {
          _mongoose.modelSchemas[name] = schema;
        } else {
          throw new mongoose7.Error.MissingSchemaError(name);
        }
      }
      const originalSchema = schema;
      if (schema) {
        if (_mongoose.get("cloneSchemas")) {
          schema = schema.clone();
        }
        _mongoose._applyPlugins(schema);
      }
      let sub;
      const overwriteModels = _mongoose.options.hasOwnProperty("overwriteModels") ? _mongoose.options.overwriteModels : options.overwriteModels;
      if (_mongoose.models[name] && options.cache !== false && overwriteModels !== true) {
        if (originalSchema && originalSchema.instanceOfSchema && originalSchema !== _mongoose.models[name].schema) {
          throw new _mongoose.Error.OverwriteModelError(name);
        }
        if (collection && collection !== _mongoose.models[name].collection.name) {
          model = _mongoose.models[name];
          schema = model.prototype.schema;
          sub = model.__subclass(_mongoose.connection, schema, collection);
          return sub;
        }
        return _mongoose.models[name];
      }
      if (!schema) {
        schema = this.modelSchemas[name];
        if (!schema) {
          throw new mongoose7.Error.MissingSchemaError(name);
        }
      }
      if (!("pluralization" in schema.options)) {
        schema.options.pluralization = _mongoose.options.pluralization;
      }
      if (!collection) {
        collection = schema.get("collection") || utils.toCollectionName(name, _mongoose.pluralize());
      }
      const connection = options.connection || _mongoose.connection;
      model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);
      if (!skipInit) {
        model.init(function $modelInitNoop() {
        });
      }
      connection.emit("model", model);
      if (options.cache === false) {
        return model;
      }
      _mongoose.models[name] = model;
      return _mongoose.models[name];
    };
    Mongoose.prototype.deleteModel = function(name) {
      const _mongoose = this instanceof Mongoose ? this : mongoose7;
      _mongoose.connection.deleteModel(name);
      return _mongoose;
    };
    Mongoose.prototype.modelNames = function() {
      const _mongoose = this instanceof Mongoose ? this : mongoose7;
      const names = Object.keys(_mongoose.models);
      return names;
    };
    Mongoose.prototype._applyPlugins = function(schema, options) {
      const _mongoose = this instanceof Mongoose ? this : mongoose7;
      options = options || {};
      options.applyPluginsToDiscriminators = get(
        _mongoose,
        "options.applyPluginsToDiscriminators",
        false
      );
      options.applyPluginsToChildSchemas = get(
        _mongoose,
        "options.applyPluginsToChildSchemas",
        true
      );
      applyPlugins(schema, _mongoose.plugins, options, "$globalPluginsApplied");
    };
    Mongoose.prototype.plugin = function(fn, opts) {
      const _mongoose = this instanceof Mongoose ? this : mongoose7;
      _mongoose.plugins.push([fn, opts]);
      return _mongoose;
    };
    Mongoose.prototype.__defineGetter__("connection", function() {
      return this.connections[0];
    });
    Mongoose.prototype.__defineSetter__("connection", function(v) {
      if (v instanceof Connection4) {
        this.connections[0] = v;
        this.models = v.models;
      }
    });
    Mongoose.prototype.connections;
    var Connection4 = driver.get().getConnection();
    var Collection = driver.get().Collection;
    Mongoose.prototype.Aggregate = Aggregate;
    Mongoose.prototype.Collection = Collection;
    Mongoose.prototype.Connection = Connection4;
    Mongoose.prototype.version = pkg.version;
    Mongoose.prototype.Mongoose = Mongoose;
    Mongoose.prototype.Schema = Schema6;
    Mongoose.prototype.SchemaType = SchemaType;
    Mongoose.prototype.SchemaTypes = Schema6.Types;
    Mongoose.prototype.VirtualType = VirtualType;
    Mongoose.prototype.Types = Types2;
    Mongoose.prototype.Query = Query;
    Object.defineProperty(Mongoose.prototype, "Promise", {
      get: function() {
        return PromiseProvider.get();
      },
      set: function(lib) {
        PromiseProvider.set(lib);
      }
    });
    Mongoose.prototype.PromiseProvider = PromiseProvider;
    Mongoose.prototype.Model = Model6;
    Mongoose.prototype.Document = Document6;
    Mongoose.prototype.DocumentProvider = require_document_provider();
    Mongoose.prototype.ObjectId = SchemaTypes.ObjectId;
    Mongoose.prototype.isValidObjectId = function(v) {
      if (v == null) {
        return true;
      }
      const base = this || mongoose7;
      const ObjectId2 = base.driver.get().ObjectId;
      if (v instanceof ObjectId2) {
        return true;
      }
      if (v._id != null) {
        if (v._id instanceof ObjectId2) {
          return true;
        }
        if (v._id.toString instanceof Function) {
          v = v._id.toString();
          if (typeof v === "string" && v.length === 12) {
            return true;
          }
          if (typeof v === "string" && v.length === 24 && /^[a-f0-9]*$/.test(v)) {
            return true;
          }
          return false;
        }
      }
      if (v.toString instanceof Function) {
        v = v.toString();
      }
      if (typeof v === "string" && v.length === 12) {
        return true;
      }
      if (typeof v === "string" && v.length === 24 && /^[a-f0-9]*$/.test(v)) {
        return true;
      }
      return false;
    };
    Mongoose.prototype.Decimal128 = SchemaTypes.Decimal128;
    Mongoose.prototype.Mixed = SchemaTypes.Mixed;
    Mongoose.prototype.Date = SchemaTypes.Date;
    Mongoose.prototype.Number = SchemaTypes.Number;
    Mongoose.prototype.Error = require_error();
    Mongoose.prototype.now = function now() {
      return /* @__PURE__ */ new Date();
    };
    Mongoose.prototype.CastError = require_cast();
    Mongoose.prototype.SchemaTypeOptions = require_SchemaTypeOptions();
    Mongoose.prototype.mongo = require("mongodb");
    Mongoose.prototype.mquery = require_mquery();
    Mongoose.prototype._promiseOrCallback = function(callback, fn, ee) {
      return promiseOrCallback(callback, fn, ee, this.Promise);
    };
    var mongoose7 = module2.exports = exports2 = new Mongoose({
      [defaultMongooseSymbol]: true
    });
  }
});

// node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/index.js
var require_mongoose = __commonJS({
  "node_modules/.pnpm/registry.npmmirror.com+mongoose@5.13.16/node_modules/mongoose/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = require_lib2();
  }
});

// src/index.ts
init_cjs_shims();

// src/utils/log.ts
init_cjs_shims();
var import_winston = __toESM(require("winston"), 1);
var { timestamp, colorize, printf, combine } = import_winston.default.format;
var formatConsole = combine(
  //label({ label: options.serverName }),
  timestamp({ format: "HH:mm:ss" }),
  printf(({ level, message, stack, parent, title, timestamp: timestamp2 }) => {
    while (parent) {
      if (parent.defaultMeta.title)
        title = parent.defaultMeta.title + "|" + title;
      parent = parent.defaultMeta.parent;
    }
    if (typeof stack === "string") {
      if (stack.includes(message))
        message = stack;
      else
        message += "\n" + stack;
    }
    return `${timestamp2} ${title ? title + " " : ""}${level}: ${message}`;
  })
);
var format = combine(
  timestamp(),
  printf(({ name, level, message, stack, parent, title, timestamp: timestamp2 }) => {
    while (parent) {
      if (parent.defaultMeta.title)
        title = parent.defaultMeta.title + "|" + title;
      parent = parent.defaultMeta.parent;
    }
    if (typeof stack === "string") {
      if (stack.includes(message))
        message = stack;
      else
        message += "\n" + stack;
    }
    return `${name} ${timestamp2} ${title ? title + " " : ""}${level}: ${message}`;
  })
);
function createLogger(name, level = "debug") {
  const l2 = import_winston.default.createLogger({
    defaultMeta: { name },
    format,
    level,
    transports: [
      new import_winston.default.transports.Console({
        handleExceptions: true,
        //level: 'debug',
        format: combine(colorize(), formatConsole)
      }),
      new import_winston.default.transports.File({
        level: "debug",
        filename: name + ".log"
      }),
      new import_winston.default.transports.File({
        filename: name + "_errors.log",
        level: "error"
      })
      //new winston.transports.Http({ ssl: false, level: 'debug' })// web
    ],
    exceptionHandlers: [
      new import_winston.default.transports.File({ filename: name + "exceptions.log" })
    ]
  });
  logger || (logger = l2);
  return l2;
}
function createChildLogger(title, parent = logger) {
  parent || (parent = logger);
  const newLogger = Object.create(parent);
  newLogger.defaultMeta = Object.create(parent.defaultMeta);
  newLogger.defaultMeta.parent = parent;
  newLogger.defaultMeta.title = title;
  return newLogger;
}
var logger;

// src/index.ts
var import_express6 = __toESM(require("express"), 1);
var import_ws3 = __toESM(require("ws"), 1);
var import_vhost = __toESM(require("vhost"), 1);
var import_path2 = __toESM(require("path"), 1);

// src/wsss/relayServer.ts
init_cjs_shims();
var import_net = __toESM(require("net"), 1);
var import_ws2 = __toESM(require("ws"), 1);

// src/wsss/connection.ts
init_cjs_shims();
var import_ws = __toESM(require("ws"), 1);

// src/wsss/utils.ts
init_cjs_shims();
var import_winston2 = __toESM(require("winston"), 1);
var ADDRESS_TYPE_IPV4 = 1;
var ADDRESS_TYPE_DOMAIN_NAME = 3;
function parseAddressHeader(data, offset) {
  if (data.length - offset < 7)
    throw "addressHeader error data.length < 7";
  const addressType = data.readUInt8(offset);
  if (addressType == ADDRESS_TYPE_DOMAIN_NAME) {
    const dstAddrLen = data.readUInt8(offset + 1);
    const dstAddr = data.slice(offset + 2, offset + 2 + dstAddrLen).toString();
    const dstPort = data.readUInt16BE(offset + 2 + dstAddrLen);
    const headerLen = 4 + dstAddrLen;
    return { addressType, headerLen, dstAddr, dstPort };
  } else if (addressType == ADDRESS_TYPE_IPV4) {
    const dstAddr = data.slice(offset + 1, offset + 5).join(".").toString();
    const dstPort = data.readUInt16BE(offset + 5);
    const headerLen = 7;
    return { addressType, headerLen, dstAddr, dstPort };
  } else {
    throw "addressHeader error";
  }
}
function renderSize(value) {
  if (value > 1024)
    return (value / 1024).toFixed(1) + "KB";
  return value + "B";
}
var MAX_CONNECTIONS = 5e4;
var sleep = (timeountMS) => new Promise((resolve) => {
  setTimeout(resolve, timeountMS);
});
var myFormat = import_winston2.format.combine(
  //format.label({ label: options.serverName }),
  import_winston2.format.timestamp(),
  import_winston2.format.colorize(),
  import_winston2.format.printf(({ level, message, stack, title, timestamp: timestamp2 }) => {
    return `${timestamp2} ${title} ${level}: ${message}${stack ? "\n" + stack : ""}`;
  })
);
function createLogger2(title, level = "debug") {
  return import_winston2.default.createLogger({
    defaultMeta: { title },
    format: myFormat,
    level,
    transports: [
      new import_winston2.default.transports.Console({
        handleExceptions: true,
        //level: 'debug',
        format: import_winston2.format.combine(import_winston2.format.colorize(), myFormat)
      }),
      new import_winston2.default.transports.File({
        level: "debug",
        filename: title + ".log"
      }),
      new import_winston2.default.transports.File({
        filename: title + "_errors.log",
        level: "error"
      })
      //new winston.transports.Http({ ssl: false, level: 'debug' })// web
    ],
    exceptionHandlers: [
      new import_winston2.default.transports.File({ filename: title + "exceptions.log" })
    ]
  });
}

// src/wsss/connection.ts
var _Connection = class {
  constructor(logger3, socket) {
    this.sendCount = 0;
    this.acceptCount = 0;
    this.dataCache = [];
    this.isConnected = false;
    this.isDestroyed = false;
    this.socket = socket;
    for (let i = 0; i < MAX_CONNECTIONS; ++i) {
      if (!_Connection.connections[i]) {
        this.socketId = i;
        _Connection.connections[i] = this;
        break;
      }
    }
    this.logger = Object.create(logger3);
    this.logger.defaultMeta = { title: logger3.defaultMeta.title + "-" + this.socketId };
    this.startConnection();
  }
  async waitConnected() {
    while (true) {
      if (this.isConnected)
        return;
      if (this.isDestroyed)
        throw "isDestroyed";
      await sleep(1);
    }
  }
  async getData() {
    while (true) {
      if (this.dataCache.length > 0)
        return this.dataCache.shift();
      if (this.isDestroyed)
        throw "isDestroyed";
      await sleep(1);
    }
  }
  async run(callback) {
    _Connection.globalSocketCount++;
    try {
      await this.waitConnected();
      await callback(this);
    } catch (e) {
      this.logger.error(e);
    }
    this.destroy();
    _Connection.connections[this.socketId] = null;
    this.logger.info(`closed [globalSocketCount=${_Connection.globalSocketCount}]`);
    _Connection.globalSocketCount--;
  }
  startConnection() {
  }
  async onConnect() {
    this.isConnected = true;
  }
  onData(data) {
    this.acceptCount++;
    this.logger.debug(`${this.sendCount}/${this.acceptCount} Accept data[${renderSize(data.length)}]`);
    this.dataCache.push(data);
  }
  send(data) {
    this.sendCount++;
    return;
  }
  pause() {
  }
  resume() {
  }
  destroy() {
    this.isDestroyed = true;
  }
};
var Connection = _Connection;
Connection.connections = {};
Connection.globalSocketCount = 0;
var TcpConnection = class extends Connection {
  startConnection() {
    this.socket.setKeepAlive(false);
    this.socket.on("data", (data) => this.onData(data));
    this.socket.on("end", () => {
      this.logger.info(`end event`);
      this.destroy();
    });
    this.socket.on("close", (hadError) => {
      if (hadError)
        this.logger.error(`close event had error`);
      else
        this.logger.info(`close event`);
      this.destroy();
    });
    this.socket.on("error", (error) => {
      this.logger.error(`error event`, error);
      this.destroy();
    });
    if (!this.socket.connecting)
      this.onConnect();
    else {
      const timeBegin = Date.now();
      this.socket.on("connect", () => {
        this.logger.info(`connected [${Date.now() - timeBegin}ms]`);
        this.onConnect();
      });
    }
  }
  send(data) {
    return new Promise((resolve, reject) => {
      super.send(data);
      if (this.socket)
        this.socket.write(data, () => {
          resolve();
        });
      else
        resolve();
    });
  }
  pause() {
    if (this.socket)
      this.socket.pause();
  }
  resume() {
    if (this.socket)
      this.socket.resume();
  }
  destroy() {
    super.destroy();
    if (this.socket) {
      this.socket.end();
      this.socket.destroy();
      this.socket = null;
    }
  }
};
var WebConnection = class extends Connection {
  /*client.on('pong', ()=> {
  	logger.info(`[${clientId}]: client pong`)
  })
  heartbeat = setInterval(ping()=> {
  	if (client.readyState != WebSocket.OPEN) return
  	client.ping()
  	logger.info(`[${clientId}]: ping`)
  }, 30000)*/
  startConnection() {
    this.socket.on("message", (data) => this.onData(data));
    this.socket.on("close", (code, reason) => {
      this.logger.info(`close event [code='${code}' reason='${reason}']`);
      this.destroy();
    });
    this.socket.on("error", (error) => {
      this.logger.error(`error event`, error);
      this.destroy();
    });
    if (this.socket.readyState == import_ws.default.OPEN)
      this.onConnect();
    else {
      const timeBegin = Date.now();
      this.socket.on("open", () => {
        this.logger.info(`connected [${Date.now() - timeBegin}ms]`);
        this.onConnect();
      });
    }
  }
  send(data) {
    return new Promise((resolve, reject) => {
      super.send(data);
      if (this.socket && this.socket.readyState == import_ws.default.OPEN)
        this.socket.send(data, { binary: true }, () => {
          resolve();
        });
      else
        resolve();
    });
  }
  pause() {
  }
  resume() {
  }
  destroy() {
    super.destroy();
    if (this.socket) {
      this.socket.terminate();
      this.socket.close();
      this.socket = null;
    }
  }
};
var AgentConnectionManager = class {
  constructor(source) {
    this.globleIndex = 0;
    this.connections = {};
    this.source = source;
    source.logger.defaultMeta = { title: source.logger.defaultMeta.title + "-Agent" };
    source.logger.level = "debug";
    source.logger.info("\u521B\u5EFA Agents");
  }
  find(id) {
    return this.connections[id];
  }
  create(id = null) {
    let headerCode = 1;
    if (id == null) {
      id = this.globleIndex;
      this.globleIndex = (this.globleIndex + 1) % MAX_CONNECTIONS;
      headerCode = 0;
    }
    const agent = new AgentConnection(this, id, headerCode);
    this.connections[id] = agent;
    return agent;
  }
  async run() {
    while (!this.source.isDestroyed) {
      while (this.source.dataCache.length > 0) {
        const data = this.source.dataCache.shift();
        const id = data.readUInt32BE(0);
        const code = data.readUInt8(4);
        const agent = this.find(id);
        if (code == 0) {
          if (agent)
            agent.dataCache.push(data.slice(6));
          else
            this.source.logger.error(`bad agent! ${id}`);
        } else if (code == 1) {
          if (agent)
            agent.dataCache.push(data.slice(6));
          else
            this.source.logger.error(`unknown agent! ${id}`);
        } else if (code == 2) {
          if (agent)
            agent.destroy();
        } else {
          this.source.logger.error(`bad code! ${id}:${code}`);
        }
      }
      await sleep(1);
    }
  }
  async run2(callback) {
    while (!this.source.isDestroyed) {
      while (this.source.dataCache.length > 0) {
        const data = this.source.dataCache.shift();
        const id = data.readUInt32BE(0);
        const code = data.readUInt8(4);
        let agent = this.find(id);
        if (code == 0) {
          if (agent)
            this.source.logger.error(`bad agent! ${id}`);
          agent = this.create(id);
          agent.dataCache.push(data.slice(6));
          agent.run(callback);
        } else if (code == 1) {
          if (agent)
            agent.dataCache.push(data.slice(6));
          else
            this.source.logger.error(`unknown agent! ${id}`);
        } else if (code == 2) {
          if (agent)
            agent.destroy();
        } else {
          this.source.logger.error(`bad code! ${id}:${code}`);
        }
      }
      await sleep(1);
    }
  }
};
var AgentConnection = class extends Connection {
  constructor(manager, agentId, headerCode) {
    super(manager.source.logger, null);
    this.manager = manager;
    this.agentId = agentId;
    this.header = Buffer.alloc(6);
    this.header.writeUInt32BE(this.agentId, 0);
    this.header.writeUInt8(headerCode, 4);
  }
  get source() {
    return this.manager?.source;
  }
  async waitConnected() {
    await this.source.waitConnected();
  }
  send(data) {
    data = Buffer.concat([this.header, data]);
    this.header.writeUInt8(1, 4);
    if (this.source)
      return this.source.send(data);
  }
  pause() {
    if (this.source)
      this.source.pause();
  }
  resume() {
    if (this.source)
      this.source.resume();
  }
  destroy() {
    super.destroy();
    if (this.manager) {
      this.header.writeUInt8(2, 4);
      this.source.send(this.header);
      this.manager.connections[this.agentId] = null;
      this.manager = null;
    }
  }
};

// src/wsss/relayServer.ts
var RelayServer = class {
  constructor(options) {
    this.logger = createLogger2(options.serverName, options.logLevel);
    if (options.server) {
      if (options.server instanceof import_ws2.default.Server) {
        this.startWebSocketServer(options.server, options.callback);
        return;
      } else if (options.server instanceof import_net.default.Server) {
        this.startTcpServer(options.server, options.callback);
        return;
      }
    }
    if (options.port > 0) {
      const server = import_net.default.createServer({ allowHalfOpen: true });
      server.listen(options.port);
      this.startTcpServer(server, options.callback);
      return;
    }
  }
  startTcpServer(server, callback) {
    server.maxConnections = MAX_CONNECTIONS;
    server.on("connection", (socket) => {
      new TcpConnection(this.logger, socket).run(callback);
    });
    server.on("close", () => {
      this.logger.info("server is closed");
    });
    server.on("error", (error) => {
      this.logger.error("server error", error);
    });
    server.on("listening", () => {
      this.logger.info("Server is listening");
    });
  }
  startWebSocketServer(server, callback) {
    server.on("connection", (socket) => {
      new WebConnection(this.logger, socket).run(callback);
    });
    server.on("error", (error) => {
      this.logger.error("server error", error);
    });
    server.on("listening", () => {
      this.logger.info("server is listening");
    });
  }
};

// src/wsss/remoteRelay.ts
init_cjs_shims();
var import_net2 = __toESM(require("net"), 1);

// src/wsss/encrypt.ts
init_cjs_shims();
var import_crypto = __toESM(require("crypto"), 1);
var import_util = __toESM(require("util"), 1);

// src/wsss/merge_sort.ts
init_cjs_shims();
function merge(left, right, comparison) {
  const result = new Array();
  while (left.length > 0 && right.length > 0)
    result.push(comparison(left[0], right[0]) <= 0 ? left.shift() : right.shift());
  while (left.length > 0)
    result.push(left.shift());
  while (right.length > 0)
    result.push(right.shift());
  return result;
}
function merge_sort(array, comparison) {
  if (array.length < 2)
    return array;
  const middle = Math.ceil(array.length / 2);
  return merge(merge_sort(array.slice(0, middle), comparison), merge_sort(array.slice(middle), comparison), comparison);
}

// src/wsss/encrypt.ts
var int32Max = Math.pow(2, 32);
var cachedTables = {};
function getTable(key) {
  var result;
  if (cachedTables[key]) {
    return cachedTables[key];
  }
  import_util.default.log("calculating ciphers");
  let table = new Array(256);
  const decrypt_table = new Array(256);
  const md5sum = import_crypto.default.createHash("md5");
  md5sum.update(key);
  const hash = new Buffer(md5sum.digest());
  const al = hash.readUInt32LE(0);
  const ah = hash.readUInt32LE(4);
  let i = 0;
  while (i < 256) {
    table[i] = i;
    i++;
  }
  i = 1;
  while (i < 1024) {
    table = merge_sort(table, function(x, y) {
      return (ah % (x + i) * int32Max + al) % (x + i) - (ah % (y + i) * int32Max + al) % (y + i);
    });
    i++;
  }
  i = 0;
  while (i < 256) {
    decrypt_table[table[i]] = i;
    ++i;
  }
  result = [table, decrypt_table];
  cachedTables[key] = result;
  return result;
}
function substitute(table, buf) {
  for (let i = 0; i < buf.length; ++i)
    buf[i] = table[buf[i]];
  return buf;
}
var bytes_to_key_results = {};
function EVP_BytesToKey(password, key_len, iv_len) {
  const strKey = "" + password + ":" + key_len + ":" + iv_len;
  if (bytes_to_key_results[strKey]) {
    return bytes_to_key_results[strKey];
  }
  const m = [];
  let i = 0;
  let count = 0;
  while (count < key_len + iv_len) {
    const md5 = import_crypto.default.createHash("md5");
    let data = password;
    if (i > 0) {
      data = Buffer.concat([m[i - 1], password]);
    }
    md5.update(data);
    const d = md5.digest();
    m.push(d);
    count += d.length;
    i += 1;
  }
  const ms = Buffer.concat(m);
  const key = ms.slice(0, key_len);
  const iv = ms.slice(key_len, key_len + iv_len);
  bytes_to_key_results[strKey] = [key, iv];
  return [key, iv];
}
var method_supported = {
  "aes-128-cfb": [16, 16],
  "aes-192-cfb": [24, 16],
  "aes-256-cfb": [32, 16],
  "bf-cfb": [16, 8],
  "camellia-128-cfb": [16, 16],
  "camellia-192-cfb": [24, 16],
  "camellia-256-cfb": [32, 16],
  "cast5-cfb": [16, 8],
  "des-cfb": [8, 8],
  "idea-cfb": [16, 8],
  "rc2-cfb": [16, 8],
  "rc4": [16, 0],
  "rc4-md5": [16, 16],
  "seed-cfb": [16, 16]
};
function create_rc4_md5_cipher(key, iv, op) {
  const md5 = import_crypto.default.createHash("md5");
  md5.update(key);
  md5.update(iv);
  const rc4_key = md5.digest();
  if (op === 1) {
    return import_crypto.default.createCipheriv("rc4", rc4_key, "");
  } else {
    return import_crypto.default.createDecipheriv("rc4", rc4_key, "");
  }
}
var Encryptor = class {
  constructor(key, method) {
    this.key = key;
    this.method = method;
    this.iv_sent = false;
    if (this.method === "table")
      this.method = null;
    if (this.method != null) {
      this.cipher = this.get_cipher(this.key, this.method, 1, import_crypto.default.randomBytes(32));
    } else {
      [this.encryptTable, this.decryptTable] = getTable(this.key);
    }
  }
  get_cipher_len(method) {
    return method_supported[method.toLowerCase()];
  }
  get_cipher(password, method, op, iv) {
    method = method.toLowerCase();
    const pwdBuf = new Buffer(password, "binary");
    const m = this.get_cipher_len(method);
    if (m != null) {
      const [key, iv_] = EVP_BytesToKey(pwdBuf, m[0], m[1]);
      if (iv == null) {
        iv = iv_;
      }
      if (op === 1) {
        this.cipher_iv = iv.slice(0, m[1]);
      }
      iv = iv.slice(0, m[1]);
      if (method === "rc4-md5") {
        return create_rc4_md5_cipher(key, iv, op);
      } else {
        if (op === 1) {
          return import_crypto.default.createCipheriv(method, key, iv);
        } else {
          return import_crypto.default.createDecipheriv(method, key, iv);
        }
      }
    }
  }
  encrypt(buf) {
    if (this.method == null)
      return substitute(this.encryptTable, buf);
    const result = this.cipher.update(buf);
    if (this.iv_sent)
      return result;
    this.iv_sent = true;
    return Buffer.concat([this.cipher_iv, result]);
  }
  decrypt(buf) {
    if (this.method == null)
      return substitute(this.decryptTable, buf);
    if (this.decipher == null) {
      const decipher_iv_len = this.get_cipher_len(this.method)[1];
      const decipher_iv = buf.slice(0, decipher_iv_len);
      this.decipher = this.get_cipher(this.key, this.method, 0, decipher_iv);
      return this.decipher.update(buf.slice(decipher_iv_len));
    }
    return this.decipher.update(buf);
  }
};

// src/wsss/remoteRelay.ts
async function remoteRelay(client, password, method) {
  const encryptor = new Encryptor(password, method);
  let data = await client.getData();
  data = encryptor.decrypt(data);
  const addressHeader = parseAddressHeader(data, 0);
  client.logger = Object.create(client.logger);
  client.logger.defaultMeta = { title: client.logger.defaultMeta.title + "[" + addressHeader.dstAddr + ":" + addressHeader.dstPort + "]" };
  const socket = import_net2.default.createConnection({ port: addressHeader.dstPort, host: addressHeader.dstAddr, allowHalfOpen: true });
  const server = new TcpConnection(client.logger, socket);
  await server.run(async () => {
    if (data.length > addressHeader.headerLen)
      server.send(data.slice(addressHeader.headerLen));
    while (!client.isDestroyed && !server.isDestroyed) {
      while (client.dataCache.length > 0) {
        const data2 = client.dataCache.shift();
        server.send(encryptor.decrypt(data2));
      }
      await sleep(1);
      server.pause();
      while (server.dataCache.length > 0) {
        const data2 = server.dataCache.shift();
        await client.send(encryptor.encrypt(data2));
      }
      server.resume();
      await sleep(1);
    }
  });
}
async function remoteMultRelay(source, password, method) {
  let data = await source.getData();
  if (data.length > 5 && data.readUInt32BE(0) == 0 && data.readUInt8(4) == 0) {
    source.dataCache.unshift(data);
    const agents = new AgentConnectionManager(source);
    await agents.run2(async (client) => {
      await remoteRelay(client, password, method);
    });
  } else {
    source.dataCache.unshift(data);
    await remoteRelay(source, password, method);
  }
}

// src/utils/express.ts
init_cjs_shims();
var import_express = __toESM(require("express"), 1);
var import_cors = __toESM(require("cors"), 1);
var import_http = __toESM(require("http"), 1);
var import_https = __toESM(require("https"), 1);
var import_url = __toESM(require("url"), 1);
var import_url2 = __toESM(require("url"), 1);

// src/utils/fileLoader.ts
init_cjs_shims();
var import_fs = __toESM(require("fs"), 1);
var import_path = __toESM(require("path"), 1);
var import_tls = __toESM(require("tls"), 1);
function createServerOptions() {
  const options = { secureContext: {} };
  const badHosts = [];
  options.SNICallback = (servername, cb) => {
    let ctx = options.secureContext[servername];
    if (!ctx) {
      const host = servername.substring(servername.indexOf(".") + 1);
      ctx = options.secureContext[host];
    }
    if (!ctx) {
      if (!badHosts.includes(servername)) {
        badHosts.push(servername);
        console.warn(`SNICallback ${servername}`);
      }
      if (!options.defaultSecureContext) {
        console.error(`No SecureContext ${servername}`);
        return;
      }
      ctx = options.defaultSecureContext;
    }
    cb(null, ctx);
  };
  return options;
}
function loadCerts(dir = "./certs", options) {
  if (!options)
    options = createServerOptions();
  if (!import_fs.default.existsSync(dir))
    return options;
  const pa = import_fs.default.readdirSync(dir);
  function readFile(path3) {
    if (!import_fs.default.existsSync(path3))
      return void 0;
    return import_fs.default.readFileSync(path3, "utf8");
  }
  for (const ele of pa) {
    const pathname = import_path.default.join(dir, ele);
    if (!import_fs.default.statSync(pathname).isFile())
      continue;
    const ext = import_path.default.extname(pathname);
    if (ext != ".cer")
      continue;
    const domain = import_path.default.basename(pathname, ext);
    const cert = readFile(pathname);
    const key = readFile(import_path.default.join(dir, domain + ".key"));
    if (!key) {
      console.error(`\u7F3A\u5931 ${domain} \u7684\u79C1\u94A5`);
      continue;
    }
    const ca = readFile(import_path.default.join(dir, domain + ".ca"));
    if (!ca) {
      console.warn(`\u7F3A\u5931 ${domain} \u7684\u6839\u8BC1\u4E66`);
    }
    const sco = import_tls.default.createSecureContext({ cert, key, ca });
    if (!options.defaultSecureContext) {
      options.cert = cert;
      options.key = key;
      options.ca = ca;
      options.defaultSecureContext = sco;
    }
    options.secureContext[domain] = sco;
  }
  return options;
}

// src/utils/express.ts
function assignBody(req, res, next) {
  if (req.body == null)
    req.body = req.query;
  else
    Object.assign(req.body, req.query);
  next();
}
function redirectWWW(req, res, next) {
  const host = req.headers.host;
  if (!host)
    return;
  if (host.split(".").length === 2) {
    const pathname = import_url.default.parse(req.url).pathname;
    res.redirect("https://www." + host + pathname);
  } else {
    return next();
  }
}
function redirectHttps(req, res, next) {
  const host = req.headers.host?.replace(/\:\d+$/, "");
  res.redirect(307, `https://${host}${req.originalUrl}`);
}
function createExpress() {
  const app = (0, import_express.default)();
  app.use((0, import_cors.default)());
  app.use(import_express.default.json(), assignBody);
  app.use(redirectWWW);
  return app;
}
function createServer(requestListener, useSSL = false) {
  const server = useSSL ? import_https.default.createServer(loadCerts("/certs", loadCerts("./certs")), requestListener) : import_http.default.createServer(requestListener);
  return server;
}
function createRedirectHttpsServer(port = 80) {
  const server = import_http.default.createServer((0, import_express.default)().use((0, import_cors.default)(), redirectHttps));
  server.listen(port, function() {
    console.log(`Http to Https Server Running on ${port}`);
  });
  return server;
}
function getClientIp(req) {
  return req.headers["x-forwarded-for"] || req.connection.remoteAddress || req.socket.remoteAddress || //req.connection.socket.remoteAddress ||
  "";
}
function toUnicode(str) {
  let unicode = "";
  for (let i = 0; i < str.length; i++) {
    const temp = str.charCodeAt(i);
    if (temp > 127)
      unicode += "\\u" + temp.toString(16);
    else
      unicode += str.charAt(i);
  }
  return unicode;
}
function getXFF(req) {
  let xff = req.header("x-forwarded-for");
  const curIP = req.connection.remoteAddress || req.socket.remoteAddress || req.connection.remoteAddress || "";
  if (xff && xff.length > 0)
    xff += "," + curIP;
  else
    xff = curIP;
  return xff;
}
function GetProxyRouter(urlHandle = (url2) => url2.replace(/\/(http[s]?)\//, "$1://")) {
  return function(req, res, next) {
    try {
      const urlWithParsedQuery = import_url2.default.parse(urlHandle(req.originalUrl), true);
      const { protocol, port, auth: auth2, host, hostname, path: path3 } = urlWithParsedQuery;
      const options = { protocol, port, auth: auth2, host, hostname, path: path3, method: req.method };
      options.headers = { "x-forwarded-for": getXFF(req) };
      let content = null;
      if (req.method == "POST") {
        content = toUnicode(JSON.stringify(req.body));
        options.headers["Content-Type"] = "application/json";
        options.headers["Content-Length"] = content.length;
      }
      const request = (options.protocol == "https:" ? import_https.default : import_http.default).request(options, function(response) {
        response.pipe(res);
      });
      if (content)
        request.write(content);
      request.end();
    } catch (e) {
      console.error(e);
      res.send(e);
    }
  };
}

// src/gameAnalytics/index.ts
init_cjs_shims();
var import_express4 = __toESM(require("express"), 1);

// src/gameAnalytics/AppData.ts
init_cjs_shims();
var import_mongoose4 = __toESM(require_mongoose(), 1);
var import_cron = __toESM(require("cron"), 1);

// src/utils/time.ts
init_cjs_shims();
function getDayInSeconds(time) {
  return Math.floor(time / (3600 * 24));
}
function getHoursInSeconds(time) {
  return Math.floor(time / 3600);
}
function getNowDay() {
  return Math.floor(Date.now() / (36e5 * 24));
}
function getNowHours() {
  return Math.floor(Date.now() / 36e5);
}
function floatFixed2(value) {
  return parseFloat(value.toFixed(2));
}
function floatFixed(value, fractionDigits) {
  return parseFloat(value.toFixed(fractionDigits));
}
function sleep2(time) {
  return new Promise((resolve) => setTimeout(resolve, time));
}
function cacheCall(callback, ms, ...args) {
  let timeout = null;
  return () => {
    if (timeout)
      return;
    timeout = setTimeout((...args2) => {
      timeout = null;
      callback(...args2);
    }, ms, ...args);
  };
}

// src/gameAnalytics/models/Counter.ts
init_cjs_shims();
var import_mongoose = __toESM(require_mongoose(), 1);
var CounterSchema = new import_mongoose.Schema({
  _id: { type: String, required: true },
  seq: { type: Number, default: 0 }
});
CounterSchema.static("getNextSequenceValue", async function(sequenceName) {
  var counter = await this.findOneAndUpdate(
    { _id: sequenceName },
    { $inc: { seq: 1 } },
    {
      new: true,
      upsert: true
    }
  );
  return counter.seq;
});
var Counter_default = import_mongoose.default.model("Counter", CounterSchema);

// src/gameAnalytics/AppData.ts
var import_lodash = __toESM(require("lodash"), 1);

// src/utils/HTTPException.ts
init_cjs_shims();
var HTTPException = class {
  constructor(status, message, errors) {
    this.status = status;
    this.message = message;
    this.errors = errors;
    this.status = status;
    this.message = message;
    this.errors = errors || {};
  }
};
var BaseError = class extends Error {
  constructor(message) {
    super(message);
    this.name = new.target.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, new.target);
    }
    if (typeof Object.setPrototypeOf === "function") {
      Object.setPrototypeOf(this, new.target.prototype);
    } else {
      this.__proto__ = new.target.prototype;
    }
  }
};
var ApiError = class extends BaseError {
  constructor(message, ...args) {
    super(message);
    this.args = args;
  }
};

// src/gameAnalytics/models/App.ts
init_cjs_shims();
var import_mongoose2 = __toESM(require_mongoose(), 1);
var ConfigKeySchema = new import_mongoose2.Schema({
  name: String,
  sort: Number,
  enable: Boolean
}, { _id: false });
var RankItemSchema = new import_mongoose2.Schema({
  id: String,
  name: String,
  score: Number,
  expand: import_mongoose2.Schema.Types.Mixed,
  time: Number
}, { _id: false });
var RankSchema = new import_mongoose2.Schema({
  top: [RankItemSchema],
  total: Number,
  counter: [Number]
}, { _id: false });
var AppSchema = new import_mongoose2.Schema({
  name: String,
  id: String,
  userCount: Number,
  ranks: { type: Map, of: RankSchema },
  //configKeys: { type: Map, of: { type: Map, of: ConfigKeySchema } }
  configKeys: { type: import_mongoose2.Schema.Types.Mixed },
  config: { type: import_mongoose2.Schema.Types.Mixed }
});
var App = import_mongoose2.default.model("App", AppSchema);

// src/utils/region.ts
init_cjs_shims();
var import_node_ip2region = __toESM(require("node-ip2region"), 1);
var searcher = import_node_ip2region.default.create();
function getRegion(ip) {
  try {
    let m = ip.match(/\d+\.\d+\.\d+\.\d+/);
    if (m) {
      const ret2 = searcher.btreeSearchSync(m[0]);
      if (ret2)
        return ret2.region.split("|")[0];
      else
        throw new Error("IPv4 null");
    }
    m = ip.match(/^([\da-fA-F]{0,4}:){2,7}[\da-fA-F]{0,4}/);
    if (m) {
    }
    throw new Error("Bad IP");
  } catch (error) {
    console.error(`getRegion err: ${ip} ${error}`);
  }
  return "unknown";
}

// src/gameAnalytics/cloudData.ts
init_cjs_shims();
function Rate(values, weights) {
  this.values = values;
  this.weights = weights;
  this.max = 0;
  for (let i = 0, l2 = this.weights.length; i < l2; ++i) {
    this.max += this.weights[i];
  }
  this.rndValue = function() {
    let valueMax = 0;
    const value = Math.random() * this.max;
    for (let i = 0, l2 = this.weights.length; i < l2; ++i) {
      valueMax += this.weights[i];
      if (valueMax >= value)
        return this.values[i];
    }
    return this.values[0];
  };
}
var appsConfig = {
  "Battle Angels: PVP Defence": {
    cloud: {
      parameters: {},
      combines: { "a.0": { data: { cloudHideGuideSkip: false }, weight: 1 } }
    }
  },
  "DustSettle": {
    cloud: {
      parameters: {
        enablePurchase: { id: "ep", enable: true, default: true },
        // 
        enablePropWeapon: { id: "ew", enable: true, default: true },
        // 
        interstitialLevel: { id: "il", enable: true, default: 3, test: [3, 6], weight: 1 },
        interstitialMinTime: { id: "it", enable: true, default: 15, test: [15, 20, 25, 30, 35, 40, 45], weight: 1 },
        ///
        showInterstitial: { id: "si", enable: true, default: true },
        // 
        interstitialX: { id: "ix", enable: true, default: 1 },
        interstitialY: { id: "iy", enable: true, default: 0 },
        recommendPowerRate: { id: "rp", enable: true, default: 3e-3 },
        //
        difficultyRate: { id: "dr", enable: true, default: 0.75, test: [0.7, 0.72, 0.74, 0.76, 0.78, 0.8], weight: 1 },
        //
        boosLifeRate: { id: "bl", enable: true, default: 8, test: [7, 7.3, 7.6, 7.9, 8.2, 8.5], weight: 1 },
        //Boss
        enemyLifeRate: { id: "el", enable: false, default: 3 },
        //DPS*
        enemyLifeMinRate: { id: "eln", enable: false, default: 2 },
        //DPS*
        enemyLifeMaxRate: { id: "elx", enable: false, default: 12 }
        //DPS*
      },
      combines: {
        "c.0": { data: {}, weight: 1 },
        "c.1": { data: { interstitialMinTime: 15, difficultyRate: 0.74, boosLifeRate: 7 }, weight: 4 }
        //'c.2': { data: { interstitialMinTime: 15, interstitialLevel: 5 }, weight: 1 },
      }
    }
  },
  "BulletBang": {
    cloud: {
      parameters: {},
      combines: { "a.0": { data: { RewardAdLevelDur: 2 }, weight: 1 } }
    }
  },
  "MergeTowerShoot": {
    cloud: {
      parameters: {
        /*BossLifeRate: { id: "blr", enable: true, default: "1.0" },// XX
        RecycleUpgradeTimeDuration: { id: "rutd", enable: true, default: "900", },// XX
        MergeUpgradeTimeDuration: { id: "mutd", enable: true, default: "300", },// XX
        UpgradeChanceAccurate: { id: "uca", enable: true, default: "1.0", },// XX
        MergeUpgradeAccurate: { id: "mca", enable: true, default: "1.0", },// XX
        LevelBossLifeRate: { id: "lblr", enable: true, default: [{ "8": "1.5" }, { "18": "2" }], },// XX
        useInterstitialAd: { id: "utad", enable: true, default: 1, test: [1, 0], weight: 1 },// XX
        adTimes: { id: "adt", enable: true, default: 120, },// XX
        dynamicHP: { id: "dhp", enable: true, default: 1, test: [1, 0], weight: 1 }// XX*/
      },
      combines: {
        /*'c.0': { data: { useInterstitialAd: 1 }, weight: 0 },
        'c.1': { data: { useInterstitialAd: 0, dynamicHP: 1, dynamicHPValue: 3, dynamicHPStartLevel: 1, fixcoin: 5 }, weight: 0 },
        'd.0': { data: { useInterstitialAd: 1, adTimes: 10 }, weight: 1 },
        'd.1': { data: { useInterstitialAd: 1, adTimes: 10, dynamicHP: 1, dynamicHPValue: 3, dynamicHPStartLevel: 1, fixcoin: 5 }, weight: 1 },*/
        //'e.0': { data: { isRVCalADTime: 0, useAirGift: 0, AirGiftForceLevel: 99 }, weight: 1 },
        //'e.1': { data: { isRVCalADTime: 1, useAirGift: 0, AirGiftForceLevel: 99 }, weight: 1 },
        "e.a": { data: { adTimes: 300, useAirGift: 1, AirGiftForceLevel: 6 }, weight: 1 },
        "e.b": { data: { adTimes: 300, useAirGift: 0, AirGiftForceLevel: 999 }, weight: 1 }
      }
    }
  }
};

// src/gameAnalytics/models/Report.ts
init_cjs_shims();
var import_mongoose3 = __toESM(require_mongoose(), 1);
var ReportSchema = new import_mongoose3.Schema({
  date: Date,
  source: String,
  condition: String,
  stackTrace: String,
  expand: String,
  version: String,
  count: Number
}, {
  timestamps: true
});
ReportSchema.static("add", async function(source, condition, stackTrace, expand, version) {
  await this.updateOne({ source, version, condition, stackTrace, expand }, { $inc: { count: 1 } }, { upsert: true });
});
var Report_default = (appId) => import_mongoose3.default.model("Report_" + appId, ReportSchema);

// src/gameAnalytics/AppData.ts
var DbCache = class {
  constructor(filter) {
    this.data = {};
    this.filter = Object.assign({}, filter);
  }
  inc(value) {
    var _a;
    (_a = this.data).$inc || (_a.$inc = {});
    var incValue = this.data.$inc;
    for (var key in value) {
      if (typeof value[key] !== "number")
        continue;
      if (typeof incValue[key] === "number")
        incValue[key] += value[key];
      else
        incValue[key] = value[key];
    }
  }
  set(value) {
    var _a;
    (_a = this.data).$set || (_a.$set = {});
    Object.assign(this.data.$set, value);
  }
};
var _AppData = class {
  constructor() {
    this.dbCaches = {};
    this.log = {};
    this.inited = false;
    this.collections = {};
  }
  static async getAppByName(appName) {
    while (_AppData.initializing)
      await sleep2(1);
    _AppData.initializing = true;
    let app = _AppData.apps[appName];
    if (!app) {
      var db = await App.findOne({ name: appName });
      if (!db) {
        db = new App({ name: appName });
        db.id = (await Counter_default.getNextSequenceValue("App")).toString();
        await db.save();
      } else {
        if (!db.id)
          db.id = escape(db.name);
      }
      app = new _AppData();
      await app.setup(db);
      _AppData.apps[app.db.name] = app;
      _AppData.apps[app.db.id] = app;
    }
    _AppData.initializing = false;
    return app;
  }
  static async getAppById(appId) {
    while (_AppData.initializing)
      await sleep2(1);
    _AppData.initializing = true;
    let app = _AppData.apps[appId];
    if (!app) {
      const db = await App.findOne({ id: appId });
      if (!db)
        throw new ApiError("appId\u4E0D\u5B58\u5728");
      app = new _AppData();
      await app.setup(db);
      _AppData.apps[app.db.name] = app;
      _AppData.apps[app.db.id] = app;
    }
    _AppData.initializing = false;
    return app;
  }
  initCloudData() {
    if (!this.db.config?.cloud)
      return;
    const { parameters, combines } = this.db.config.cloud;
    const cloudData = {};
    const cloudRandomData = {};
    const cloudRandomList = [];
    const cloudRandomWeights = [];
    for (const key in parameters) {
      const element = parameters[key];
      if (element.enable) {
        cloudData[key] = element.default;
      }
    }
    for (const key in parameters) {
      const element = parameters[key];
      if (element.enable && element.test) {
        const weight = (element.weight || 1) / element.test.length;
        for (let j = 0; j < element.test.length; ++j) {
          cloudRandomList.push(element.id + "." + j);
          cloudRandomWeights.push(weight);
          const newCloudData = {};
          newCloudData[key] = element.test[j];
          cloudRandomData[element.id + "." + j] = newCloudData;
        }
      }
    }
    for (const key in combines) {
      const element = combines[key];
      cloudRandomList.push(key);
      cloudRandomWeights.push(element.weight || 1);
      cloudRandomData[key] = element.data;
    }
    this.cloudData = { cloudData, cloudRandomData, cloudRate: new Rate(cloudRandomList, cloudRandomWeights) };
  }
  async setup(db) {
    var _a, _b, _c, _d;
    this.db = db;
    this.logger = createChildLogger(this.db.name);
    (_a = this.db).userCount ?? (_a.userCount = 0);
    (_b = this.db).configKeys ?? (_b.configKeys = {});
    (_c = this.db).config ?? (_c.config = appsConfig[this.db.name]);
    (_d = this.db).ranks ?? (_d.ranks = /* @__PURE__ */ new Map());
    this.initCloudData();
    this.db.ranks.forEach((value) => {
      value.top.sort((a, b) => b.score - a.score);
    });
    this.report = Report_default(this.db.id);
    this.logger.info(`Inited app, userCount:${this.db.userCount}, appName:${this.db.name}, appId:${this.db.id}`);
    this.inited = true;
    this.delaySave = cacheCall(async () => {
      try {
        await this.updateDbCaches();
      } catch (error) {
        logger.error(`updateDbCaches ${this.db.name} ${this.db.id}`, error);
      }
    }, 3e4);
    new import_cron.default.CronJob("* 1 0 * * *", this.refreshDaily, null, true, "Europe/London");
  }
  checkKeyword(path3) {
    if (!this.inited)
      return;
    if (import_lodash.default.hasIn(this.db.configKeys, path3))
      return;
    this.logger.info(`new keyword ${path3}`);
    import_lodash.default.setWith(this.db.configKeys, path3, null, Object);
    this.db.markModified("configKeys");
  }
  getDbCache(collectionName, filter) {
    var _a;
    (_a = this.dbCaches)[collectionName] ?? (_a[collectionName] = {});
    const collection = this.dbCaches[collectionName];
    const dbCacheName = JSON.stringify(filter);
    collection[dbCacheName] ?? (collection[dbCacheName] = new DbCache(filter));
    const dbCache = collection[dbCacheName];
    return dbCache;
  }
  collection(name) {
    var _a;
    (_a = this.collections)[name] ?? (_a[name] = import_mongoose4.default.connection.collection(name + "_" + this.db.id));
    return this.collections[name];
  }
  async dailyCleaning() {
    var nowDay = getNowDay();
    var nowHours = getNowHours();
    await this.collection("mission").deleteMany({ day: { "$lt": nowDay - 7 } });
    await this.collection("event").deleteMany({ day: { "$lt": nowDay - 14 } });
    await this.collection("realtime").deleteMany({ hours: { "$lt": nowHours - 168 } });
    await this.collection("userAnalytics").deleteMany({ day: { "$lt": nowDay - 30 } });
    await this.collection("userActive").deleteMany({ day: { "$lt": nowDay - 90 } });
  }
  /**  */
  async refreshDaily() {
    try {
      await this.dailyCleaning();
    } catch (e) {
      this.logger.error("refreshDaily", e);
    }
  }
  async dbSize() {
    let size = 0;
    for (const name of ["realtime", "userAnalytics", "userActive"])
      size += (await this.collection(name).stats()).size;
    return size;
  }
  async updateDbCaches() {
    var lastCachesTime = Date.now();
    var dbCaches = this.dbCaches;
    this.dbCaches = {};
    this.log = { lastTime: new Date(lastCachesTime), count: 0, total: 0, cachesTime: "", preTime: "", caches: {} };
    for (var collName in dbCaches) {
      var collCaches = dbCaches[collName];
      var collLog = { name: collName, count: 0, total: 0 };
      this.log.caches[collName] = collLog;
      for (var dbCacheName in collCaches) {
        collLog.total++;
        this.log.total++;
      }
    }
    try {
      if (this.db.isModified())
        await this.db.save();
    } catch (e) {
      this.logger.error(`updateDbCaches db.save ${this.db.name} ${this.db.id}`, e);
    }
    try {
      var nowDay = getNowDay();
      await this.collection("userActive").updateOne({ day: nowDay }, { $set: { count: this.db.userCount } }, { upsert: true });
    } catch (e) {
      this.logger.error(`updateDbCaches userActive updateOne ${this.db.name} ${this.db.id}`, e);
    }
    for (var collName in dbCaches) {
      var collCaches = dbCaches[collName];
      var coll = this.collection(collName);
      const collLog2 = this.log.caches[collName];
      for (var dbCacheName in collCaches) {
        var dbCache = collCaches[dbCacheName];
        collLog2.count++;
        this.log.count++;
        try {
          await coll.updateOne(dbCache.filter, dbCache.data, { upsert: true });
        } catch (e) {
          this.logger.error(`updateDbCaches updateOne ${this.db.name} ${this.db.id}`, e);
        }
      }
    }
    var cachesTime = Date.now() - lastCachesTime;
    this.log.cachesTime = floatFixed2(cachesTime / 1e3) + "s";
    this.log.preTime = floatFixed(cachesTime / this.log.count, 0) + "ms";
  }
  async login(channel, version, cloud, lang, region, ip, loginTime, first, last) {
    lang || (lang = "unknown");
    if (ip)
      region = getRegion(ip);
    loginTime || (loginTime = Date.now() / 1e3);
    const day = getDayInSeconds(loginTime);
    const hours = getHoursInSeconds(loginTime);
    let isOldActive = false;
    let isActive = false;
    let inc = {
      login: 1,
      [`region.${region}.login`]: 1,
      [`lang.${lang}.login`]: 1
    };
    let incActive = {
      [`channel.${channel}.login`]: 1,
      [`version.${version}.login`]: 1,
      [`cloud.${cloud}.login`]: 1
    };
    if (last == null || last == 0 || isNaN(last)) {
      isActive = true;
      inc.new = 1;
      inc[`region.${region}.new`] = 1;
      inc[`lang.${lang}.new`] = 1;
      incActive[`channel.${channel}.new`] = 1;
      incActive[`version.${version}.new`] = 1;
      incActive[`cloud.${cloud}.new`] = 1;
      this.db.userCount++;
    } else if (day != getDayInSeconds(last)) {
      isActive = true;
      isOldActive = true;
    }
    if (isActive) {
      inc.active = 1;
      inc[`region.${region}.active`] = 1;
      inc[`lang.${lang}.active`] = 1;
      incActive[`channel.${channel}.active`] = 1;
      incActive[`version.${version}.active`] = 1;
      incActive[`cloud.${cloud}.active`] = 1;
    }
    Object.assign(incActive, inc);
    this.getDbCache("realtime", { hours }).inc(incActive);
    this.getDbCache("userActive", { day }).inc(incActive);
    this.getDbCache("userAnalytics", { day, channel, version, cloud }).inc(inc);
    if (isOldActive) {
      let firstDay = getDayInSeconds(first);
      let newDays = day - firstDay;
      if (newDays > 0 && newDays < 30) {
        let incFirstDay = {};
        incFirstDay["new_d" + newDays] = 1;
        this.getDbCache("userActive", { day: firstDay }).inc(incFirstDay);
        this.getDbCache("userAnalytics", { day: firstDay, channel, version, cloud }).inc(incFirstDay);
      }
    }
    this.delaySave();
  }
  async event(channel, version, cloud, key, value, last) {
    const day = getNowDay();
    key || (key = "unknown");
    const inc = {};
    this.checkKeyword(`event.${key}`);
    inc[`event.${key}._value`] = value || 0;
    inc[`event.${key}._count`] = 1;
    if (last == null || last == 0 || isNaN(last)) {
      inc[`event.${key}._new`] = 1;
      inc[`event.${key}._active`] = 1;
    } else if (day != getDayInSeconds(last))
      inc[`event.${key}._active`] = 1;
    this.getDbCache("userActive", { day }).inc(inc);
    this.getDbCache("userAnalytics", { day, channel, version, cloud }).inc(inc);
    this.delaySave();
  }
};
var AppData = _AppData;
AppData.initializing = false;
AppData.apps = {};

// src/gameAnalytics/controllers/admin.ts
var admin_exports = {};
__export(admin_exports, {
  appList: () => appList,
  logout: () => logout
});
init_cjs_shims();
function checkNumber(value) {
  value = parseInt(value);
  if (value <= Number.MAX_VALUE && value >= -Number.MAX_VALUE)
    return value;
  return null;
}
async function logout() {
}
async function appList(query) {
  query.start = checkNumber(query.start) ?? 0;
  query.count = checkNumber(query.count) ?? 50;
  const { start, count, search } = query;
  const list = [];
  const appList2 = (await App.find({})).slice(start, start + count);
  for (const app of appList2) {
    const name = unescape(app.name);
    var appData = await AppData.getAppByName(name);
    const sizeOnDisk = await appData.dbSize();
    if (app.userCount > 5)
      list.push({ name, sizeOnDisk, userCount: app.userCount, icon: "static/icon/" + app.name + ".jpg" });
  }
  return list;
}

// src/gameAnalytics/controllers/adminApp.ts
var adminApp_exports = {};
__export(adminApp_exports, {
  analytics: () => analytics,
  clear: () => clear,
  getConfig: () => getConfig,
  getKeys: () => getKeys,
  realtime: () => realtime,
  setConfig: () => setConfig,
  setKeys: () => setKeys
});
init_cjs_shims();
var import_lodash2 = __toESM(require("lodash"), 1);
function checkNumber2(value) {
  value = parseInt(value);
  if (value <= Number.MAX_VALUE && value >= -Number.MAX_VALUE)
    return value;
  return null;
}
var getKeys = async (query) => {
  return query.appData.db.configKeys;
};
var setKeys = async (query) => {
  query.appData.db.configKeys = query.keys;
};
var getConfig = async (query) => {
  return query.appData.db.config;
};
var setConfig = async (query) => {
  query.appData.db.config = query.config;
  query.appData.initCloudData();
};
async function clear(query) {
  await query.appData.dailyCleaning();
}
function GetDBQuery(query) {
  const dbQuery = {};
  if (query.hoursEnd) {
    query.hoursEnd = checkNumber2(query.hoursEnd);
    query.hoursBegin = checkNumber2(query.hoursBegin) ?? query.hoursEnd - 1;
    dbQuery.hours = { "$gte": query.hoursBegin, "$lte": query.hoursEnd };
  }
  if (query.dayEnd) {
    query.dayEnd = checkNumber2(query.dayEnd);
    query.dayBegin = checkNumber2(query.dayBegin) ?? query.dayEnd - 1;
    dbQuery.day = { "$gte": query.dayBegin, "$lte": query.dayEnd };
  }
  ["hours", "day", "channel", "version", "cloud"].map((t) => {
    const value = query[t];
    if (!value)
      return;
    if (Array.isArray(value))
      dbQuery[t] = { "$in": value };
    else
      dbQuery[t] = value;
  });
  return dbQuery;
}
function flattenObject(object) {
  const result = {};
  function flat(obj2, path3) {
    Object.keys(obj2).forEach((key) => {
      const value = obj2[key];
      if (typeof value === "object")
        flat(value, `${path3}${key}.`);
      else
        result[`${path3}${key}`] = value;
    });
  }
  flat(object, "");
  return result;
}
async function querySeries(query, collection, keys, values) {
  const data = await query.appData.collection(collection).find(GetDBQuery(query)).toArray();
  function customizer(objValue, srcValue) {
    if (import_lodash2.default.isNumber(objValue) && import_lodash2.default.isNumber(srcValue))
      return objValue + srcValue;
  }
  const series = [];
  for (const item of data) {
    const itemKey = flattenObject(import_lodash2.default.pick(item, keys));
    let it = import_lodash2.default.find(series, itemKey);
    if (it == null) {
      it = itemKey;
      series.push(it);
    }
    const itemValue = import_lodash2.default.pick(item, values);
    import_lodash2.default.mergeWith(it, itemValue, customizer);
  }
  return import_lodash2.default.sortBy(series, keys);
}
async function realtime(query) {
  const keys = ["hours"];
  const values = query.values || ["new", "active", "login"];
  return await querySeries(query, "realtime", keys, values);
}
async function analytics(query) {
  const collection = query.channel || query.version || query.cloud ? "userAnalytics" : "userActive";
  const keys = query.keys || ["day"];
  const values = query.values || ["new", "active", "login"];
  return await querySeries(query, collection, keys, values);
}

// src/gameAnalytics/controllers/adminNoauth.ts
var adminNoauth_exports = {};
__export(adminNoauth_exports, {
  getip: () => getip,
  login: () => login,
  register: () => register
});
init_cjs_shims();

// src/gameAnalytics/models/Admin.ts
init_cjs_shims();
var import_mongoose5 = __toESM(require_mongoose(), 1);
var AdminSchema = new import_mongoose5.Schema({
  // username: { type: String, required: [true, ''], minlength: [6, '6'], maxlength: [12, '12'] },
  username: { type: String, index: { unique: true, sparse: true } },
  password: String,
  role: String,
  nickname: String,
  avatar: String
});
var Admin = import_mongoose5.default.model("Admin", AdminSchema);

// src/env.ts
init_cjs_shims();
var MONGO_URI = process.env.MONGO_URI || "mongodb://localhost:27017/analytics";
var JWT_SECRET = process.env.JWT_SECRET || "Lny+5yn%RCTVtq&f#mE@&63BP9BuAJBs";
var FACEBOOK_APP_TOKEN = process.env.FACEBOOK_APP_TOKEN || "353169041992501|8d17708d062493030db44dd687b73e97";
var TWITTER_CONSUMER_KEY = process.env.TWITTER_CONSUMER_KEY || "JehPM5P4UxbVbrEQlrtx6ED2x";
var TWITTER_CONSUMER_SECRET = process.env.TWITTER_CONSUMER_SECRET || "M19cCQwfWvA3vBVsNTULruD9Ez5PzJf0GPpWe2YF7DzQxvEkYU";

// src/gameAnalytics/controllers/adminNoauth.ts
var import_jsonwebtoken = __toESM(require("jsonwebtoken"), 1);
async function register(query) {
  const { username, password } = query;
  const admin = await Admin.findOne({ username });
  if (admin)
    throw new ApiError("\u8D26\u53F7\u5DF2\u7ECF\u5B58\u5728");
  await Admin.insertMany({ username, password });
}
async function login(query) {
  const { username, password } = query;
  if (username == null || username.length < 2 || password == null || password.length < 6)
    throw new ApiError("\u8D26\u53F7\u6216\u5BC6\u7801\u9519\u8BEF(50)");
  const admin = await Admin.findOne({ username, password });
  if (!admin)
    throw new ApiError("\u8D26\u53F7\u6216\u5BC6\u7801\u9519\u8BEF(51)");
  const { role, nickname, avatar } = admin;
  const token = import_jsonwebtoken.default.sign({ _id: admin._id }, JWT_SECRET);
  return { token, role, nickname, avatar };
}
async function getip(query) {
  let { ip } = query;
  ip || (ip = getClientIp(query._req));
  const begin = Date.now();
  const region = getRegion(ip);
  const time = Date.now() - begin;
  return { ip, time, region };
}

// src/gameAnalytics/controllers/index.ts
var controllers_exports = {};
__export(controllers_exports, {
  ad: () => ad,
  adClick: () => adClick,
  adShow: () => adShow,
  config: () => config,
  rankSelf: () => rankSelf,
  rankTop: () => rankTop,
  rankUpdate: () => rankUpdate,
  v1: () => v1,
  v2: () => v2,
  v3: () => v3
});
init_cjs_shims();

// src/gameAnalytics/controllers/analytics.ts
init_cjs_shims();
async function v2(query) {
  if (query.events == null)
    throw new Error("no events");
  query.channel ?? (query.channel = "unknown");
  query.version ?? (query.version = "unknown");
  query.cloud ?? (query.cloud = "unknown");
  query.cloud = query.cloud.replace(/_/g, ".");
  const { appData, channel, version, cloud } = query;
  appData.checkKeyword(`channel.${channel}`);
  appData.checkKeyword(`version.${version}`);
  appData.checkKeyword(`cloud.${cloud}`);
  for (let eventData of query.events) {
    const { id } = eventData;
    if (id == "li")
      appData.login(channel, version, cloud, eventData.lang, query.region, getClientIp(query._req), eventData.login, eventData.first, eventData.last);
    else if (id == "lo")
      appData.event(channel, version, cloud, "logout", eventData.logout - eventData.login);
    else if (id == "ev")
      appData.event(channel, version, cloud, eventData.key, eventData.value);
    else if (id == "me")
      appData.event(channel, version, cloud, `${eventData.key}.${eventData.mission}`, eventData.value);
    else if (id == "pu") {
      appData.event(channel, version, cloud, `purchase.${eventData.sku}`, eventData.response == 0 ? 1 : 0);
    }
  }
}
async function v3(query) {
  if (query.data == null)
    throw new Error("no data");
  query.channel ?? (query.channel = "unknown");
  query.version ?? (query.version = "unknown");
  query.cloud ?? (query.cloud = "unknown");
  query.cloud = query.cloud.replace(/_/g, ".");
  const { appData, channel, version, cloud, lang } = query;
  appData.checkKeyword(`channel.${channel}`);
  appData.checkKeyword(`version.${version}`);
  appData.checkKeyword(`cloud.${cloud}`);
  for (let it of query.data) {
    const id = it[0];
    if (id == "li")
      appData.login(channel, version, cloud, lang, query.region, getClientIp(query._req), null, it[1], it[2]);
    else if (id == "lo")
      appData.event(channel, version, cloud, "logout", it[1], it[2]);
    else if (id == "ev")
      appData.event(channel, version, cloud, it[1], it[2], it[3]);
    else if (id == "rp")
      appData.report?.add("client", it[1], it[2], null, version);
  }
}
async function v1(query) {
  if (query.appProfile == null || query.events == null)
    return;
  query.appName ?? (query.appName = query.appProfile.appName || "unknown");
  query.channel ?? (query.channel = query.appProfile.partner || "unknown");
  query.version ?? (query.version = query.appProfile.version || "unknown");
  query.cloud ?? (query.cloud = query.appProfile.cloud || "unknown");
  query.appName += "v1";
  query.appData = await AppData.getAppByName(query.appName);
  query.cloud = query.cloud.replace(/_/g, ".");
  const { appName, appData, channel, version, cloud } = query;
  appData.checkKeyword(`channel.${channel}`);
  appData.checkKeyword(`version.${version}`);
  appData.checkKeyword(`cloud.${cloud}`);
  var events = query.events;
  for (var i = 0; i < events.length; ++i) {
    var eventData = events[i];
    if (eventData.id == "G9") {
      const { mission, sku, success, value } = eventData.data;
      appData.event(channel, version, cloud, `purchaseSkus.${sku}`, success ? 1 : 0);
      if (success) {
      } else if (value.indexOf("UserCancelled") != -1) {
      } else if (value.indexOf("User canceled") != -1) {
      } else if (value.indexOf("Billing Unavailable") != -1) {
      } else
        console.warn(appName, "purchase ", sku, success, value);
    } else if (eventData.id == "G3") {
      eventData.first || (eventData.first = query.appProfile.installationTime / 1e3);
      if (eventData.data.interval != null) {
        eventData.last || (eventData.last = Date.now() / 1e3 + eventData.data.interval);
        console.log("eventData: " + JSON.stringify(eventData));
      }
      appData.login(channel, version, cloud, query.appProfile.lang, query.appProfile.region, getClientIp(query._req), eventData.login, eventData.first, eventData.last);
    } else if (eventData.id == "G6") {
      const { mission, custom, status } = eventData.data;
      if (status == 1)
        appData.event(channel, version, cloud, `missionEnter.${mission}`, 1);
      else if (status == 2)
        appData.event(channel, version, cloud, `missionSuccess.${mission}`, 1);
      else if (status == 3)
        appData.event(channel, version, cloud, `missionSuccess.${mission}`, 0);
      if (status == 2 && eventData.data.timeConsuming)
        appData.event(channel, version, cloud, `missionDuration.${mission}`, eventData.data.timeConsuming);
      if (custom)
        for (let key in custom)
          appData.event(channel, version, cloud, key, custom[key]);
    }
  }
}

// src/gameAnalytics/controllers/rank.ts
init_cjs_shims();
function getNumberBit(num) {
  let bit = 0;
  while (num > 0) {
    num >>= 1;
    ++bit;
  }
  return bit;
}
async function rankUpdate(query) {
  let lastScore = parseFloat(query.lastScore) || 0;
  let score = parseFloat(query.score);
  const { id, name, expand } = query;
  if (!query.appData.db.ranks.has(query.key))
    query.appData.db.ranks.set(query.key, { top: [], total: 0, counter: [] });
  const rankData = query.appData.db.ranks.get(query.key);
  const { counter, top } = rankData;
  const topCount = top.length;
  const minScore = topCount > 0 ? top[topCount - 1].score : 0;
  if (lastScore > 0) {
    let bit = Math.ceil(Math.log2(lastScore + 1));
    counter[bit] = (counter[bit] || 0) - 1;
  } else
    ++rankData.total;
  if (score > 0) {
    let bit = Math.ceil(Math.log2(lastScore + 1));
    counter[bit] = (counter[bit] || 0) + 1;
  }
  if (score >= minScore || topCount < 100) {
    let i = 0;
    for (; i < topCount; ++i) {
      let item = top[i];
      if (item.id == id) {
        top.splice(i, 1);
        break;
      }
    }
    if (i == topCount && topCount >= 100) {
      top.splice(99);
    }
  }
  if (top.length < 100) {
    top.push({ id, score, name, expand, time: Date.now() });
    top.sort((a, b) => b.score - a.score);
  }
}
async function rankTop(query) {
  return query.appData.db.ranks.get(query.key)?.top;
}
async function rankSelf(query) {
  var rankData = query.appData.db.ranks.get(query.key);
  if (rankData == null) {
    return { rank: 0, over: 1 };
  }
  let id = query.id;
  let score = parseFloat(query.score);
  let counter = rankData.counter;
  let top = rankData.top;
  let topCount = top.length;
  let minScore = topCount > 0 ? top[topCount - 1].score : 0;
  let rank = topCount;
  if (score >= minScore) {
    for (let i = 0; i < topCount; ++i) {
      if (top[i].id == id) {
        rank = i;
        break;
      }
    }
  }
  if (rank >= topCount) {
    let bit = getNumberBit(score);
    let scoreMax = 1 << bit || 0;
    let scoreMin = bit > 0 ? 1 << bit - 1 || 0 : 0;
    rank = Math.floor((counter[bit] || 0) * (score - scoreMin) / (scoreMax - scoreMin));
    --bit;
    for (; bit >= 0; --bit)
      rank += counter[bit] || 0;
    rank = rankData.total - rank;
  }
  return { rank, over: floatFixed((rankData.total - rank) / rankData.total, 4) };
}

// src/gameAnalytics/controllers/ads.ts
init_cjs_shims();
async function adShow(query) {
  const { appData, channel, version, cloud } = query;
  appData.event(channel, version, cloud, "myAdShow", 1);
}
async function adClick(query) {
  const { appData, channel, version, cloud, success } = query;
  appData.event(channel, version, cloud, "myAdClick", parseFloat(success));
}
async function ad(query) {
  const { appData, channel, version, cloud, event, value } = query;
  appData.event(channel, version, cloud, "myAd" + event, parseFloat(value));
}

// src/gameAnalytics/controllers/config.ts
init_cjs_shims();
async function config(query) {
  let level = parseInt(query.level) || 1;
  const version = parseFloat(query.version) || 1;
  let bundleVersion = parseFloat(query.bundleVersion) || 1;
  var channel = query.channel || "unknown";
  const cloud = (query.cloud || "0").replace(/_/g, ".");
  const lang = query.lang || "unknown";
  let debug = query.debug === 1 || query.debug === true;
  let data = {};
  let appCloudData = query.appData.cloudData;
  if (appCloudData != null) {
    data.cloud = cloud;
    if (cloud === "0" || appCloudData.cloudRate.values.indexOf(cloud) == -1) {
      data.cloud = appCloudData.cloudRate.rndValue() || "0";
    }
    data.cloudVersion = getNowDay().toString();
    Object.assign(data, appCloudData.cloudData, appCloudData.cloudRandomData[data.cloud]);
  }
  if (query.appName == "DustSettle") {
    if (lang === "ChineseSimplified" && query.channel === "apple") {
      data.enablePurchase = false;
    }
    if (version >= 1.19) {
      data.enableSkin = true;
    }
    data.spin = [
      [0.35, 0.1, 0.05, 0.3, 0.05, 0.3, 0.2, 0],
      [0.3, 0.1, 0.05, 0.2, 0.05, 0.3, 0.2, 0],
      [0.3, 0.15, 0.1, 0.2, 0.08, 0.3, 0.2, 0],
      [0.3, 0.2, 0.15, 0.2, 0.08, 0.3, 0.2, 0.1]
    ];
  }
  return data;
}

// src/utils/middlewares.ts
init_cjs_shims();
var import_http_status_codes = require("http-status-codes");
var import_express_jwt = __toESM(require("express-jwt"), 1);

// src/utils/polyglot.ts
init_cjs_shims();

// src/utils/string.ts
init_cjs_shims();
function stringFormat(format3, ...args) {
  if (args.length == 1 && typeof args[0] == "object") {
    for (var key in args[0]) {
      var reg = new RegExp("({" + key + "})", "g");
      format3 = format3.replace(reg, args[0][key]);
    }
  } else {
    for (var i = 0; i < args.length; i++) {
      var reg = new RegExp("({[" + i + "]})", "g");
      format3 = format3.replace(reg, args[i]);
    }
  }
  return format3;
}

// src/utils/polyglot.ts
var englishMessages = {
  \u672A\u5206\u914D\u8DEF\u7531: "Unassigned request"
};
var langs = {
  en: englishMessages,
  english: englishMessages
};
function getLang(text, lang = "en", ...args) {
  lang = lang.toLowerCase();
  if (lang != "chinese") {
    const list = langs[lang] ?? langs.en;
    text = list[text] ?? text;
  }
  if (args.length > 0)
    text = stringFormat(text, ...args.map((v) => getLang(v, lang)));
  return text;
}

// src/utils/middlewares.ts
function GetJwtMiddleware(secret, credentialsRequired = true) {
  const jwtMiddleware = (0, import_express_jwt.default)({
    secret,
    algorithms: ["HS256"],
    credentialsRequired,
    userProperty: "body.$payload",
    getToken: function(req) {
      if (req.headers.authorization?.split(" ")[0] === "Bearer")
        return req.headers.authorization.split(" ")[1];
      return req.body?.token;
    }
  });
  return jwtMiddleware;
}
function apiMiddleware(controller, handler, version) {
  return async (req, res, next) => {
    const query = req.body;
    try {
      query._req = req;
      query._id = req.body.$payload?._id;
      if (handler)
        await handler(query);
      const data = await controller(query);
      if (version > 0)
        res.json(data ?? { success: true });
      else
        res.json(data != null ? { success: true, data } : { success: true });
    } catch (e) {
      if (e.message) {
        if (e.args)
          e.message = getLang(e.message, query.l, ...e.args);
        else
          e.message = getLang(e.message, query.l);
      }
      next(e);
    }
  };
}
var errorMiddleware = (err, req, res, _next) => {
  res.status(err.status || import_http_status_codes.StatusCodes.INTERNAL_SERVER_ERROR).json({
    success: false,
    message: err.message,
    errors: err.errors
  });
};
var emptyMiddleware = (req, _res, next) => {
  next(new HTTPException(404, getLang("\u672A\u5206\u914D\u8DEF\u7531", req.body.l)));
};

// src/gameAnalytics/index.ts
var adminAppDataMiddleware = async (req, res, next) => {
  if (req.body.appName) {
    req.body.appName = unescape(req.body.appName);
    req.body.appData = await AppData.getAppByName(req.body.appName);
  } else {
    const appName = (await App.findOne()).name;
    console.log("appName findOne", appName);
    req.body.appName = appName;
    req.body.appData = await AppData.getAppByName(appName);
  }
  next();
};
var appDataMiddleware = async (req, res, next) => {
  var _a;
  (_a = req.body).appName || (_a.appName = "unknown");
  req.body.appName = unescape(req.body.appName);
  req.body.appData = await AppData.getAppByName(req.body.appName);
  next();
};
var reportApiLog = async (e, req, res, next) => {
  const { v: version } = req.body;
  const condition = `'${req.path}' ` + e.message;
  const stackTrace = e instanceof ApiError ? "" : e.stack;
  delete req.body.appData;
  delete req.body._req;
  if (e instanceof ApiError)
    logger.error(`'${req.path}' ${JSON.stringify(req.body)} ` + e.message);
  else
    logger.error(`'${req.path}' ${JSON.stringify(req.body)}`, e);
  next(e);
};
function GetAdminRouter(secret) {
  const router2 = import_express4.default.Router();
  const jwtMiddleware = GetJwtMiddleware(secret);
  const jwtMiddlewareNoauth = GetJwtMiddleware(secret, false);
  for (const key in admin_exports)
    router2.all("/" + key, jwtMiddleware, apiMiddleware(admin_exports[key], null, 1));
  for (const key in adminNoauth_exports)
    router2.all("/" + key, jwtMiddlewareNoauth, apiMiddleware(adminNoauth_exports[key], null, 1));
  for (const key in adminApp_exports)
    router2.all("/" + key, adminAppDataMiddleware, jwtMiddleware, apiMiddleware(adminApp_exports[key], null, 1));
  router2.use(emptyMiddleware, reportApiLog, errorMiddleware);
  return router2;
}
function GetApiRouterForGa() {
  const router2 = import_express4.default.Router();
  router2.use((req, _res, next) => {
    if (req.body.data)
      Object.assign(req.body, JSON.parse(req.body.data));
    next();
  });
  for (const key in controllers_exports)
    router2.all("/" + key, appDataMiddleware, apiMiddleware(controllers_exports[key], null, 0));
  router2.use(emptyMiddleware, reportApiLog, errorMiddleware);
  return router2;
}
function GetApiRouter() {
  const router2 = import_express4.default.Router();
  for (const key in controllers_exports)
    router2.all("/" + key, appDataMiddleware, apiMiddleware(controllers_exports[key], null, 1));
  router2.use(emptyMiddleware, reportApiLog, errorMiddleware);
  return router2;
}

// src/utils/database.ts
init_cjs_shims();
var import_mongoose6 = __toESM(require_mongoose(), 1);
async function connectDatabase(uri, cb) {
  if (import_mongoose6.default.connection.readyState !== 0) {
    if (cb)
      cb(null);
    return;
  }
  try {
    logger.info(`Connecting to ${uri}`);
    await import_mongoose6.default.connect(uri, { useFindAndModify: false, autoIndex: false, useNewUrlParser: true, useUnifiedTopology: true }, cb);
    logger.info(`Successfully connected to ${uri}`);
    import_mongoose6.default.connection.on("disconnected", () => connectDatabase(uri));
  } catch (e) {
    logger.error("Error connecting to database", e);
  }
}

// src/chatgptApi/index.ts
init_cjs_shims();
var import_express5 = __toESM(require("express"), 1);

// src/chatgptApi/chatgpt/index.ts
init_cjs_shims();
var dotenv = __toESM(require("dotenv"), 1);
var import_isomorphic_fetch = require("isomorphic-fetch");
var import_axios = __toESM(require("axios"), 1);

// src/chatgptApi/utils/index.ts
init_cjs_shims();
function sendResponse(options) {
  if (options.type === "Success") {
    return Promise.resolve({
      message: options.message ?? null,
      data: options.data ?? null,
      status: options.type
    });
  }
  return Promise.reject({
    message: options.message ?? "Failed",
    data: options.data ?? null,
    status: options.type
  });
}

// src/chatgptApi/utils/is.ts
init_cjs_shims();
function isNotEmptyString(value) {
  return typeof value === "string" && value.length > 0;
}

// src/chatgptApi/chatgpt/index.ts
var chatgptModule;
async function getChatGPTModule() {
  if (!chatgptModule) {
    chatgptModule = await import("chatgpt");
  }
  return chatgptModule;
}
var ErrorCodeMessage = {
  401: "[OpenAI] \u63D0\u4F9B\u9519\u8BEF\u7684API\u5BC6\u94A5 | Incorrect API key provided",
  403: "[OpenAI] \u670D\u52A1\u5668\u62D2\u7EDD\u8BBF\u95EE\uFF0C\u8BF7\u7A0D\u540E\u518D\u8BD5 | Server refused to access, please try again later",
  502: "[OpenAI] \u9519\u8BEF\u7684\u7F51\u5173 |  Bad Gateway",
  503: "[OpenAI] \u670D\u52A1\u5668\u7E41\u5FD9\uFF0C\u8BF7\u7A0D\u540E\u518D\u8BD5 | Server is busy, please try again later",
  504: "[OpenAI] \u7F51\u5173\u8D85\u65F6 | Gateway Time-out",
  500: "[OpenAI] \u670D\u52A1\u5668\u7E41\u5FD9\uFF0C\u8BF7\u7A0D\u540E\u518D\u8BD5 | Internal Server Error"
};
dotenv.config();
var timeoutMs = !isNaN(+process.env.TIMEOUT_MS) ? +process.env.TIMEOUT_MS : 30 * 1e3;
var apiModel;
if (!process.env.OPENAI_API_KEY && !process.env.OPENAI_ACCESS_TOKEN)
  throw new Error("Missing OPENAI_API_KEY or OPENAI_ACCESS_TOKEN environment variable");
var api;
(async () => {
  if (process.env.OPENAI_API_KEY) {
    const OPENAI_API_MODEL = process.env.OPENAI_API_MODEL;
    const model = isNotEmptyString(OPENAI_API_MODEL) ? OPENAI_API_MODEL : "gpt-3.5-turbo";
    const options = {
      apiKey: process.env.OPENAI_API_KEY,
      completionParams: { model },
      debug: true
    };
    if (isNotEmptyString(process.env.OPENAI_API_BASE_URL))
      options.apiBaseUrl = process.env.OPENAI_API_BASE_URL;
    setupProxy(options);
    const chatgpt = await getChatGPTModule();
    apiModel = "ChatGPTAPI";
  } else {
    const options = {
      accessToken: process.env.OPENAI_ACCESS_TOKEN,
      debug: true
    };
    if (isNotEmptyString(process.env.API_REVERSE_PROXY))
      options.apiReverseProxyUrl = process.env.API_REVERSE_PROXY;
    setupProxy(options);
    apiModel = "ChatGPTUnofficialProxyAPI";
  }
})();
async function chatReplyProcess(message, lastContext, process2) {
  try {
    let options = { timeoutMs };
    if (lastContext) {
      if (apiModel === "ChatGPTAPI")
        options = { parentMessageId: lastContext.parentMessageId };
      else
        options = { ...lastContext };
    }
    const response = await api.sendMessage(message, {
      ...options,
      onProgress: (partialResponse) => {
        process2?.(partialResponse);
      }
    });
    return sendResponse({ type: "Success", data: response });
  } catch (error) {
    const code = error.statusCode;
    global.console.log(error);
    if (Reflect.has(ErrorCodeMessage, code))
      return sendResponse({ type: "Fail", message: ErrorCodeMessage[code] });
    return sendResponse({ type: "Fail", message: error.message ?? "Please check the back-end console" });
  }
}
async function fetchBalance() {
  const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
  const OPENAI_API_BASE_URL = process.env.OPENAI_API_BASE_URL;
  if (!isNotEmptyString(OPENAI_API_KEY))
    return Promise.resolve("-");
  const API_BASE_URL = isNotEmptyString(OPENAI_API_BASE_URL) ? OPENAI_API_BASE_URL : "https://api.openai.com";
  try {
    const headers = { "Content-Type": "application/json", "Authorization": `Bearer ${OPENAI_API_KEY}` };
    const response = await import_axios.default.get(`${API_BASE_URL}/dashboard/billing/credit_grants`, { headers });
    const balance = response.data.total_available ?? 0;
    return Promise.resolve(balance.toFixed(3));
  } catch {
    return Promise.resolve("-");
  }
}
async function chatConfig() {
  const balance = await fetchBalance();
  const reverseProxy = process.env.API_REVERSE_PROXY ?? "-";
  const httpsProxy = (process.env.HTTPS_PROXY || process.env.ALL_PROXY) ?? "-";
  const socksProxy = process.env.SOCKS_PROXY_HOST && process.env.SOCKS_PROXY_PORT ? `${process.env.SOCKS_PROXY_HOST}:${process.env.SOCKS_PROXY_PORT}` : "-";
  return sendResponse({
    type: "Success",
    data: { apiModel, reverseProxy, timeoutMs, socksProxy, httpsProxy, balance }
  });
}
function setupProxy(options) {
}
function currentModel() {
  return apiModel;
}

// src/chatgptApi/middleware/auth.ts
init_cjs_shims();
var auth = async (req, res, next) => {
  const AUTH_SECRET_KEY = process.env.AUTH_SECRET_KEY;
  if (isNotEmptyString(AUTH_SECRET_KEY)) {
    try {
      const Authorization = req.header("Authorization");
      if (!Authorization || Authorization.replace("Bearer ", "").trim() !== AUTH_SECRET_KEY.trim())
        throw new Error("Error: \u65E0\u8BBF\u95EE\u6743\u9650 | No access rights");
      next();
    } catch (error) {
      res.send({ status: "Unauthorized", message: error.message ?? "Please authenticate.", data: null });
    }
  } else {
    next();
  }
};

// src/chatgptApi/middleware/limiter.ts
init_cjs_shims();
var import_express_rate_limit = require("express-rate-limit");
var MAX_REQUEST_PER_HOUR = process.env.MAX_REQUEST_PER_HOUR;
var maxCount = isNotEmptyString(MAX_REQUEST_PER_HOUR) && !isNaN(Number(MAX_REQUEST_PER_HOUR)) ? parseInt(MAX_REQUEST_PER_HOUR) : 0;
var limiter = (0, import_express_rate_limit.rateLimit)({
  windowMs: 60 * 60 * 1e3,
  // Maximum number of accesses within an hour
  max: maxCount,
  statusCode: 200,
  // 200 means successbut the message is 'Too many request from this IP in 1 hour'
  message: async (req, res) => {
    res.send({ status: "Fail", message: "Too many request from this IP in 1 hour", data: null });
  }
});

// src/chatgptApi/index.ts
var router = import_express5.default.Router();
router.post("/chat-process", [auth, limiter], async (req, res) => {
  res.setHeader("Content-type", "application/octet-stream");
  try {
    const { prompt, options = {} } = req.body;
    let firstChunk = true;
    await chatReplyProcess(prompt, options, (chat) => {
      res.write(firstChunk ? JSON.stringify(chat) : `
${JSON.stringify(chat)}`);
      firstChunk = false;
    });
  } catch (error) {
    res.write(JSON.stringify(error));
  } finally {
    res.end();
  }
});
router.post("/config", auth, async (req, res) => {
  try {
    const response = await chatConfig();
    res.send(response);
  } catch (error) {
    res.send(error);
  }
});
router.post("/session", async (req, res) => {
  try {
    const AUTH_SECRET_KEY = process.env.AUTH_SECRET_KEY;
    const hasAuth = isNotEmptyString(AUTH_SECRET_KEY);
    res.send({ status: "Success", message: "", data: { auth: hasAuth, model: currentModel() } });
  } catch (error) {
    res.send({ status: "Fail", message: error.message, data: null });
  }
});
router.post("/verify", async (req, res) => {
  try {
    const { token } = req.body;
    if (!token)
      throw new Error("Secret key is empty");
    if (process.env.AUTH_SECRET_KEY !== token)
      throw new Error("\u5BC6\u94A5\u65E0\u6548 | Secret key is invalid");
    res.send({ status: "Success", message: "Verify successfully", data: null });
  } catch (error) {
    res.send({ status: "Fail", message: error.message, data: null });
  }
});

// src/index.ts
var logger2 = createLogger("api");
async function initGameAnalytics(app) {
  await connectDatabase(MONGO_URI);
  const adminRouter = await GetAdminRouter(JWT_SECRET);
  const apiRouter = await GetApiRouter();
  app.use((0, import_vhost.default)("ga.unityjs.net", adminRouter));
  app.use("/g", (0, import_vhost.default)("api.unityjs.net", await GetApiRouterForGa()));
  app.use("/api/g", apiRouter);
  app.use("/api/admin", adminRouter);
}
function initRelayServer(server) {
  const wss = new import_ws3.default.Server({ server });
  new RelayServer({
    server: wss,
    serverName: "wsss",
    logLevel: "warn",
    callback: async (client) => {
      await remoteMultRelay(client, "wasduijk", "aes-256-cfb");
    }
  });
}
async function main() {
  const app = createExpress();
  app.use(import_express6.default.static(import_path2.default.join(process.cwd(), "public/www")));
  app.use((0, import_vhost.default)("www.cyberpunk.online", import_express6.default.static(import_path2.default.join(process.cwd(), "public/cyberpunk.online"))));
  app.use((0, import_vhost.default)("www.soulgame.cn", import_express6.default.static(import_path2.default.join(process.cwd(), "public/soulgame.cn"))));
  app.use((0, import_vhost.default)("ga.unityjs.net", import_express6.default.static(import_path2.default.join(process.cwd(), "public/ga"))));
  app.use((0, import_vhost.default)("localhost", import_express6.default.static(import_path2.default.join(process.cwd(), "public/cyberpunk.online"))));
  app.use("/api/chat", router);
  initGameAnalytics(app);
  app.use("/http/*", GetProxyRouter());
  app.use("/https/*", GetProxyRouter());
  var useHttps = false;
  if (useHttps) {
    const httpsServer = createServer(app, true);
    httpsServer.listen(443, function() {
      console.log(`Running on ${443}`);
    });
    const server = createRedirectHttpsServer();
    initRelayServer(server);
  } else {
    const server = createServer(app);
    const port = process.env.PORT || 5e3;
    server.listen(port, function() {
      console.log(`Running on ${port}`);
    });
    initRelayServer(server);
  }
}
main();
/*! Bundled license information:

mongoose/lib/driver.js:
  (*!
   * ignore
   *)

mongoose/lib/drivers/node-mongodb-native/binary.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/connectionstate.js:
  (*!
   * Connection states
   *)

mongoose/lib/helpers/immediate.js:
  (*!
   * Centralize this so we can more easily work around issues with people
   * stubbing out `process.nextTick()` in tests using sinon:
   * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time
   * See gh-6074
   *)

mongoose/lib/collection.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/error/mongooseError.js:
  (*!
   * ignore
   *)

mongoose/lib/drivers/node-mongodb-native/objectid.js:
  (*!
   * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId
   * @constructor NodeMongoDbObjectId
   * @see ObjectId
   *)
  (*!
   * ignore
   *)

mongoose/lib/helpers/get.js:
  (*!
   * Simplified lodash.get to work around the annoying null quirk. See:
   * https://github.com/lodash/lodash/issues/3659
   *)

mongoose/lib/helpers/getConstructorName.js:
  (*!
   * If `val` is an object, returns constructor name, if possible. Otherwise returns undefined.
   *)

mongoose/lib/types/objectid.js:
  (*!
   * Getter for convenience with populate, see gh-6115
   *)

mongoose/lib/helpers/isMongooseObject.js:
  (*!
   * Returns if `v` is a mongoose object that has a `toObject()` method we can use.
   *
   * This is for compatibility with libs like Date.js which do foolish things to Natives.
   *
   * @param {any} v
   * @api private
   *)

mongoose/lib/helpers/isBsonType.js:
  (*!
   * Get the bson type, if it exists
   *)

mongoose/lib/helpers/isObject.js:
  (*!
   * Determines if `arg` is an object.
   *
   * @param {Object|Array|String|Function|RegExp|any} arg
   * @api private
   * @return {Boolean}
   *)

mpath/lib/index.js:
  (*!
   * Recursively set nested arrays
   *)
  (*!
   * Returns the value passed to it.
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

mquery/lib/utils.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mquery/lib/mquery.js:
  (*!
   * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
   *
   *     Thing.where('type').nin(array)
   *)
  (*!
   * @ignore
   *)
  (*!
   * limit, skip, maxScan, batchSize, comment
   *
   * Sets these associated options.
   *
   *     query.comment('feed query');
   *)
  (*!
   * Internal helper for update, updateMany, updateOne
   *)
  (*!
   * Permissions
   *)
  (*!
   * Exports.
   *)

mongoose/lib/promise_provider.js:
  (*!
   * ignore
   *)
  (*!
   * Use native promises by default
   *)

mongoose/lib/statemachine.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * StateMachine represents a minimal `interface` for the
   * constructors it builds via StateMachine.ctor(...).
   *
   * @api private
   *)
  (*!
   * StateMachine.ctor('state1', 'state2', ...)
   * A factory method for subclassing StateMachine.
   * The arguments are a list of states. For each state,
   * the constructor's prototype gets state transition
   * methods named after each state. These transition methods
   * place their path argument into the given state.
   *
   * @param {String} state
   * @param {String} [state]
   * @return {Function} subclass constructor
   * @private
   *)
  (*!
   * This function is wrapped by the state change functions:
   *
   * - `require(path)`
   * - `modify(path)`
   * - `init(path)`
   *
   * @api private
   *)
  (*!
   * ignore
   *)
  (*!
   * Checks to see if at least one path is in the states passed in via `arguments`
   * e.g., this.some('required', 'inited')
   *
   * @param {String} state that we want to check for.
   * @private
   *)
  (*!
   * This function builds the functions that get assigned to `forEach` and `map`,
   * since both of those methods share a lot of the same logic.
   *
   * @param {String} iterMethod is either 'forEach' or 'map'
   * @return {Function}
   * @api private
   *)
  (*!
   * Iterates over the paths that belong to one of the parameter states.
   *
   * The function profile can look like:
   * this.forEach(state1, fn);         // iterates over all paths in state1
   * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
   * this.forEach(fn);                 // iterates over all paths in all states
   *
   * @param {String} [state]
   * @param {String} [state]
   * @param {Function} callback
   * @private
   *)
  (*!
   * Maps over the paths that belong to one of the parameter states.
   *
   * The function profile can look like:
   * this.forEach(state1, fn);         // iterates over all paths in state1
   * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
   * this.forEach(fn);                 // iterates over all paths in all states
   *
   * @param {String} [state]
   * @param {String} [state]
   * @param {Function} callback
   * @return {Array}
   * @private
   *)

mongoose/lib/internal.js:
  (*!
   * Dependencies
   *)

mongoose/lib/error/notFound.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/cast.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)
  (*!
   * exports
   *)

mongoose/lib/error/validation.js:
  (*!
   * Module requirements
   *)
  (*!
  * Avoid Node deprecation warning DEP0079
  *)
  (*!
   * Helper for JSON.stringify
   * Ensure `name` and `message` show up in toJSON output re: gh-9847
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports
   *)

mongoose/lib/error/validator.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * The object used to define this validator. Not enumerable to hide
   * it from `require('util').inspect()` output re: gh-3925
   *)
  (*!
   * Formats error messages
   *)
  (*!
   * exports
   *)

mongoose/lib/error/version.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/parallelSave.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/overwriteModel.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/missingSchema.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/divergentArray.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/error/strict.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/error/index.js:
  (*!
   * Module exports.
   *)

mongoose/lib/cast/boolean.js:
  (*!
   * Given a value, cast it to a boolean, or throw a `CastError` if the value
   * cannot be casted. `null` and `undefined` are considered valid.
   *
   * @param {Any} value
   * @param {String} [path] optional the path to set on the CastError
   * @return {Boolean|null|undefined}
   * @throws {CastError} if `value` is not one of the allowed values
   * @api private
   *)

mongoose/lib/schema/operators/exists.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/operators/type.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/schematype/handleImmutable.js:
  (*!
   * ignore
   *)

mongoose/lib/schematype.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * The class that Mongoose uses internally to instantiate this SchemaType's `options` property.
   *)
  (*!
   * ignore
   *)
  (*!
   * Applies setters without casting
   *
   * @api private
   *)
  (*!
   * Handle async validators
   *)
  (*!
   * Just like handleArray, except also allows `[]` because surprisingly
   * `$in: [1, []]` works fine
   *)
  (*!
   * Wraps `castForQuery` to handle context
   *)
  (*!
   * Internal switch for runSetters
   *
   * @api private
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/schema/mixed.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/error/objectExpected.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/error/objectParameter.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/error/parallelValidate.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * exports
   *)

mongoose/lib/virtualtype.js:
  (*!
   * ignore
   *)
  (*!
   * exports
   *)

mongoose/lib/helpers/schema/getIndexes.js:
  (*!
   * Gather all indexes defined in the schema, including single nested,
   * document arrays, and embedded discriminators.
   *)
  (*!
   * Checks for indexes added to subdocs using Schema.index().
   * These indexes need their paths prefixed properly.
   *
   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]
   *)

mongoose/lib/helpers/schema/handleTimestampOption.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/update/applyTimestampsToChildren.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/update/applyTimestampsToUpdate.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/query/applyQueryMiddleware.js:
  (*!
   * ignore
   *)
  (*!
   * Apply query middleware
   *
   * @param {Query} query constructor
   * @param {Model} model
   *)

mongoose/lib/helpers/model/applyHooks.js:
  (*!
   * ignore
   *)
  (*!
   * Register hooks for this model
   *
   * @param {Model} model
   * @param {Schema} schema
   *)

mongoose/lib/options/SchemaStringOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/cast/string.js:
  (*!
   * Given a value, cast it to a string, or throw a `CastError` if the value
   * cannot be casted. `null` and `undefined` are considered valid.
   *
   * @param {Any} value
   * @param {String} [path] optional the path to set on the CastError
   * @return {string|null|undefined}
   * @throws {CastError}
   * @api private
   *)

mongoose/lib/schema/string.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/options/SchemaNumberOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/cast/number.js:
  (*!
   * Given a value, cast it to a number, or throw a `CastError` if the value
   * cannot be casted. `null` and `undefined` are considered valid.
   *
   * @param {Any} value
   * @param {String} [path] optional the path to set on the CastError
   * @return {Boolean|null|undefined}
   * @throws {Error} if `value` is not one of the allowed values
   * @api private
   *)

mongoose/lib/schema/operators/bitwise.js:
  (*!
   * Module requirements.
   *)
  (*!
   * ignore
   *)

mongoose/lib/schema/number.js:
  (*!
   * Module requirements.
   *)
  (*!
   * ignore
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/schema/boolean.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/options/SchemaArrayOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/operators/text.js:
  (*!
   * Casts val to an object suitable for `$text`. Throws an error if the object
   * can't be casted.
   *
   * @param {Any} val value to cast
   * @param {String} [path] path to associate with any errors that occured
   * @return {Object} casted object
   * @see https://docs.mongodb.com/manual/reference/operator/query/text/
   * @api private
   *)

mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js:
  (*!
  * returns discriminator by discriminatorMapping.value
  *
  * @param {Schema} schema
  * @param {string} value
  *)

mongoose/lib/cast.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/schema/operators/helpers.js:
  (*!
   * Module requirements.
   *)
  (*!
   * @ignore
   *)

mongoose/lib/schema/operators/geospatial.js:
  (*!
   * Module requirements.
   *)
  (*!
   * ignore
   *)

mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js:
  (*!
  * returns discriminator by discriminatorMapping.value
  *
  * @param {Model} model
  * @param {string} value
  *)

mongoose/lib/browserDocument.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherit from the NodeJS document
   *)
  (*!
   * ignore
   *)
  (*!
   * Browser doc exposes the event emitter API
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/document_provider.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mongoose/lib/options.js:
  (*!
   * ignore
   *)

mongoose/lib/types/embedded.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherit from Document
   *)
  (*!
   * ignore
   *)
  (*!
   * Registers remove event listeners for triggering
   * on subdocuments.
   *
   * @param {EmbeddedDocument} sub
   * @api private
   *)
  (*!
   * no-op for hooks
   *)
  (*!
  * Avoid Node deprecation warning DEP0079
  *)
  (*!
   * Module exports.
   *)

mongoose/lib/helpers/document/cleanModifiedSubpaths.js:
  (*!
   * ignore
   *)

mongoose/lib/types/core_array.js:
  (*!
   * ignore
   *)

mongoose/lib/types/array.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/types/buffer.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherit from Buffer.
   *)
  (*!
   * Compile other Buffer methods marking this buffer as modified.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/types/documentarray.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * If this is a document array, each element may contain single
   * populated paths, so we need to modify the top-level document's
   * populated cache. See gh-8247, gh-8265.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/types/map.js:
  (*!
   * ignore
   *)
  (*!
   * Since maps are stored as objects under the hood, keys must be strings
   * and can't contain any invalid characters
   *)

mongoose/lib/types/subdocument.js:
  (*!
   * ignore
   *)
  (*!
   * no-op for hooks
   *)
  (*!
   * Registers remove event listeners for triggering
   * on subdocuments.
   *
   * @param {Subdocument} sub
   * @api private
   *)

mongoose/lib/types/index.js:
  (*!
   * Module exports.
   *)

mongoose/lib/schema/array.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * Ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/options/SchemaDocumentArrayOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/document/compile.js:
  (*!
   * exports
   *)
  (*!
   * Compiles schemas.
   *)
  (*!
   * Defines the accessor named prop on the incoming prototype.
   *)

mongoose/lib/helpers/model/discriminator.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/discriminator/getConstructor.js:
  (*!
   * Find the correct constructor, taking into account discriminators
   *)

mongoose/lib/schema/documentarray.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from ArrayType.
   *)
  (*!
   * Ignore
   *)
  (*!
   * ignore
   *)
  (*!
   * Scopes paths selected in a query to this array.
   * Necessary for proper default application of subdocument values.
   *
   * @param {DocumentArrayPath} array - the array to scope `fields` paths
   * @param {Object|undefined} fields - the root fields selected in the query
   * @param {Boolean|undefined} init - if we are being created part of a query result
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/schema/SingleNestedPath.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)
  (*!
   * Special case for when users use a common location schema to represent
   * locations for use with $geoWithin.
   * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/
   *
   * @param {Object} val
   * @api private
   *)

mongoose/lib/options/SchemaBufferOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/buffer.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/options/SchemaDateOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/date.js:
  (*!
   * Module requirements.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Date Query casting.
   *
   * @api private
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/options/SchemaObjectIdOptions.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/objectid.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/schema/decimal128.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from SchemaType.
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/schema/map.js:
  (*!
   * ignore
   *)

mongoose/lib/schema/index.js:
  (*!
   * Module exports.
   *)

mongoose/lib/schema.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Create virtual properties with alias field
   *)
  (*!
   * Inherit from EventEmitter.
   *)
  (*!
   * ignore
   *)
  (*!
   * ignore. Deprecated re: #6405
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/helpers/common.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js:
  (*!
   * Like `schema.path()`, except with a document, because impossible to
   * determine path type without knowing the embedded discriminator key.
   *)

mongoose/lib/plugins/idGetter.js:
  (*!
   * ignore
   *)
  (*!
   * Returns this documents _id cast to a string.
   *)

mongoose/lib/helpers/projection/isDefiningProjection.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/projection/isExclusive.js:
  (*!
   * ignore
   *)

mongoose/lib/queryhelpers.js:
  (*!
   * Module dependencies
   *)
  (*!
   * Prepare a set of path options for query population.
   *
   * @param {Query} query
   * @param {Object} options
   * @return {Array}
   *)
  (*!
   * Prepare a set of path options for query population. This is the MongooseQuery
   * version
   *
   * @param {Query} query
   * @param {Object} options
   * @return {Array}
   *)
  (*!
   * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,
   * it returns an instance of the given model.
   *
   * @param {Model}  model
   * @param {Object} doc
   * @param {Object} fields
   *
   * @return {Document}
   *)
  (*!
   * ignore
   *)
  (*!
   * Set each path query option to lean
   *
   * @param {Object} option
   *)
  (*!
   * Handle the `WriteOpResult` from the server
   *)

mongoose/lib/document.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Document exposes the NodeJS event emitter API, so you can use
   * `on`, `once`, etc.
   *)
  (*!
   * ignore
   *)
  (*!
   * Converts to POJO when you use the document for querying
   *)
  (*!
   * If populating a path within a document array, make sure each
   * subdoc within the array knows its subpaths are populated.
   *
   * ####Example:
   *     const doc = await Article.findOne().populate('comments.author');
   *     doc.comments[0].populated('author'); // Should be set
   *)
  (*!
   * Init helper.
   *
   * @param {Object} self document instance
   * @param {Object} obj raw mongodb doc
   * @param {Object} doc object we are initializing
   * @api private
   *)
  (*!
   * Runs queued functions
   *)
  (*!
   * Minimizes an object, removing undefined values and empty objects
   *
   * @param {Object} object to minimize
   * @return {Object}
   *)
  (*!
   * Applies virtuals properties to `json`.
   *)
  (*!
   * Applies virtuals properties to `json`.
   *
   * @param {Document} self
   * @param {Object} json
   * @return {Object} `json`
   *)
  (*!
   * Applies schema type transforms to `json`.
   *
   * @param {Document} self
   * @param {Object} json
   * @return {Object} `json`
   *)
  (*!
  * Avoid Node deprecation warning DEP0079
  *)
  (*!
   * Module exports.
   *)

mongoose/lib/utils.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Produces a collection name from model `name`. By default, just returns
   * the model name
   *
   * @param {String} name a model name
   * @param {Function} pluralize function that pluralizes the collection name
   * @return {String} a collection name
   * @api private
   *)
  (*!
   * Determines if `a` and `b` are deep equal.
   *
   * Modified from node/lib/assert.js
   *
   * @param {any} a a value to compare to `b`
   * @param {any} b a value to compare to `a`
   * @return {Boolean}
   * @api private
   *)
  (*!
   * Get the last element of an array
   *)
  (*!
   * ignore
   *)
  (*!
   * Shallow copies defaults into options.
   *
   * @param {Object} defaults
   * @param {Object} options
   * @return {Object} the merged object
   * @api private
   *)
  (*!
   * Generates a random string
   *
   * @api private
   *)
  (*!
   * Merges `from` into `to` without overwriting existing properties.
   *
   * @param {Object} to
   * @param {Object} from
   * @api private
   *)
  (*!
   * Applies toObject recursively.
   *
   * @param {Document|Array|Object} obj
   * @return {Object}
   * @api private
   *)
  (*!
   * Determines if `arg` is a plain old JavaScript object (POJO). Specifically,
   * `arg` must be an object but not an instance of any special class, like String,
   * ObjectId, etc.
   *
   * `Object.getPrototypeOf()` is part of ES5: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf
   *
   * @param {Object|Array|String|Function|RegExp|any} arg
   * @api private
   * @return {Boolean}
   *)
  (*!
   * Determines if `obj` is a built-in object like an array, date, boolean,
   * etc.
   *)
  (*!
   * Determines if `val` is an object that has no own keys
   *)
  (*!
   * Search if `obj` or any POJOs nested underneath `obj` has a property named
   * `key`
   *)
  (*!
   * A faster Array.prototype.slice.call(arguments) alternative
   * @api private
   *)
  (*!
   * process.nextTick helper.
   *
   * Wraps `callback` in a try/catch + nextTick.
   *
   * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.
   *
   * @param {Function} callback
   * @api private
   *)
  (*!
   * Returns true if `v` is an object that can be serialized as a primitive in
   * MongoDB
   *)
  (*!
   * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.
   *
   * @param {Object} object
   * @api private
   *)
  (*!
   * populate helper
   *)
  (*!
   * Return the value of `obj` at the given `path`.
   *
   * @param {String} path
   * @param {Object} obj
   *)
  (*!
   * Sets the value of `obj` at the given `path`.
   *
   * @param {String} path
   * @param {Anything} val
   * @param {Object} obj
   *)
  (*!
   * Returns an array of values from object `o`.
   *
   * @param {Object} o
   * @return {Array}
   * @private
   *)
  (*!
   * @see exports.options
   *)
  (*!
   * Safer helper for hasOwnProperty checks
   *
   * @param {Object} obj
   * @param {String} prop
   *)
  (*!
   * Determine if `val` is null or undefined
   *
   * @return {Boolean}
   *)
  (*!
   * Flattens an array.
   *
   * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]
   *
   * @param {Array} arr
   * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsy value, the item will not be included in the results.
   * @return {Array}
   * @private
   *)
  (*!
   * Removes duplicate values from an array
   *
   * [1, 2, 3, 3, 5] => [1, 2, 3, 5]
   * [ ObjectId("550988ba0c19d57f697dc45e"), ObjectId("550988ba0c19d57f697dc45e") ]
   *    => [ObjectId("550988ba0c19d57f697dc45e")]
   *
   * @param {Array} arr
   * @return {Array}
   * @private
   *)
  (*!
   * Determines if two buffers are equal.
   *
   * @param {Buffer} a
   * @param {Object} b
   *)
  (*!
   * Decorate buffers
   *)

mongoose/lib/helpers/clone.js:
  (*!
   * Object clone with Mongoose natives support.
   *
   * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.
   *
   * Functions are never cloned.
   *
   * @param {Object} obj the object to clone
   * @param {Object} options
   * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.
   * @return {Object} the cloned object
   * @api private
   *)
  (*!
   * ignore
   *)

mongoose/lib/drivers/node-mongodb-native/collection.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherit from abstract Collection.
   *)
  (*!
   * ignore
   *)
  (*!
   * Copy the collection methods and make them subject to queues
   *)
  (*!
   * Debug print helper
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/drivers/node-mongodb-native/decimal128.js:
  (*!
   * ignore
   *)

mongoose/lib/drivers/node-mongodb-native/ReadPreference.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Converts arguments to ReadPrefs the driver
   * can understand.
   *
   * @param {String|Array} pref
   * @param {Array} [tags]
   *)

mongoose/lib/cursor/ChangeStream.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mongoose/lib/error/serverSelection.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)

mongoose/lib/connection.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * A list of authentication mechanisms that don't require a password for authentication.
   * This is used by the authMechanismDoesNotRequirePassword method.
   *
   * @api private
   *)
  (*!
   * Inherit from EventEmitter
   *)
  (*!
   * ignore
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/drivers/node-mongodb-native/connection.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from Connection.
   *)
  (*!
   * Register listeners for important events and bubble appropriately.
   *)
  (*!
   * Module exports.
   *)

mongoose/lib/drivers/node-mongodb-native/index.js:
  (*!
   * Module exports.
   *)

mongoose/lib/validoptions.js:
  (*!
   * Valid mongoose options
   *)

mongoose/lib/helpers/cursor/eachAsync.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/cursor/QueryCursor.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Necessary to satisfy the Readable API
   *)
  (*!
   * Marks this cursor as errored
   *)
  (*!
   * ignore
   *)
  (*!
   * Get the next doc from the underlying cursor and mongooseify it
   * (populate, etc.)
   *)
  (*!
   * Convert a raw doc into a full mongoose doc.
   *)

mongoose/lib/helpers/schema/getPath.js:
  (*!
   * Behaves like `Schema#path()`, except for it also digs into arrays without
   * needing to put `.0.`, so `getPath(schema, 'docArr.elProp')` works.
   *)

mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js:
  (*!
   * Like `schema.path()`, except with a document, because impossible to
   * determine path type without knowing the embedded discriminator key.
   *)

mongoose/lib/helpers/query/castUpdate.js:
  (*!
   * Casts an update op based on the given schema
   *
   * @param {Schema} schema
   * @param {Object} obj
   * @param {Object} options
   * @param {Boolean} [options.overwrite] defaults to false
   * @param {Boolean|String} [options.strict] defaults to true
   * @param {Query} context passed to setters
   * @return {Boolean} true iff the update is non-empty
   *)
  (*!
   * ignore
   *)
  (*!
   * Walk each path of obj and cast its values
   * according to its schema.
   *
   * @param {Schema} schema
   * @param {Object} obj - part of a query
   * @param {String} op - the atomic operator ($pull, $set, etc)
   * @param {Object} options
   * @param {Boolean|String} [options.strict]
   * @param {Boolean} [options.omitUndefined]
   * @param {Query} context
   * @param {String} pref - path prefix (internal only)
   * @return {Bool} true if this path has keys to update
   * @api private
   *)
  (*!
   * These operators should be cast to numbers instead
   * of their path schema type.
   *)
  (*!
   * These ops require no casting because the RHS doesn't do anything.
   *)
  (*!
   * These operators require casting docs
   * to real Documents for Update operations.
   *)
  (*!
   * Casts `val` according to `schema` and atomic `op`.
   *
   * @param {SchemaType} schema
   * @param {Object} val
   * @param {String} op - the atomic operator ($pull, $set, etc)
   * @param {String} $conditional
   * @param {Query} context
   * @api private
   *)

mongoose/lib/helpers/query/completeMany.js:
  (*!
   * Given a model and an array of docs, hydrates all the docs to be instances
   * of the model. Used to initialize docs returned from the db from `find()`
   *
   * @param {Model} model
   * @param {Array} docs
   * @param {Object} fields the projection used, including `select` from schemas
   * @param {Object} userProvidedFields the user-specified projection
   * @param {Object} opts
   * @param {Array} [opts.populated]
   * @param {ClientSession} [opts.session]
   * @param {Function} callback
   *)

mongoose/lib/helpers/query/hasDollarKeys.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/projection/isInclusive.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/query/selectPopulatedFields.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/updateValidators.js:
  (*!
   * Module dependencies.
   *)

mongoose/lib/helpers/query/wrapThunk.js:
  (*!
   * A query thunk is the function responsible for sending the query to MongoDB,
   * like `Query#_findOne()` or `Query#_execUpdate()`. The `Query#exec()` function
   * calls a thunk. The term "thunk" here is the traditional Node.js definition:
   * a function that takes exactly 1 parameter, a callback.
   *
   * This function defines common behavior for all query thunks.
   *)

mongoose/lib/query.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * inherit mquery
   *)
  (*!
   * ignore
   *)
  (*!
   * Internal thunk for `deleteOne()`
   *)
  (*!
   * Internal thunk around `deleteMany()`
   *)
  (*!
   * hydrates a document
   *
   * @param {Model} model
   * @param {Document} doc
   * @param {Object} res 3rd parameter to callback
   * @param {Object} fields
   * @param {Query} self
   * @param {Array} [pop] array of paths used in population
   * @param {Function} callback
   *)
  (*!
   * If the model is a discriminator type and not root, then add the key & value to the criteria.
   *)
  (*!
   * Thunk around findOneAndUpdate()
   *
   * @param {Function} [callback]
   * @api private
   *)
  (*!
   * Thunk around findOneAndDelete()
   *
   * @param {Function} [callback]
   * @return {Query} this
   * @api private
   *)
  (*!
   * Thunk around findOneAndReplace()
   *
   * @param {Function} [callback]
   * @return {Query} this
   * @api private
   *)
  (*!
   * Support the `new` option as an alternative to `returnOriginal` for backwards
   * compat.
   *)
  (*!
   * Thunk around findOneAndRemove()
   *
   * @param {Function} [callback]
   * @return {Query} this
   * @api private
   *)
  (*!
   * Get options from query opts, falling back to the base mongoose object.
   *)
  (*!
   * Override mquery.prototype._findAndModify to provide casting etc.
   *
   * @param {String} type - either "remove" or "update"
   * @param {Function} callback
   * @api private
   *)
  (*!
   * Override mquery.prototype._mergeUpdate to handle mongoose objects in
   * updates.
   *
   * @param {Object} doc
   * @api private
   *)
  (*!
   * The mongodb driver 1.3.23 only supports the nested array sort
   * syntax. We must convert it or sorting findAndModify will not work.
   *)
  (*!
   * Mongoose calls this function internally to validate the query if
   * `runValidators` is set
   *
   * @param {Object} castedDoc the update, after casting
   * @param {Object} options the options from `_optionsForExec()`
   * @param {Function} callback
   * @api private
   *)
  (*!
   * Internal thunk for .update()
   *
   * @param {Function} callback
   * @see Model.update #model_Model.update
   * @api private
   *)
  (*!
   * Internal thunk for .updateMany()
   *
   * @param {Function} callback
   * @see Model.update #model_Model.update
   * @api private
   *)
  (*!
   * Internal thunk for .updateOne()
   *
   * @param {Function} callback
   * @see Model.update #model_Model.update
   * @api private
   *)
  (*!
   * Internal thunk for .replaceOne()
   *
   * @param {Function} callback
   * @see Model.replaceOne #model_Model.replaceOne
   * @api private
   *)
  (*!
   * Internal helper for update, updateMany, updateOne, replaceOne
   *)
  (*!
   * Get the error to throw for `orFail()`
   *)
  (*!
   * Casts obj for an update command.
   *
   * @param {Object} obj
   * @return {Object} obj after casting its values
   * @api private
   *)
  (*!
   * castQuery
   * @api private
   *)
  (*!
   * castDoc
   * @api private
   *)
  (*!
   * Overwriting mquery is needed to support a couple different near() forms found in older
   * versions of mongoose
   * near([1,1])
   * near(1,1)
   * near(field, [1,2])
   * near(field, 1, 2)
   * In addition to all of the normal forms supported by mquery
   *)
  (*!
   * this is needed to support the mongoose syntax of:
   * box(field, { ll : [x,y], ur : [x2,y2] })
   * box({ ll : [x,y], ur : [x2,y2] })
   *)
  (*!
   * Export
   *)

mongoose/lib/cursor/AggregationCursor.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * ignore
   *)
  (*!
   * Necessary to satisfy the Readable API
   *)
  (*!
   * Marks this cursor as errored
   *)
  (*!
   * Get the next doc from the underlying cursor and mongooseify it
   * (populate, etc.)
   *)

mongoose/lib/aggregate.js:
  (*!
   * Module dependencies
   *)
  (*!
   * define methods
   *)
  (*!
   * Helpers
   *)
  (*!
   * Adds the appropriate `$match` pipeline step to the top of an aggregate's
   * pipeline, should it's model is a non-root discriminator type. This is
   * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.
   *
   * @param {Aggregate} aggregate Aggregate to prepare
   *)
  (*!
   * Exports
   *)

mongoose/lib/helpers/model/applyMethods.js:
  (*!
   * Register methods for this model
   *
   * @param {Model} model
   * @param {Schema} schema
   *)

mongoose/lib/helpers/model/applyStatics.js:
  (*!
   * Register statics for this model
   * @param {Model} model
   * @param {Schema} schema
   *)

mongoose/lib/helpers/populate/leanPopulateMap.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js:
  (*!
   * Assign `vals` returned by mongo query to the `rawIds`
   * structure returned from utils.getVals() honoring
   * query sort order if specified by user.
   *
   * This can be optimized.
   *
   * Rules:
   *
   *   if the value of the path is not an array, use findOne rules, else find.
   *   for findOne the results are assigned directly to doc path (including null results).
   *   for find, if user specified sort order, results are assigned directly
   *   else documents are put back in original order of array if found in results
   *
   * @param {Array} rawIds
   * @param {Array} vals
   * @param {Boolean} sort
   * @api private
   *)

mongoose/lib/helpers/populate/getVirtual.js:
  (*!
   * ignore
   *)

sift/es5m/index.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

mongoose/lib/helpers/populate/assignVals.js:
  (*!
   * 1) Apply backwards compatible find/findOne behavior to sub documents
   *
   *    find logic:
   *      a) filter out non-documents
   *      b) remove _id from sub docs when user specified
   *
   *    findOne
   *      a) if no doc found, set to null
   *      b) remove _id from sub docs when user specified
   *
   * 2) Remove _ids when specified by users query.
   *
   * background:
   * _ids are left in the query even when user excludes them so
   * that population mapping can occur.
   *)
  (*!
   * Remove _id from `subdoc` if user specified "lean" query option
   *)
  (*!
   * Determine if `obj` is something we can set a populated path to. Can be a
   * document, a lean document, or an array/map that contains docs.
   *)

mongoose/lib/helpers/model/castBulkWrite.js:
  (*!
   * Given a model and a bulkWrite op, return a thunk that handles casting and
   * validating the individual op.
   *)
  (*!
   * gets discriminator model if discriminator key is present in object
   *)

mongoose/lib/helpers/populate/createPopulateQueryFilter.js:
  (*!
   * Optionally filter out invalid ids that don't conform to foreign field's schema
   * to avoid cast errors (gh-7706)
   *)
  (*!
   * Format `mod.match` given that it may be an array that we need to $or if
   * the client has multiple docs with match functions
   *)

mongoose/lib/helpers/projection/isPathExcluded.js:
  (*!
   * Determines if `path` is excluded by `projection`
   *
   * @param {Object} projection
   * @param {string} path
   * @return {Boolean}
   *)

mongoose/lib/helpers/populate/getSchemaTypes.js:
  (*!
   * ignore
   *)
  (*!
   * @param {Schema} schema
   * @param {Object} doc POJO
   * @param {string} path
   *)

mongoose/lib/helpers/populate/getModelsMapForPopulate.js:
  (*!
   * ignore
   *)
  (*!
   * Retrieve the _id of `val` if a Document or Array of Documents.
   *
   * @param {Array|Document|Any} val
   * @return {Array|Document|Any}
   *)

mongoose/lib/helpers/projection/isPathSelectedInclusive.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/parallelLimit.js:
  (*!
   * ignore
   *)

mongoose/lib/helpers/populate/removeDeselectedForeignField.js:
  (*!
   * ignore
   *)

mongoose/lib/model.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Inherits from Document.
   *
   * All Model.prototype features are available on
   * top level (non-sub) documents.
   *)
  (*!
   * Compiled middleware for this model. Set in `applyHooks()`.
   *
   * @api private
   * @property _middleware
   * @memberOf Model
   * @static
   *)
  (*!
   * ignore
   *)
  (*!
   * Determines whether versioning should be skipped for the given path
   *
   * @param {Document} self
   * @param {String} path
   * @return {Boolean} true if versioning should be skipped for the given path
   *)
  (*!
   * Apply the operation to the delta (update) clause as
   * well as track versioning for our where clause.
   *
   * @param {Document} self
   * @param {Object} where
   * @param {Object} delta
   * @param {Object} data
   * @param {Mixed} val
   * @param {String} [operation]
   *)
  (*!
   * Compiles an update and where clause for a `val` with _atomics.
   *
   * @param {Document} self
   * @param {Object} where
   * @param {Object} delta
   * @param {Object} data
   * @param {Array} value
   *)
  (*!
   * Determine if array was populated with some form of filter and is now
   * being updated in a manner which could overwrite data unintentionally.
   *
   * @see https://github.com/Automattic/mongoose/issues/1334
   * @param {Document} doc
   * @param {String} path
   * @return {String|undefined}
   *)
  (*!
   * Make sure `this` is a model
   *)
  (*!
   * Give the constructor the ability to emit events.
   *)
  (*!
   * Connection instance the model uses.
   *
   * @property db
   * @api public
   * @memberOf Model
   *)
  (*!
   * Collection the model uses.
   *
   * @property collection
   * @api public
   * @memberOf Model
   *)
  (*!
   * Decorate the update with a version key, if necessary
   *)
  (*!
   * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`
   * because they need to do the same thing
   *)
  (*!
   * Populate helper
   *
   * @param {Model} model the model to use
   * @param {Document|Array} docs Either a single document or array of documents to populate.
   * @param {Object} paths
   * @param {Function} [cb(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.
   * @return {Function}
   * @api private
   *)
  (*!
   * Populates `docs`
   *)
  (*!
   * Compiler utility.
   *
   * @param {String|Function} name model name or class extending Model
   * @param {Schema} schema
   * @param {String} collectionName
   * @param {Connection} connection
   * @param {Mongoose} base mongoose instance
   *)
  (*!
   * Register custom query methods for this model
   *
   * @param {Model} model
   * @param {Schema} schema
   *)
  (*!
   * Subclass this model with `conn`, `schema`, and `collection` settings.
   *
   * @param {Connection} conn
   * @param {Schema} [schema]
   * @param {String} [collection]
   * @return {Model}
   *)
  (*!
  * Avoid Node deprecation warning DEP0079
  *)
  (*!
   * Module exports.
   *)

mongoose-legacy-pluralize/index.js:
  (*!
   * Pluralize function.
   *
   * @author TJ Holowaychuk (extracted from _ext.js_)
   * @param {String} string to pluralize
   * @api private
   *)

mongoose/lib/plugins/removeSubdocs.js:
  (*!
   * ignore
   *)

mongoose/lib/plugins/saveSubdocs.js:
  (*!
   * ignore
   *)

mongoose/lib/plugins/validateBeforeSave.js:
  (*!
   * ignore
   *)

mongoose/lib/plugins/sharding.js:
  (*!
   * ignore
   *)

mongoose/lib/index.js:
  (*!
   * Module dependencies.
   *)
  (*!
   * Connection
   *)
  (*!
   * Collection
   *)
  (*!
   * ignore
   *)
  (*!
   * The exports object is an instance of Mongoose.
   *
   * @api public
   *)
*/
//# sourceMappingURL=index.cjs.map